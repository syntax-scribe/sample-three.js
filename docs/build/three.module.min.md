[â¬…ï¸ Back to Table of Contents](../index.md)

# ğŸ“„ `three.module.min.js`

## ğŸ“Š Analysis Summary

| Metric | Count |
|--------|-------|
| ğŸ”§ Functions | 498 |
| ğŸ§± Classes | 11 |
| ğŸ“¦ Imports | 186 |
| ğŸ“Š Variables & Constants | 995 |
| ğŸ”„ Re-exports | 1 |

## ğŸ“š Table of Contents

- [Imports](#imports)
- [Variables & Constants](#variables-constants)
- [Re-exports](#re-exports)
- [Functions](#functions)
- [Classes](#classes)

## ğŸ› ï¸ File Location:
ğŸ“‚ **`build/three.module.min.js`**

## ğŸ“¦ Imports

| Name | Source |
|------|--------|
| `e` | `./three.core.min.js` |
| `t` | `./three.core.min.js` |
| `n` | `./three.core.min.js` |
| `r` | `./three.core.min.js` |
| `i` | `./three.core.min.js` |
| `a` | `./three.core.min.js` |
| `o` | `./three.core.min.js` |
| `s` | `./three.core.min.js` |
| `l` | `./three.core.min.js` |
| `c` | `./three.core.min.js` |
| `d` | `./three.core.min.js` |
| `u` | `./three.core.min.js` |
| `f` | `./three.core.min.js` |
| `p` | `./three.core.min.js` |
| `m` | `./three.core.min.js` |
| `h` | `./three.core.min.js` |
| `_` | `./three.core.min.js` |
| `g` | `./three.core.min.js` |
| `v` | `./three.core.min.js` |
| `E` | `./three.core.min.js` |
| `S` | `./three.core.min.js` |
| `T` | `./three.core.min.js` |
| `M` | `./three.core.min.js` |
| `x` | `./three.core.min.js` |
| `R` | `./three.core.min.js` |
| `A` | `./three.core.min.js` |
| `b` | `./three.core.min.js` |
| `C` | `./three.core.min.js` |
| `L` | `./three.core.min.js` |
| `P` | `./three.core.min.js` |
| `U` | `./three.core.min.js` |
| `D` | `./three.core.min.js` |
| `w` | `./three.core.min.js` |
| `y` | `./three.core.min.js` |
| `I` | `./three.core.min.js` |
| `N` | `./three.core.min.js` |
| `O` | `./three.core.min.js` |
| `F` | `./three.core.min.js` |
| `B` | `./three.core.min.js` |
| `H` | `./three.core.min.js` |
| `G` | `./three.core.min.js` |
| `V` | `./three.core.min.js` |
| `z` | `./three.core.min.js` |
| `k` | `./three.core.min.js` |
| `W` | `./three.core.min.js` |
| `X` | `./three.core.min.js` |
| `Y` | `./three.core.min.js` |
| `K` | `./three.core.min.js` |
| `q` | `./three.core.min.js` |
| `j` | `./three.core.min.js` |
| `Z` | `./three.core.min.js` |
| `$` | `./three.core.min.js` |
| `Q` | `./three.core.min.js` |
| `J` | `./three.core.min.js` |
| `ee` | `./three.core.min.js` |
| `te` | `./three.core.min.js` |
| `ne` | `./three.core.min.js` |
| `re` | `./three.core.min.js` |
| `ie` | `./three.core.min.js` |
| `ae` | `./three.core.min.js` |
| `oe` | `./three.core.min.js` |
| `se` | `./three.core.min.js` |
| `le` | `./three.core.min.js` |
| `ce` | `./three.core.min.js` |
| `de` | `./three.core.min.js` |
| `ue` | `./three.core.min.js` |
| `fe` | `./three.core.min.js` |
| `pe` | `./three.core.min.js` |
| `me` | `./three.core.min.js` |
| `he` | `./three.core.min.js` |
| `_e` | `./three.core.min.js` |
| `ge` | `./three.core.min.js` |
| `ve` | `./three.core.min.js` |
| `Ee` | `./three.core.min.js` |
| `Se` | `./three.core.min.js` |
| `Te` | `./three.core.min.js` |
| `Me` | `./three.core.min.js` |
| `xe` | `./three.core.min.js` |
| `Re` | `./three.core.min.js` |
| `Ae` | `./three.core.min.js` |
| `be` | `./three.core.min.js` |
| `Ce` | `./three.core.min.js` |
| `Le` | `./three.core.min.js` |
| `Pe` | `./three.core.min.js` |
| `Ue` | `./three.core.min.js` |
| `De` | `./three.core.min.js` |
| `we` | `./three.core.min.js` |
| `ye` | `./three.core.min.js` |
| `Ie` | `./three.core.min.js` |
| `Ne` | `./three.core.min.js` |
| `Oe` | `./three.core.min.js` |
| `Fe` | `./three.core.min.js` |
| `Be` | `./three.core.min.js` |
| `He` | `./three.core.min.js` |
| `Ge` | `./three.core.min.js` |
| `Ve` | `./three.core.min.js` |
| `ze` | `./three.core.min.js` |
| `ke` | `./three.core.min.js` |
| `We` | `./three.core.min.js` |
| `Xe` | `./three.core.min.js` |
| `Ye` | `./three.core.min.js` |
| `Ke` | `./three.core.min.js` |
| `qe` | `./three.core.min.js` |
| `je` | `./three.core.min.js` |
| `Ze` | `./three.core.min.js` |
| `$e` | `./three.core.min.js` |
| `Qe` | `./three.core.min.js` |
| `Je` | `./three.core.min.js` |
| `et` | `./three.core.min.js` |
| `tt` | `./three.core.min.js` |
| `nt` | `./three.core.min.js` |
| `rt` | `./three.core.min.js` |
| `it` | `./three.core.min.js` |
| `at` | `./three.core.min.js` |
| `ot` | `./three.core.min.js` |
| `st` | `./three.core.min.js` |
| `lt` | `./three.core.min.js` |
| `ct` | `./three.core.min.js` |
| `dt` | `./three.core.min.js` |
| `ut` | `./three.core.min.js` |
| `ft` | `./three.core.min.js` |
| `pt` | `./three.core.min.js` |
| `mt` | `./three.core.min.js` |
| `ht` | `./three.core.min.js` |
| `_t` | `./three.core.min.js` |
| `gt` | `./three.core.min.js` |
| `vt` | `./three.core.min.js` |
| `Et` | `./three.core.min.js` |
| `St` | `./three.core.min.js` |
| `Tt` | `./three.core.min.js` |
| `Mt` | `./three.core.min.js` |
| `xt` | `./three.core.min.js` |
| `Rt` | `./three.core.min.js` |
| `At` | `./three.core.min.js` |
| `bt` | `./three.core.min.js` |
| `Ct` | `./three.core.min.js` |
| `Lt` | `./three.core.min.js` |
| `Pt` | `./three.core.min.js` |
| `Ut` | `./three.core.min.js` |
| `Dt` | `./three.core.min.js` |
| `wt` | `./three.core.min.js` |
| `yt` | `./three.core.min.js` |
| `It` | `./three.core.min.js` |
| `Nt` | `./three.core.min.js` |
| `Ot` | `./three.core.min.js` |
| `Ft` | `./three.core.min.js` |
| `Bt` | `./three.core.min.js` |
| `Ht` | `./three.core.min.js` |
| `Gt` | `./three.core.min.js` |
| `Vt` | `./three.core.min.js` |
| `zt` | `./three.core.min.js` |
| `kt` | `./three.core.min.js` |
| `Wt` | `./three.core.min.js` |
| `Xt` | `./three.core.min.js` |
| `Yt` | `./three.core.min.js` |
| `Kt` | `./three.core.min.js` |
| `qt` | `./three.core.min.js` |
| `jt` | `./three.core.min.js` |
| `Zt` | `./three.core.min.js` |
| `$t` | `./three.core.min.js` |
| `Qt` | `./three.core.min.js` |
| `Jt` | `./three.core.min.js` |
| `en` | `./three.core.min.js` |
| `tn` | `./three.core.min.js` |
| `nn` | `./three.core.min.js` |
| `rn` | `./three.core.min.js` |
| `an` | `./three.core.min.js` |
| `on` | `./three.core.min.js` |
| `sn` | `./three.core.min.js` |
| `ln` | `./three.core.min.js` |
| `cn` | `./three.core.min.js` |
| `dn` | `./three.core.min.js` |
| `un` | `./three.core.min.js` |
| `fn` | `./three.core.min.js` |
| `pn` | `./three.core.min.js` |
| `mn` | `./three.core.min.js` |
| `hn` | `./three.core.min.js` |
| `_n` | `./three.core.min.js` |
| `gn` | `./three.core.min.js` |
| `vn` | `./three.core.min.js` |
| `En` | `./three.core.min.js` |
| `Sn` | `./three.core.min.js` |
| `Tn` | `./three.core.min.js` |
| `Mn` | `./three.core.min.js` |
| `xn` | `./three.core.min.js` |
| `Rn` | `./three.core.min.js` |


---

## Variables & Constants

| Name | Type | Kind | Value | Exported |
|------|------|------|-------|----------|
| `e` | `any` | let/var | `null` | âœ— |
| `t` | `boolean` | let/var | `!1` | âœ— |
| `n` | `any` | let/var | `null` | âœ— |
| `r` | `any` | let/var | `null` | âœ— |
| `t` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `r` | `any` | let/var | `t.array` | âœ— |
| `i` | `any` | let/var | `t.usage` | âœ— |
| `a` | `any` | let/var | `r.byteLength` | âœ— |
| `s` | `any` | let/var | `*not shown*` | âœ— |
| `i` | `any` | let/var | `n.array` | âœ— |
| `a` | `any` | let/var | `n.updateRanges` | âœ— |
| `t` | `number` | let/var | `0` | âœ— |
| `n` | `any` | let/var | `a[t]` | âœ— |
| `r` | `any` | let/var | `a[e]` | âœ— |
| `n` | `any` | let/var | `a[t]` | âœ— |
| `Cn` | `{ alphahash_fragment: string; alphaha...` | let/var | `{alphahash_fragment:"#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHa...` | âœ— |
| `Ln` | `{ common: { diffuse: { value: $r; }; ...` | let/var | `{common:{diffuse:{value:new n(16777215)},opacity:{value:1},map:{value:null},m...` | âœ— |
| `Pn` | `{ basic: { uniforms: {}; vertexShader...` | let/var | `{basic:{uniforms:r([Ln.common,Ln.specularmap,Ln.envmap,Ln.aomap,Ln.lightmap,L...` | âœ— |
| `Un` | `{ r: number; b: number; g: number; }` | let/var | `{r:0,b:0,g:0}` | âœ— |
| `Dn` | `yr` | let/var | `new u` | âœ— |
| `wn` | `nr` | let/var | `new f` | âœ— |
| `E` | `$r` | let/var | `new n(0)` | âœ— |
| `S` | `any` | let/var | `*not shown*` | âœ— |
| `T` | `any` | let/var | `*not shown*` | âœ— |
| `M` | `number` | let/var | `!0===f?0:1` | âœ— |
| `x` | `any` | let/var | `null` | âœ— |
| `R` | `number` | let/var | `0` | âœ— |
| `A` | `any` | let/var | `null` | âœ— |
| `n` | `any` | let/var | `!0===e.isScene?e.background:null` | âœ— |
| `n` | `boolean` | let/var | `!1` | âœ— |
| `r` | `{}` | let/var | `{}` | âœ— |
| `a` | `{ geometry: any; program: any; wirefr...` | let/var | `i` | âœ— |
| `o` | `boolean` | let/var | `!1` | âœ— |
| `t` | `any[]` | let/var | `[]` | âœ— |
| `r` | `any[]` | let/var | `[]` | âœ— |
| `i` | `any[]` | let/var | `[]` | âœ— |
| `e` | `number[]` | let/var | `a.newAttributes` | âœ— |
| `r` | `number[]` | let/var | `a.newAttributes` | âœ— |
| `i` | `number[]` | let/var | `a.enabledAttributes` | âœ— |
| `o` | `number[]` | let/var | `a.attributeDivisors` | âœ— |
| `t` | `number[]` | let/var | `a.newAttributes` | âœ— |
| `n` | `number[]` | let/var | `a.enabledAttributes` | âœ— |
| `g` | `boolean` | let/var | `!1` | âœ— |
| `a` | `boolean` | let/var | `!0===i.wireframe` | âœ— |
| `o` | `any` | let/var | `r[t.id]` | âœ— |
| `s` | `any` | let/var | `o[n.id]` | âœ— |
| `l` | `any` | let/var | `s[a]` | âœ— |
| `i` | `{}` | let/var | `a.attributes` | âœ— |
| `o` | `any` | let/var | `t.attributes` | âœ— |
| `s` | `number` | let/var | `0` | âœ— |
| `n` | `any` | let/var | `i[t]` | âœ— |
| `r` | `any` | let/var | `o[t]` | âœ— |
| `i` | `{}` | let/var | `{}` | âœ— |
| `o` | `any` | let/var | `t.attributes` | âœ— |
| `s` | `number` | let/var | `0` | âœ— |
| `n` | `any` | let/var | `o[t]` | âœ— |
| `r` | `{ attribute: any; data: any; }` | let/var | `{}` | âœ— |
| `o` | `any` | let/var | `a.attributes` | âœ— |
| `l` | `any` | let/var | `r.defaultAttributeValues` | âœ— |
| `i` | `any` | let/var | `s[r]` | âœ— |
| `s` | `any` | let/var | `o[r]` | âœ— |
| `r` | `any` | let/var | `s.normalized` | âœ— |
| `o` | `any` | let/var | `s.itemSize` | âœ— |
| `c` | `any` | let/var | `l.buffer` | âœ— |
| `d` | `any` | let/var | `l.type` | âœ— |
| `p` | `any` | let/var | `l.bytesPerElement` | âœ— |
| `h` | `boolean` | let/var | `d===e.INT\|\|d===e.UNSIGNED_INT\|\|s.gpuType===v` | âœ— |
| `t` | `any` | let/var | `s.data` | âœ— |
| `l` | `any` | let/var | `t.stride` | âœ— |
| `_` | `any` | let/var | `s.offset` | âœ— |
| `t` | `any` | let/var | `l[r]` | âœ— |
| `t` | `any` | let/var | `r[e]` | âœ— |
| `n` | `any` | let/var | `t[e]` | âœ— |
| `t` | `any` | let/var | `r[e.id]` | âœ— |
| `n` | `any` | let/var | `t[e]` | âœ— |
| `n` | `any` | let/var | `r[t]` | âœ— |
| `i` | `any` | let/var | `n[e.id]` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `o` | `number` | let/var | `0` | âœ— |
| `t` | `number` | let/var | `0` | âœ— |
| `i` | `any` | let/var | `*not shown*` | âœ— |
| `o` | `any` | let/var | `void 0!==n.precision?n.precision:"highp"` | âœ— |
| `l` | `boolean` | let/var | `!0===n.logarithmicDepthBuffer` | âœ— |
| `c` | `any` | let/var | `!0===n.reversedDepthBuffer&&t.has("EXT_clip_control")` | âœ— |
| `i` | `any` | let/var | `n===E&&(t.has("EXT_color_buffer_half_float")\|\|t.has("EXT_color_buffer_float"))` | âœ— |
| `n` | `this` | let/var | `this` | âœ— |
| `r` | `any` | let/var | `null` | âœ— |
| `i` | `number` | let/var | `0` | âœ— |
| `a` | `boolean` | let/var | `!1` | âœ— |
| `o` | `boolean` | let/var | `!1` | âœ— |
| `s` | `ro` | let/var | `new x` | âœ— |
| `l` | `es` | let/var | `new e` | âœ— |
| `c` | `{ value: any; needsUpdate: boolean; }` | let/var | `{value:null,needsUpdate:!1}` | âœ— |
| `a` | `any` | let/var | `null!==e?e.length:0` | âœ— |
| `o` | `any` | let/var | `null` | âœ— |
| `n` | `any` | let/var | `r+4*a` | âœ— |
| `i` | `any` | let/var | `t.matrixWorldInverse` | âœ— |
| `n` | `any` | let/var | `0!==e.length\|\|t\|\|0!==i\|\|a` | âœ— |
| `u` | `any` | let/var | `e.clippingPlanes` | âœ— |
| `f` | `any` | let/var | `e.clipIntersection` | âœ— |
| `p` | `any` | let/var | `e.clipShadows` | âœ— |
| `e` | `number` | let/var | `o?0:i` | âœ— |
| `t` | `number` | let/var | `4*e` | âœ— |
| `n` | `any` | let/var | `m.clippingState\|\|null` | âœ— |
| `t` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `n` | `any` | let/var | `e.target` | âœ— |
| `a` | `any` | let/var | `i.mapping` | âœ— |
| `a` | `any` | let/var | `i.image` | âœ— |
| `o` | `ia` | let/var | `new b(a.height)` | âœ— |
| `Hn` | `number[]` | let/var | `[.125,.215,.35,.446,.526,.582]` | âœ— |
| `Gn` | `20` | let/var | `20` | âœ— |
| `Vn` | `Fc` | let/var | `new P` | âœ— |
| `zn` | `$r` | let/var | `new n` | âœ— |
| `kn` | `any` | let/var | `null` | âœ— |
| `Wn` | `number` | let/var | `0` | âœ— |
| `Xn` | `number` | let/var | `0` | âœ— |
| `Yn` | `boolean` | let/var | `!1` | âœ— |
| `Kn` | `number` | let/var | `(1+Math.sqrt(5))/2` | âœ— |
| `qn` | `number` | let/var | `1/Kn` | âœ— |
| `jn` | `Qi[]` | let/var | `[new i(-Kn,qn,0),new i(Kn,qn,0),new i(-qn,0,Kn),new i(qn,0,Kn),new i(0,Kn,-qn...` | âœ— |
| `Zn` | `Qi` | let/var | `new i` | âœ— |
| `n` | `any` | let/var | `t\|\|this._allocateTargets()` | âœ— |
| `e` | `number` | let/var | `3*Math.max(this._cubeSize,112)` | âœ— |
| `t` | `number` | let/var | `4*this._cubeSize` | âœ— |
| `n` | `{ magFilter: number; minFilter: numbe...` | let/var | `{magFilter:B,minFilter:B,generateMipmaps:!1,type:E,format:M,colorSpace:F,dept...` | âœ— |
| `t` | `any[]` | let/var | `[]` | âœ— |
| `n` | `any[]` | let/var | `[]` | âœ— |
| `r` | `any[]` | let/var | `[]` | âœ— |
| `i` | `number` | let/var | `e` | âœ— |
| `a` | `number` | let/var | `e-4+1+Hn.length` | âœ— |
| `s` | `number` | let/var | `1/a` | âœ— |
| `l` | `number` | let/var | `1/(a-2)` | âœ— |
| `c` | `number` | let/var | `-l` | âœ— |
| `d` | `number` | let/var | `1+l` | âœ— |
| `u` | `number[]` | let/var | `[c,c,d,c,d,d,c,c,d,d,c,d]` | âœ— |
| `f` | `6` | let/var | `6` | âœ— |
| `p` | `6` | let/var | `6` | âœ— |
| `m` | `3` | let/var | `3` | âœ— |
| `h` | `2` | let/var | `2` | âœ— |
| `_` | `1` | let/var | `1` | âœ— |
| `g` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(m*p*f)` | âœ— |
| `v` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(h*p*f)` | âœ— |
| `E` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(_*p*f)` | âœ— |
| `t` | `number` | let/var | `e%3*2/3-1` | âœ— |
| `n` | `0 \| -1` | let/var | `e>2?0:-1` | âœ— |
| `r` | `number[]` | let/var | `[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0]` | âœ— |
| `i` | `number[]` | let/var | `[e,e,e,e,e,e]` | âœ— |
| `S` | `any` | let/var | `new N` | âœ— |
| `r` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(Gn)` | âœ— |
| `a` | `Qi` | let/var | `new i(0,1,0)` | âœ— |
| `o` | `Xn` | let/var | `new l({name:"SphericalGaussianBlur",defines:{n:Gn,CUBEUV_TEXEL_WIDTH:1/t,CUBE...` | âœ— |
| `t` | `jn` | let/var | `new o(this._lodPlanes[0],e)` | âœ— |
| `a` | `Qn` | let/var | `new U(90,1,t,n)` | âœ— |
| `l` | `number[]` | let/var | `[1,-1,1,1,1,1]` | âœ— |
| `d` | `number[]` | let/var | `[1,1,1,-1,-1,-1]` | âœ— |
| `u` | `any` | let/var | `this._renderer` | âœ— |
| `f` | `any` | let/var | `u.autoClear` | âœ— |
| `p` | `any` | let/var | `u.toneMapping` | âœ— |
| `m` | `en` | let/var | `new w({name:"PMREM.Background",side:c,depthWrite:!1,depthTest:!1})` | âœ— |
| `h` | `jn` | let/var | `new o(new s,m)` | âœ— |
| `_` | `boolean` | let/var | `!1` | âœ— |
| `g` | `any` | let/var | `e.background` | âœ— |
| `n` | `number` | let/var | `t%3` | âœ— |
| `o` | `number` | let/var | `this._cubeSize` | âœ— |
| `n` | `any` | let/var | `this._renderer` | âœ— |
| `r` | `boolean` | let/var | `e.mapping===C\|\|e.mapping===L` | âœ— |
| `i` | `Xn` | let/var | `r?this._cubemapMaterial:this._equirectMaterial` | âœ— |
| `a` | `jn` | let/var | `new o(this._lodPlanes[0],i)` | âœ— |
| `s` | `number` | let/var | `this._cubeSize` | âœ— |
| `t` | `any` | let/var | `this._renderer` | âœ— |
| `n` | `any` | let/var | `t.autoClear` | âœ— |
| `r` | `number` | let/var | `this._lodPlanes.length` | âœ— |
| `i` | `Qi` | let/var | `jn[(r-t-1)%jn.length]` | âœ— |
| `a` | `zs` | let/var | `this._pingPongRenderTarget` | âœ— |
| `l` | `any` | let/var | `this._renderer` | âœ— |
| `c` | `Xn` | let/var | `this._blurMaterial` | âœ— |
| `d` | `jn` | let/var | `new o(this._lodPlanes[r],c)` | âœ— |
| `u` | `{}` | let/var | `c.uniforms` | âœ— |
| `f` | `number` | let/var | `this._sizeLods[n]-1` | âœ— |
| `p` | `number` | let/var | `isFinite(i)?Math.PI/(2*f):2*Math.PI/39` | âœ— |
| `m` | `number` | let/var | `i/p` | âœ— |
| `h` | `number` | let/var | `isFinite(i)?1+Math.floor(3*m):Gn` | âœ— |
| `_` | `any[]` | let/var | `[]` | âœ— |
| `g` | `number` | let/var | `0` | âœ— |
| `t` | `number` | let/var | `e/m` | âœ— |
| `E` | `any` | let/var | `this._sizeLods[r]` | âœ— |
| `r` | `zs` | let/var | `new I(e,t,n)` | âœ— |
| `t` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `n` | `any` | let/var | `null` | âœ— |
| `n` | `any` | let/var | `e.target` | âœ— |
| `a` | `any` | let/var | `i.mapping` | âœ— |
| `o` | `boolean` | let/var | `a===R\|\|a===A` | âœ— |
| `s` | `boolean` | let/var | `a===C\|\|a===L` | âœ— |
| `l` | `any` | let/var | `void 0!==a?a.texture.pmremVersion:0` | âœ— |
| `l` | `any` | let/var | `i.image` | âœ— |
| `t` | `number` | let/var | `0` | âœ— |
| `n` | `6` | let/var | `6` | âœ— |
| `t` | `{}` | let/var | `{}` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `i` | `{}` | let/var | `{}` | âœ— |
| `a` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `s` | `any` | let/var | `e.target` | âœ— |
| `n` | `any[]` | let/var | `[]` | âœ— |
| `r` | `any` | let/var | `e.index` | âœ— |
| `i` | `any` | let/var | `e.attributes.position` | âœ— |
| `o` | `number` | let/var | `0` | âœ— |
| `e` | `any` | let/var | `r.array` | âœ— |
| `r` | `any` | let/var | `e[t+0]` | âœ— |
| `i` | `any` | let/var | `e[t+1]` | âœ— |
| `a` | `any` | let/var | `e[t+2]` | âœ— |
| `e` | `any` | let/var | `i.array` | âœ— |
| `e` | `number` | let/var | `t+0` | âœ— |
| `r` | `number` | let/var | `t+1` | âœ— |
| `i` | `number` | let/var | `t+2` | âœ— |
| `s` | `xn` | let/var | `new(z(n)?G:V)(n,1)` | âœ— |
| `r` | `any` | let/var | `n.attributes` | âœ— |
| `n` | `any` | let/var | `e.index` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `i` | `any` | let/var | `*not shown*` | âœ— |
| `a` | `any` | let/var | `*not shown*` | âœ— |
| `s` | `number` | let/var | `0` | âœ— |
| `t` | `number` | let/var | `0` | âœ— |
| `t` | `{ frame: number; calls: number; trian...` | let/var | `{frame:0,calls:0,triangles:0,points:0,lines:0}` | âœ— |
| `i` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `a` | `As` | let/var | `new k` | âœ— |
| `c` | `any` | let/var | `o.morphTargetInfluences` | âœ— |
| `d` | `any` | let/var | `s.morphAttributes.position\|\|s.morphAttributes.normal\|\|s.morphAttributes.c...` | âœ— |
| `u` | `any` | let/var | `void 0!==d?d.length:0` | âœ— |
| `p` | `boolean` | let/var | `void 0!==s.morphAttributes.position` | âœ— |
| `m` | `boolean` | let/var | `void 0!==s.morphAttributes.normal` | âœ— |
| `h` | `boolean` | let/var | `void 0!==s.morphAttributes.color` | âœ— |
| `_` | `any` | let/var | `s.morphAttributes.position\|\|[]` | âœ— |
| `g` | `any` | let/var | `s.morphAttributes.normal\|\|[]` | âœ— |
| `v` | `any` | let/var | `s.morphAttributes.color\|\|[]` | âœ— |
| `E` | `number` | let/var | `0` | âœ— |
| `S` | `number` | let/var | `s.attributes.position.count*E` | âœ— |
| `M` | `number` | let/var | `1` | âœ— |
| `x` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(S*M*4*u)` | âœ— |
| `R` | `Cs` | let/var | `new W(x,S,M,u)` | âœ— |
| `A` | `number` | let/var | `4*E` | âœ— |
| `L` | `any` | let/var | `_[C]` | âœ— |
| `P` | `any` | let/var | `g[C]` | âœ— |
| `U` | `any` | let/var | `v[C]` | âœ— |
| `D` | `number` | let/var | `S*M*4*C` | âœ— |
| `y` | `number` | let/var | `w*A` | âœ— |
| `I` | `number` | let/var | `0` | âœ— |
| `N` | `number` | let/var | `s.morphTargetsRelative?1:1-I` | âœ— |
| `i` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `t` | `any` | let/var | `e.target` | âœ— |
| `s` | `any` | let/var | `r.render.frame` | âœ— |
| `l` | `any` | let/var | `o.geometry` | âœ— |
| `e` | `any` | let/var | `o.skeleton` | âœ— |
| `dr` | `_s` | let/var | `new j` | âœ— |
| `ur` | `ah` | let/var | `new q(1,1)` | âœ— |
| `fr` | `Cs` | let/var | `new W` | âœ— |
| `pr` | `Bs` | let/var | `new Y` | âœ— |
| `mr` | `ea` | let/var | `new X` | âœ— |
| `hr` | `any[]` | let/var | `[]` | âœ— |
| `_r` | `any[]` | let/var | `[]` | âœ— |
| `gr` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(16)` | âœ— |
| `vr` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(9)` | âœ— |
| `Er` | `Float32Array<ArrayBuffer>` | let/var | `new Float32Array(4)` | âœ— |
| `r` | `any` | let/var | `e[0]` | âœ— |
| `i` | `number` | let/var | `t*n` | âœ— |
| `a` | `any` | let/var | `hr[i]` | âœ— |
| `n` | `any` | let/var | `_r[t]` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `t.elements` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `t.elements` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `t.elements` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `n` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `a` | `any` | let/var | `*not shown*` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `i` | `any` | let/var | `t.length` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `i` | `any` | let/var | `t.length` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `i` | `any` | let/var | `t.length` | âœ— |
| `r` | `any` | let/var | `this.cache` | âœ— |
| `i` | `any` | let/var | `t.length` | âœ— |
| `r` | `any[]` | let/var | `this.seq` | âœ— |
| `a` | `any` | let/var | `r[i]` | âœ— |
| `ui` | `RegExp` | let/var | `/(\w+)(\])?(\[\|\.)?/g` | âœ— |
| `r` | `any` | let/var | `e.name` | âœ— |
| `i` | `any` | let/var | `r.length` | âœ— |
| `o` | `number` | let/var | `ui.lastIndex` | âœ— |
| `s` | `string` | let/var | `a[1]` | âœ— |
| `l` | `boolean` | let/var | `"]"===a[2]` | âœ— |
| `c` | `string` | let/var | `a[3]` | âœ— |
| `e` | `any` | let/var | `n.map[s]` | âœ— |
| `i` | `any` | let/var | `this.map[t]` | âœ— |
| `r` | `any` | let/var | `t[n]` | âœ— |
| `a` | `any` | let/var | `t[i]` | âœ— |
| `o` | `any` | let/var | `n[a.id]` | âœ— |
| `n` | `any[]` | let/var | `[]` | âœ— |
| `i` | `any` | let/var | `e[r]` | âœ— |
| `_i` | `number` | let/var | `0` | âœ— |
| `gi` | `es` | let/var | `new e` | âœ— |
| `r` | `any[]` | let/var | `[]` | âœ— |
| `i` | `number` | let/var | `e+1` | âœ— |
| `t` | `string` | let/var | ``mat3( ${gi.elements.map(e=>e.toFixed(4))} )`` | âœ— |
| `n` | `any` | let/var | `*not shown*` | âœ— |
| `Ti` | `Qi` | let/var | `new i` | âœ— |
| `n` | `number` | let/var | `t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps` | âœ— |
| `bi` | `RegExp` | let/var | `/^[ \t]*#include +<([\w\d./]+)>/gm` | âœ— |
| `Li` | `Map<any, any>` | let/var | `new Map` | âœ— |
| `n` | `any` | let/var | `Cn[t]` | âœ— |
| `Ui` | `RegExp` | let/var | `/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d...` | âœ— |
| `i` | `string` | let/var | `""` | âœ— |
| `t` | `string` | let/var | ``precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecisio...` | âœ— |
| `o` | `any` | let/var | `n.defines` | âœ— |
| `s` | `any` | let/var | `n.vertexShader` | âœ— |
| `l` | `any` | let/var | `n.fragmentShader` | âœ— |
| `t` | `string` | let/var | `"SHADOWMAP_TYPE_BASIC"` | âœ— |
| `t` | `string` | let/var | `"ENVMAP_TYPE_CUBE"` | âœ— |
| `t` | `string` | let/var | `"ENVMAP_MODE_REFLECTION"` | âœ— |
| `t` | `string` | let/var | `"ENVMAP_BLENDING_NONE"` | âœ— |
| `t` | `any` | let/var | `e.envMapCubeUVHeight` | âœ— |
| `n` | `number` | let/var | `Math.log2(t)-2` | âœ— |
| `r` | `number` | let/var | `1/t` | âœ— |
| `t` | `any[]` | let/var | `[]` | âœ— |
| `r` | `any` | let/var | `e[n]` | âœ— |
| `g` | `any` | let/var | `*not shown*` | âœ— |
| `v` | `any` | let/var | `*not shown*` | âœ— |
| `E` | `string` | let/var | `n.glslVersion?"#version "+n.glslVersion+"\n":""` | âœ— |
| `S` | `string` | let/var | `E+g+s` | âœ— |
| `T` | `string` | let/var | `E+v+l` | âœ— |
| `n` | `any` | let/var | `i.getProgramInfoLog(_)\|\|""` | âœ— |
| `r` | `any` | let/var | `i.getShaderInfoLog(M)\|\|""` | âœ— |
| `a` | `any` | let/var | `i.getShaderInfoLog(x)\|\|""` | âœ— |
| `c` | `boolean` | let/var | `!0` | âœ— |
| `d` | `boolean` | let/var | `!0` | âœ— |
| `n` | `{}` | let/var | `{}` | âœ— |
| `a` | `any` | let/var | `r.name` | âœ— |
| `o` | `number` | let/var | `1` | âœ— |
| `A` | `any` | let/var | `*not shown*` | âœ— |
| `b` | `any` | let/var | `*not shown*` | âœ— |
| `P` | `boolean` | let/var | `!1===n.rendererExtensionParallelShaderCompile` | âœ— |
| `Ni` | `number` | let/var | `0` | âœ— |
| `t` | `any` | let/var | `e.vertexShader` | âœ— |
| `n` | `any` | let/var | `e.fragmentShader` | âœ— |
| `t` | `Map<any, any>` | let/var | `this.materialCache` | âœ— |
| `t` | `Map<any, any>` | let/var | `this.shaderCache` | âœ— |
| `l` | `gr` | let/var | `new _e` | âœ— |
| `d` | `Oi` | let/var | `new Oi` | âœ— |
| `u` | `Set<any>` | let/var | `new Set` | âœ— |
| `f` | `any[]` | let/var | `[]` | âœ— |
| `h` | `any` | let/var | `i.logarithmicDepthBuffer` | âœ— |
| `_` | `any` | let/var | `i.vertexTextures` | âœ— |
| `g` | `any` | let/var | `i.precision` | âœ— |
| `v` | `{ MeshDepthMaterial: string; MeshDist...` | let/var | `{MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMate...` | âœ— |
| `M` | `any` | let/var | `S.fog` | âœ— |
| `x` | `any` | let/var | `T.geometry` | âœ— |
| `R` | `any` | let/var | `o.isMeshStandardMaterial?S.environment:null` | âœ— |
| `b` | `any` | let/var | `A&&A.mapping===a?A.image.height:null` | âœ— |
| `C` | `any` | let/var | `v[o.type]` | âœ— |
| `L` | `any` | let/var | `x.morphAttributes.position\|\|x.morphAttributes.normal\|\|x.morphAttributes.c...` | âœ— |
| `P` | `any` | let/var | `void 0!==L?L.length:0` | âœ— |
| `U` | `any` | let/var | `*not shown*` | âœ— |
| `w` | `any` | let/var | `*not shown*` | âœ— |
| `y` | `any` | let/var | `*not shown*` | âœ— |
| `I` | `any` | let/var | `*not shown*` | âœ— |
| `N` | `number` | let/var | `0` | âœ— |
| `e` | `any` | let/var | `Pn[C]` | âœ— |
| `H` | `boolean` | let/var | `!0===T.isInstancedMesh` | âœ— |
| `G` | `boolean` | let/var | `!0===T.isBatchedMesh` | âœ— |
| `V` | `boolean` | let/var | `!!o.map` | âœ— |
| `z` | `boolean` | let/var | `!!o.matcap` | âœ— |
| `k` | `boolean` | let/var | `!!A` | âœ— |
| `W` | `boolean` | let/var | `!!o.aoMap` | âœ— |
| `X` | `boolean` | let/var | `!!o.lightMap` | âœ— |
| `Y` | `boolean` | let/var | `!!o.bumpMap` | âœ— |
| `K` | `boolean` | let/var | `!!o.normalMap` | âœ— |
| `q` | `boolean` | let/var | `!!o.displacementMap` | âœ— |
| `j` | `boolean` | let/var | `!!o.emissiveMap` | âœ— |
| `Z` | `boolean` | let/var | `!!o.metalnessMap` | âœ— |
| `$` | `boolean` | let/var | `!!o.roughnessMap` | âœ— |
| `Q` | `boolean` | let/var | `o.anisotropy>0` | âœ— |
| `J` | `boolean` | let/var | `o.clearcoat>0` | âœ— |
| `ee` | `boolean` | let/var | `o.dispersion>0` | âœ— |
| `te` | `boolean` | let/var | `o.iridescence>0` | âœ— |
| `ne` | `boolean` | let/var | `o.sheen>0` | âœ— |
| `re` | `boolean` | let/var | `o.transmission>0` | âœ— |
| `ie` | `boolean` | let/var | `Q&&!!o.anisotropyMap` | âœ— |
| `ae` | `boolean` | let/var | `J&&!!o.clearcoatMap` | âœ— |
| `oe` | `boolean` | let/var | `J&&!!o.clearcoatNormalMap` | âœ— |
| `se` | `boolean` | let/var | `J&&!!o.clearcoatRoughnessMap` | âœ— |
| `le` | `boolean` | let/var | `te&&!!o.iridescenceMap` | âœ— |
| `ce` | `boolean` | let/var | `te&&!!o.iridescenceThicknessMap` | âœ— |
| `de` | `boolean` | let/var | `ne&&!!o.sheenColorMap` | âœ— |
| `ue` | `boolean` | let/var | `ne&&!!o.sheenRoughnessMap` | âœ— |
| `_e` | `boolean` | let/var | `!!o.specularMap` | âœ— |
| `ge` | `boolean` | let/var | `!!o.specularColorMap` | âœ— |
| `ve` | `boolean` | let/var | `!!o.specularIntensityMap` | âœ— |
| `Ee` | `boolean` | let/var | `re&&!!o.transmissionMap` | âœ— |
| `Se` | `boolean` | let/var | `re&&!!o.thicknessMap` | âœ— |
| `Te` | `boolean` | let/var | `!!o.gradientMap` | âœ— |
| `Me` | `boolean` | let/var | `!!o.alphaMap` | âœ— |
| `xe` | `boolean` | let/var | `o.alphaTest>0` | âœ— |
| `Re` | `boolean` | let/var | `!!o.alphaHash` | âœ— |
| `Ae` | `boolean` | let/var | `!!o.extensions` | âœ— |
| `be` | `number` | let/var | `D` | âœ— |
| `Ce` | `{ shaderID: any; shaderType: any; sha...` | let/var | `{shaderID:C,shaderType:o.type,shaderName:o.name,vertexShader:U,fragmentShader...` | âœ— |
| `n` | `any[]` | let/var | `[]` | âœ— |
| `t` | `any` | let/var | `v[e.type]` | âœ— |
| `n` | `any` | let/var | `*not shown*` | âœ— |
| `e` | `any` | let/var | `Pn[t]` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `t` | `any` | let/var | `f[e]` | âœ— |
| `e` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `e` | `any[]` | let/var | `[]` | âœ— |
| `t` | `number` | let/var | `0` | âœ— |
| `n` | `any[]` | let/var | `[]` | âœ— |
| `r` | `any[]` | let/var | `[]` | âœ— |
| `i` | `any[]` | let/var | `[]` | âœ— |
| `l` | `any` | let/var | `e[t]` | âœ— |
| `t` | `any` | let/var | `e[n]` | âœ— |
| `e` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `i` | `any` | let/var | `*not shown*` | âœ— |
| `e` | `{}` | let/var | `{}` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `Xi` | `number` | let/var | `0` | âœ— |
| `n` | `any` | let/var | `new Wi` | âœ— |
| `e` | `{}` | let/var | `{}` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `a` | `{ version: number; hash: { directiona...` | let/var | `{version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLe...` | âœ— |
| `o` | `Qi` | let/var | `new i` | âœ— |
| `s` | `nr` | let/var | `new f` | âœ— |
| `l` | `nr` | let/var | `new f` | âœ— |
| `i` | `number` | let/var | `0` | âœ— |
| `o` | `number` | let/var | `0` | âœ— |
| `s` | `number` | let/var | `0` | âœ— |
| `l` | `number` | let/var | `0` | âœ— |
| `c` | `number` | let/var | `0` | âœ— |
| `d` | `number` | let/var | `0` | âœ— |
| `u` | `number` | let/var | `0` | âœ— |
| `f` | `number` | let/var | `0` | âœ— |
| `p` | `number` | let/var | `0` | âœ— |
| `m` | `number` | let/var | `0` | âœ— |
| `h` | `number` | let/var | `0` | âœ— |
| `_` | `number` | let/var | `0` | âœ— |
| `g` | `number` | let/var | `0` | âœ— |
| `v` | `number` | let/var | `0` | âœ— |
| `E` | `any` | let/var | `t[e]` | âœ— |
| `S` | `any` | let/var | `E.color` | âœ— |
| `T` | `any` | let/var | `E.intensity` | âœ— |
| `M` | `any` | let/var | `E.distance` | âœ— |
| `x` | `any` | let/var | `E.shadow&&E.shadow.map?E.shadow.map.texture:null` | âœ— |
| `e` | `any` | let/var | `E.shadow` | âœ— |
| `t` | `any` | let/var | `E.shadow` | âœ— |
| `e` | `any` | let/var | `E.shadow` | âœ— |
| `E` | `{ directionalLength: number; pointLen...` | let/var | `a.hash` | âœ— |
| `n` | `number` | let/var | `0` | âœ— |
| `r` | `number` | let/var | `0` | âœ— |
| `i` | `number` | let/var | `0` | âœ— |
| `c` | `number` | let/var | `0` | âœ— |
| `d` | `number` | let/var | `0` | âœ— |
| `u` | `any` | let/var | `t.matrixWorldInverse` | âœ— |
| `f` | `any` | let/var | `e[t]` | âœ— |
| `e` | `any` | let/var | `a.directional[n]` | âœ— |
| `e` | `any` | let/var | `a.spot[i]` | âœ— |
| `e` | `any` | let/var | `a.rectArea[c]` | âœ— |
| `e` | `any` | let/var | `a.point[r]` | âœ— |
| `e` | `any` | let/var | `a.hemi[d]` | âœ— |
| `t` | `any` | let/var | `new Ki(e)` | âœ— |
| `n` | `any[]` | let/var | `[]` | âœ— |
| `r` | `any[]` | let/var | `[]` | âœ— |
| `i` | `{ lightsArray: any[]; shadowsArray: a...` | let/var | `{lightsArray:n,shadowsArray:r,camera:null,lights:t,transmissionRenderTarget:{}}` | âœ— |
| `t` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `a` | `any` | let/var | `*not shown*` | âœ— |
| `i` | `ho` | let/var | `new ge` | âœ— |
| `a` | `Gi` | let/var | `new t` | âœ— |
| `s` | `Gi` | let/var | `new t` | âœ— |
| `d` | `As` | let/var | `new k` | âœ— |
| `u` | `Wl` | let/var | `new ve({depthPacking:Ee})` | âœ— |
| `f` | `Dl` | let/var | `new Se` | âœ— |
| `p` | `{}` | let/var | `{}` | âœ— |
| `m` | `any` | let/var | `r.maxTextureSize` | âœ— |
| `h` | `{ 0: number; 1: number; 2: number; }` | let/var | `{[_]:c,[c]:_,[fe]:fe}` | âœ— |
| `g` | `Xn` | let/var | `new l({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:...` | âœ— |
| `E` | `Cn` | let/var | `new N` | âœ— |
| `S` | `jn` | let/var | `new o(E,g)` | âœ— |
| `T` | `this` | let/var | `this` | âœ— |
| `M` | `number` | let/var | `this.type` | âœ— |
| `a` | `any` | let/var | `null` | âœ— |
| `o` | `any` | let/var | `!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial` | âœ— |
| `e` | `string` | let/var | `a.uuid` | âœ— |
| `t` | `any` | let/var | `n.uuid` | âœ— |
| `r` | `any` | let/var | `p[e]` | âœ— |
| `i` | `any` | let/var | `r[t]` | âœ— |
| `l` | `any` | let/var | `t.material` | âœ— |
| `n` | `any` | let/var | `i.groups` | âœ— |
| `d` | `any` | let/var | `n[c]` | âœ— |
| `u` | `any` | let/var | `l[d.materialIndex]` | âœ— |
| `l` | `any` | let/var | `t.children` | âœ— |
| `n` | `any` | let/var | `p[t]` | âœ— |
| `r` | `any` | let/var | `e.target.uuid` | âœ— |
| `u` | `any` | let/var | `e.state` | âœ— |
| `f` | `boolean` | let/var | `M!==J&&this.type===J` | âœ— |
| `p` | `boolean` | let/var | `M===J&&this.type!==J` | âœ— |
| `l` | `any` | let/var | `t[o]` | âœ— |
| `c` | `any` | let/var | `l.shadow` | âœ— |
| `e` | `{ minFilter: number; magFilter: numbe...` | let/var | `this.type!==J?{minFilter:Te,magFilter:Te}:{}` | âœ— |
| `$i` | `{ 0: number; 2: number; 4: number; 3:...` | let/var | `{[Ke]:Ye,[Xe]:ze,[We]:Ve,[Me]:ke,[Ye]:Ke,[ze]:Xe,[Ve]:We,[ke]:Me}` | âœ— |
| `t` | `boolean` | let/var | `!1` | âœ— |
| `n` | `As` | let/var | `new k` | âœ— |
| `r` | `any` | let/var | `null` | âœ— |
| `i` | `As` | let/var | `new k(0,0,0,0)` | âœ— |
| `r` | `any` | let/var | `new function(){let t=!1;const n=new k;let r=null;const i=new k(0,0,0,0);retur...` | âœ— |
| `n` | `boolean` | let/var | `!1` | âœ— |
| `r` | `boolean` | let/var | `!1` | âœ— |
| `i` | `any` | let/var | `null` | âœ— |
| `a` | `any` | let/var | `null` | âœ— |
| `o` | `any` | let/var | `null` | âœ— |
| `i` | `any` | let/var | `o` | âœ— |
| `i` | `any` | let/var | `new function(){let n=!1,r=!1,i=null,a=null,o=null;return{setReversed:function...` | âœ— |
| `t` | `boolean` | let/var | `!1` | âœ— |
| `n` | `any` | let/var | `null` | âœ— |
| `r` | `any` | let/var | `null` | âœ— |
| `i` | `any` | let/var | `null` | âœ— |
| `a` | `any` | let/var | `null` | âœ— |
| `o` | `any` | let/var | `null` | âœ— |
| `s` | `any` | let/var | `null` | âœ— |
| `l` | `any` | let/var | `null` | âœ— |
| `c` | `any` | let/var | `null` | âœ— |
| `a` | `any` | let/var | `new function(){let t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=nu...` | âœ— |
| `o` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `s` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `l` | `{}` | let/var | `{}` | âœ— |
| `d` | `{}` | let/var | `{}` | âœ— |
| `u` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `f` | `any[]` | let/var | `[]` | âœ— |
| `p` | `any` | let/var | `null` | âœ— |
| `m` | `boolean` | let/var | `!1` | âœ— |
| `h` | `any` | let/var | `null` | âœ— |
| `_` | `any` | let/var | `null` | âœ— |
| `g` | `any` | let/var | `null` | âœ— |
| `v` | `any` | let/var | `null` | âœ— |
| `E` | `any` | let/var | `null` | âœ— |
| `S` | `any` | let/var | `null` | âœ— |
| `T` | `any` | let/var | `null` | âœ— |
| `M` | `$r` | let/var | `new n(0,0,0)` | âœ— |
| `x` | `number` | let/var | `0` | âœ— |
| `R` | `boolean` | let/var | `!1` | âœ— |
| `A` | `any` | let/var | `null` | âœ— |
| `b` | `any` | let/var | `null` | âœ— |
| `C` | `any` | let/var | `null` | âœ— |
| `L` | `any` | let/var | `null` | âœ— |
| `P` | `any` | let/var | `null` | âœ— |
| `D` | `boolean` | let/var | `!1` | âœ— |
| `w` | `number` | let/var | `0` | âœ— |
| `N` | `any` | let/var | `null` | âœ— |
| `O` | `{}` | let/var | `{}` | âœ— |
| `a` | `Uint8Array<ArrayBuffer>` | let/var | `new Uint8Array(4)` | âœ— |
| `z` | `{}` | let/var | `{}` | âœ— |
| `Y` | `{ 100: any; 101: any; 102: any; }` | let/var | `{[Ae]:e.FUNC_ADD,[Re]:e.FUNC_SUBTRACT,[xe]:e.FUNC_REVERSE_SUBTRACT}` | âœ— |
| `K` | `{ 200: any; 201: any; 202: any; 204: ...` | let/var | `{[Ge]:e.ZERO,[He]:e.ONE,[Be]:e.SRC_COLOR,[Fe]:e.SRC_ALPHA,[Oe]:e.SRC_ALPHA_SA...` | âœ— |
| `r` | `any[]` | let/var | `f` | âœ— |
| `i` | `boolean` | let/var | `!1` | âœ— |
| `a` | `any` | let/var | `t.textures` | âœ— |
| `o` | `boolean` | let/var | `t.side===c` | âœ— |
| `s` | `any` | let/var | `t.stencilWrite` | âœ— |
| `i` | `any` | let/var | `O[r]` | âœ— |
| `t` | `any` | let/var | `O[N]` | âœ— |
| `l` | `any` | let/var | `n.has("WEBGL_multisampled_render_to_texture")?n.get("WEBGL_multisampled_rende...` | âœ— |
| `c` | `boolean` | let/var | `"undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent)` | âœ— |
| `d` | `Gi` | let/var | `new t` | âœ— |
| `u` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `f` | `any` | let/var | `*not shown*` | âœ— |
| `h` | `WeakMap<WeakKey, any>` | let/var | `new WeakMap` | âœ— |
| `_` | `boolean` | let/var | `!1` | âœ— |
| `r` | `number` | let/var | `1` | âœ— |
| `o` | `any` | let/var | `t?g(n,a):f` | âœ— |
| `s` | `any` | let/var | `r` | âœ— |
| `t` | `any` | let/var | `o?se:p.getTransfer(a)` | âœ— |
| `r` | `any` | let/var | `*not shown*` | âœ— |
| `t` | `any` | let/var | `e.target` | âœ— |
| `n` | `any` | let/var | `e.source` | âœ— |
| `i` | `any` | let/var | `r[t.__cacheKey]` | âœ— |
| `n` | `any` | let/var | `t.target` | âœ— |
| `r` | `any` | let/var | `t.textures` | âœ— |
| `r` | `any` | let/var | `t.source` | âœ— |
| `D` | `number` | let/var | `0` | âœ— |
| `t` | `any` | let/var | `s.render.frame` | âœ— |
| `e` | `any` | let/var | `t.image` | âœ— |
| `y` | `{ 1000: any; 1001: any; 1002: any; }` | let/var | `{[at]:e.REPEAT,[it]:e.CLAMP_TO_EDGE,[rt]:e.MIRRORED_REPEAT}` | âœ— |
| `I` | `{ 1003: any; 1004: any; 1005: any; 10...` | let/var | `{[Te]:e.NEAREST,[ct]:e.NEAREST_MIPMAP_NEAREST,[lt]:e.NEAREST_MIPMAP_LINEAR,[B...` | âœ— |
| `N` | `{ 512: any; 519: any; 513: any; 515: ...` | let/var | `{[_t]:e.NEVER,[ht]:e.ALWAYS,[mt]:e.LESS,[K]:e.LEQUAL,[pt]:e.EQUAL,[ft]:e.GEQU...` | âœ— |
| `r` | `boolean` | let/var | `!1` | âœ— |
| `i` | `any` | let/var | `n.source` | âœ— |
| `t` | `any[]` | let/var | `[]` | âœ— |
| `i` | `any` | let/var | `a[t.__cacheKey]` | âœ— |
| `l` | `any` | let/var | `e.TEXTURE_2D` | âœ— |
| `d` | `any` | let/var | `n.source` | âœ— |
| `i` | `any` | let/var | `n.colorSpace===gt?null:p.getPrimaries(n.colorSpace)` | âœ— |
| `f` | `any` | let/var | `n.colorSpace===gt\|\|t===i?e.NONE:e.BROWSER_DEFAULT_WEBGL` | âœ— |
| `g` | `any` | let/var | `*not shown*` | âœ— |
| `T` | `any` | let/var | `n.mipmaps` | âœ— |
| `R` | `boolean` | let/var | `!0!==n.isVideoTexture` | âœ— |
| `L` | `boolean` | let/var | `void 0===u.__version\|\|!0===c` | âœ— |
| `P` | `any` | let/var | `d.dataReady` | âœ— |
| `o` | `any` | let/var | `t.updateRanges` | âœ— |
| `s` | `number` | let/var | `0` | âœ— |
| `t` | `any` | let/var | `o[s]` | âœ— |
| `r` | `any` | let/var | `o[e]` | âœ— |
| `i` | `any` | let/var | `t.start+t.count` | âœ— |
| `s` | `any` | let/var | `o[t]` | âœ— |
| `d` | `number` | let/var | `l%n.width` | âœ— |
| `f` | `number` | let/var | `c` | âœ— |
| `p` | `1` | let/var | `1` | âœ— |
| `t` | `any` | let/var | `m.width` | âœ— |
| `n` | `any` | let/var | `m.height` | âœ— |
| `i` | `any` | let/var | `n.depthTexture` | âœ— |
| `a` | `any` | let/var | `i&&i.isDepthTexture?i.type:null` | âœ— |
| `s` | `any` | let/var | `n.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT` | âœ— |
| `t` | `any` | let/var | `n.textures` | âœ— |
| `a` | `any` | let/var | `t[i]` | âœ— |
| `o` | `any` | let/var | `a.__webglTexture` | âœ— |
| `a` | `boolean` | let/var | `!0===t.isWebGLCubeRenderTarget` | âœ— |
| `e` | `any` | let/var | `t.depthTexture` | âœ— |
| `e` | `any` | let/var | `t.texture.mipmaps` | âœ— |
| `r` | `any` | let/var | `t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT` | âœ— |
| `a` | `any` | let/var | `n.__webglDepthbuffer[i]` | âœ— |
| `i` | `any` | let/var | `t.texture.mipmaps` | âœ— |
| `r` | `any` | let/var | `t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT` | âœ— |
| `i` | `any` | let/var | `n.__webglDepthbuffer` | âœ— |
| `Y` | `any[]` | let/var | `[]` | âœ— |
| `q` | `any[]` | let/var | `[]` | âœ— |
| `n` | `any` | let/var | `e.colorSpace` | âœ— |
| `r` | `any` | let/var | `e.format` | âœ— |
| `i` | `any` | let/var | `e.type` | âœ— |
| `e` | `number` | let/var | `D` | âœ— |
| `c` | `any` | let/var | `n.source` | âœ— |
| `i` | `any` | let/var | `n.colorSpace===gt?null:p.getPrimaries(n.colorSpace)` | âœ— |
| `u` | `any` | let/var | `n.colorSpace===gt\|\|t===i?e.NONE:e.BROWSER_DEFAULT_WEBGL` | âœ— |
| `f` | `any` | let/var | `n.isCompressedTexture\|\|n.image[0].isCompressedTexture` | âœ— |
| `m` | `any` | let/var | `n.image[0]&&n.image[0].isDataTexture` | âœ— |
| `h` | `any[]` | let/var | `[]` | âœ— |
| `_` | `any` | let/var | `h[0]` | âœ— |
| `R` | `boolean` | let/var | `!0!==n.isVideoTexture` | âœ— |
| `b` | `boolean` | let/var | `void 0===d.__version\|\|!0===l` | âœ— |
| `L` | `any` | let/var | `c.dataReady` | âœ— |
| `P` | `any` | let/var | `*not shown*` | âœ— |
| `a` | `any` | let/var | `P[i]` | âœ— |
| `i` | `any` | let/var | `P[n].image[t].image` | âœ— |
| `i` | `any` | let/var | `P[n]` | âœ— |
| `n` | `any` | let/var | `t.texture` | âœ— |
| `c` | `any` | let/var | `t.textures` | âœ— |
| `d` | `boolean` | let/var | `!0===t.isWebGLCubeRenderTarget` | âœ— |
| `u` | `boolean` | let/var | `c.length>1` | âœ— |
| `r` | `any` | let/var | `c[n]` | âœ— |
| `o` | `any` | let/var | `c[n]` | âœ— |
| `l` | `any` | let/var | `e.TEXTURE_2D` | âœ— |
| `i` | `any` | let/var | `e.TEXTURE_2D` | âœ— |
| `t` | `any` | let/var | `e.textures` | âœ— |
| `a` | `any` | let/var | `t[n]` | âœ— |
| `n` | `any` | let/var | `i.get(a).__webglTexture` | âœ— |
| `n` | `any` | let/var | `t.textures` | âœ— |
| `a` | `any` | let/var | `t.width` | âœ— |
| `o` | `any` | let/var | `t.height` | âœ— |
| `s` | `any` | let/var | `e.COLOR_BUFFER_BIT` | âœ— |
| `l` | `any` | let/var | `t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT` | âœ— |
| `u` | `boolean` | let/var | `n.length>1` | âœ— |
| `f` | `any` | let/var | `t.texture.mipmaps` | âœ— |
| `t` | `any` | let/var | `i.get(n[r]).__webglTexture` | âœ— |
| `a` | `any` | let/var | `i.get(n[t]).__webglTexture` | âœ— |
| `n` | `any` | let/var | `t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT` | âœ— |
| `i` | `any` | let/var | `*not shown*` | âœ— |
| `n` | `ta` | let/var | `new ta(e.texture)` | âœ— |
| `t` | `any` | let/var | `e.cameras[0].viewport` | âœ— |
| `n` | `Xn` | let/var | `new l({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 )...` | âœ— |
| `r` | `this` | let/var | `this` | âœ— |
| `a` | `any` | let/var | `null` | âœ— |
| `o` | `number` | let/var | `1` | âœ— |
| `s` | `any` | let/var | `null` | âœ— |
| `l` | `string` | let/var | `"local-floor"` | âœ— |
| `c` | `number` | let/var | `1` | âœ— |
| `d` | `any` | let/var | `null` | âœ— |
| `u` | `any` | let/var | `null` | âœ— |
| `f` | `any` | let/var | `null` | âœ— |
| `p` | `any` | let/var | `null` | âœ— |
| `m` | `any` | let/var | `null` | âœ— |
| `h` | `any` | let/var | `null` | âœ— |
| `_` | `na` | let/var | `new na` | âœ— |
| `g` | `{}` | let/var | `{}` | âœ— |
| `E` | `any` | let/var | `null` | âœ— |
| `T` | `any` | let/var | `null` | âœ— |
| `x` | `any[]` | let/var | `[]` | âœ— |
| `R` | `any[]` | let/var | `[]` | âœ— |
| `A` | `Gi` | let/var | `new t` | âœ— |
| `b` | `any` | let/var | `null` | âœ— |
| `C` | `Qn` | let/var | `new U` | âœ— |
| `L` | `Qn` | let/var | `new U` | âœ— |
| `P` | `Qn[]` | let/var | `[C,L]` | âœ— |
| `D` | `hu` | let/var | `new gn` | âœ— |
| `w` | `any` | let/var | `null` | âœ— |
| `y` | `any` | let/var | `null` | âœ— |
| `n` | `any` | let/var | `x[t]` | âœ— |
| `t` | `any` | let/var | `R[e]` | âœ— |
| `n` | `any` | let/var | `e.removed[t]` | âœ— |
| `n` | `any` | let/var | `e.added[t]` | âœ— |
| `i` | `any` | let/var | `x[r]` | âœ— |
| `t` | `any` | let/var | `x[e]` | âœ— |
| `t` | `any` | let/var | `x[e]` | âœ— |
| `t` | `any` | let/var | `x[e]` | âœ— |
| `t` | `any` | let/var | `null` | âœ— |
| `r` | `any` | let/var | `null` | âœ— |
| `i` | `any` | let/var | `null` | âœ— |
| `s` | `{ colorFormat: any; depthFormat: any;...` | let/var | `{colorFormat:n.RGBA8,depthFormat:i,scaleFactor:o}` | âœ— |
| `t` | `{ antialias: any; alpha: boolean; dep...` | let/var | `{antialias:v.antialias,alpha:!0,depth:v.depth,stencil:v.stencil,framebufferSc...` | âœ— |
| `B` | `Qi` | let/var | `new i` | âœ— |
| `H` | `Qi` | let/var | `new i` | âœ— |
| `t` | `any` | let/var | `e.near` | âœ— |
| `n` | `any` | let/var | `e.far` | âœ— |
| `r` | `any` | let/var | `e.parent` | âœ— |
| `i` | `any[]` | let/var | `D.cameras` | âœ— |
| `i` | `number[]` | let/var | `t.projectionMatrix.elements` | âœ— |
| `a` | `number[]` | let/var | `n.projectionMatrix.elements` | âœ— |
| `o` | `number` | let/var | `i[14]/(i[10]-1)` | âœ— |
| `s` | `number` | let/var | `i[14]/(i[10]+1)` | âœ— |
| `l` | `number` | let/var | `(i[9]+1)/i[5]` | âœ— |
| `c` | `number` | let/var | `(i[9]-1)/i[5]` | âœ— |
| `d` | `number` | let/var | `(i[8]-1)/i[0]` | âœ— |
| `u` | `number` | let/var | `(a[8]+1)/a[0]` | âœ— |
| `f` | `number` | let/var | `o*d` | âœ— |
| `p` | `number` | let/var | `o*u` | âœ— |
| `m` | `number` | let/var | `r/(-d+u)` | âœ— |
| `h` | `number` | let/var | `m*-d` | âœ— |
| `t` | `number` | let/var | `o+m` | âœ— |
| `n` | `number` | let/var | `s+m` | âœ— |
| `i` | `number` | let/var | `f-h` | âœ— |
| `a` | `number` | let/var | `p+(r-h)` | âœ— |
| `d` | `number` | let/var | `l*s/n*t` | âœ— |
| `u` | `number` | let/var | `c*s/n*t` | âœ— |
| `V` | `any` | let/var | `null` | âœ— |
| `z` | `any` | let/var | `new An` | âœ— |
| `t` | `any` | let/var | `u.views` | âœ— |
| `n` | `boolean` | let/var | `!1` | âœ— |
| `i` | `any` | let/var | `t[r]` | âœ— |
| `a` | `any` | let/var | `null` | âœ— |
| `o` | `Qn` | let/var | `P[r]` | âœ— |
| `r` | `any` | let/var | `a.enabledFeatures` | âœ— |
| `n` | `any` | let/var | `t[e].camera` | âœ— |
| `e` | `any` | let/var | `g[n]` | âœ— |
| `t` | `any` | let/var | `R[e]` | âœ— |
| `r` | `any` | let/var | `x[e]` | âœ— |
| `ia` | `yr` | let/var | `new u` | âœ— |
| `aa` | `nr` | let/var | `new f` | âœ— |
| `a` | `any` | let/var | `i.envMap` | âœ— |
| `o` | `any` | let/var | `i.envMapRotation` | âœ— |
| `r` | `any` | let/var | `t.get(n).light` | âœ— |
| `i` | `{}` | let/var | `{}` | âœ— |
| `a` | `{}` | let/var | `{}` | âœ— |
| `o` | `any[]` | let/var | `[]` | âœ— |
| `i` | `any` | let/var | `e.value` | âœ— |
| `a` | `string` | let/var | `t+"_"+n` | âœ— |
| `e` | `any` | let/var | `r[a]` | âœ— |
| `t` | `{ boundary: number; storage: number; }` | let/var | `{boundary:0,storage:0}` | âœ— |
| `n` | `any` | let/var | `t.target` | âœ— |
| `n` | `any` | let/var | `t.program` | âœ— |
| `f` | `any` | let/var | `i[n.id]` | âœ— |
| `t` | `any` | let/var | `e.uniforms` | âœ— |
| `n` | `number` | let/var | `0` | âœ— |
| `r` | `16` | let/var | `16` | âœ— |
| `i` | `any` | let/var | `Array.isArray(t[e])?t[e]:[t[e]]` | âœ— |
| `t` | `any` | let/var | `i[e]` | âœ— |
| `a` | `any` | let/var | `Array.isArray(t.value)?t.value:[t.value]` | âœ— |
| `o` | `number` | let/var | `n%r` | âœ— |
| `s` | `number` | let/var | `o%i.boundary` | âœ— |
| `l` | `number` | let/var | `o+s` | âœ— |
| `i` | `number` | let/var | `n%r` | âœ— |
| `i` | `any` | let/var | `t.__size` | âœ— |
| `a` | `any` | let/var | `t.usage` | âœ— |
| `p` | `any` | let/var | `u.program` | âœ— |
| `m` | `any` | let/var | `t.render.frame` | âœ— |
| `n` | `any` | let/var | `i[t.id]` | âœ— |
| `r` | `any` | let/var | `t.uniforms` | âœ— |
| `a` | `any` | let/var | `t.__cache` | âœ— |
| `n` | `any` | let/var | `Array.isArray(r[t])?r[t]:[r[t]]` | âœ— |
| `i` | `any` | let/var | `n[r]` | âœ— |
| `t` | `any` | let/var | `i.__offset` | âœ— |
| `n` | `any` | let/var | `Array.isArray(i.value)?i.value:[i.value]` | âœ— |
| `r` | `number` | let/var | `0` | âœ— |
| `o` | `any` | let/var | `n[a]` | âœ— |
| `v` | `any` | let/var | `*not shown*` | âœ— |
| `T` | `Uint32Array<ArrayBuffer>` | let/var | `new Uint32Array(4)` | âœ— |
| `M` | `Int32Array<ArrayBuffer>` | let/var | `new Int32Array(4)` | âœ— |
| `x` | `any` | let/var | `null` | âœ— |
| `R` | `any` | let/var | `null` | âœ— |
| `A` | `any[]` | let/var | `[]` | âœ— |
| `b` | `any[]` | let/var | `[]` | âœ— |
| `C` | `this` | let/var | `this` | âœ— |
| `L` | `boolean` | let/var | `!1` | âœ— |
| `P` | `number` | let/var | `0` | âœ— |
| `U` | `number` | let/var | `0` | âœ— |
| `w` | `any` | let/var | `null` | âœ— |
| `y` | `number` | let/var | `-1` | âœ— |
| `N` | `any` | let/var | `null` | âœ— |
| `O` | `As` | let/var | `new k` | âœ— |
| `B` | `As` | let/var | `new k` | âœ— |
| `G` | `any` | let/var | `null` | âœ— |
| `V` | `$r` | let/var | `new n(0)` | âœ— |
| `z` | `number` | let/var | `0` | âœ— |
| `W` | `any` | let/var | `t.width` | âœ— |
| `X` | `any` | let/var | `t.height` | âœ— |
| `Y` | `number` | let/var | `1` | âœ— |
| `K` | `any` | let/var | `null` | âœ— |
| `q` | `any` | let/var | `null` | âœ— |
| `j` | `As` | let/var | `new k(0,0,W,X)` | âœ— |
| `Z` | `As` | let/var | `new k(0,0,W,X)` | âœ— |
| `$` | `boolean` | let/var | `!1` | âœ— |
| `Q` | `ho` | let/var | `new ge` | âœ— |
| `J` | `boolean` | let/var | `!1` | âœ— |
| `ee` | `boolean` | let/var | `!1` | âœ— |
| `te` | `nr` | let/var | `new f` | âœ— |
| `ne` | `Qi` | let/var | `new i` | âœ— |
| `re` | `As` | let/var | `new k` | âœ— |
| `ie` | `{ background: any; fog: any; environm...` | let/var | `{background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0}` | âœ— |
| `ae` | `boolean` | let/var | `!1` | âœ— |
| `se` | `any` | let/var | `*not shown*` | âœ— |
| `le` | `any` | let/var | `*not shown*` | âœ— |
| `ce` | `any` | let/var | `*not shown*` | âœ— |
| `de` | `any` | let/var | `*not shown*` | âœ— |
| `ue` | `any` | let/var | `*not shown*` | âœ— |
| `pe` | `any` | let/var | `*not shown*` | âœ— |
| `me` | `any` | let/var | `*not shown*` | âœ— |
| `he` | `any` | let/var | `*not shown*` | âœ— |
| `_e` | `any` | let/var | `*not shown*` | âœ— |
| `ve` | `any` | let/var | `*not shown*` | âœ— |
| `Ee` | `any` | let/var | `*not shown*` | âœ— |
| `Se` | `any` | let/var | `*not shown*` | âœ— |
| `Te` | `any` | let/var | `*not shown*` | âœ— |
| `Me` | `any` | let/var | `*not shown*` | âœ— |
| `xe` | `any` | let/var | `*not shown*` | âœ— |
| `Re` | `any` | let/var | `*not shown*` | âœ— |
| `Ae` | `any` | let/var | `*not shown*` | âœ— |
| `be` | `any` | let/var | `*not shown*` | âœ— |
| `Ce` | `any` | let/var | `*not shown*` | âœ— |
| `Le` | `any` | let/var | `*not shown*` | âœ— |
| `Pe` | `any` | let/var | `*not shown*` | âœ— |
| `Ue` | `any` | let/var | `*not shown*` | âœ— |
| `De` | `any` | let/var | `*not shown*` | âœ— |
| `we` | `any` | let/var | `*not shown*` | âœ— |
| `ye` | `any` | let/var | `r` | âœ— |
| `e` | `{ alpha: boolean; depth: any; stencil...` | let/var | `{alpha:!0,depth:a,stencil:o,antialias:l,premultipliedAlpha:d,preserveDrawingB...` | âœ— |
| `t` | `"webgl2"` | let/var | `"webgl2"` | âœ— |
| `Oe` | `ra` | let/var | `new ra(C,ye)` | âœ— |
| `e` | `any` | let/var | `de.autoReset` | âœ— |
| `t` | `any` | let/var | `Ae.enabled` | âœ— |
| `n` | `any` | let/var | `Ae.autoUpdate` | âœ— |
| `r` | `any` | let/var | `Ae.needsUpdate` | âœ— |
| `i` | `any` | let/var | `Ae.type` | âœ— |
| `t` | `any` | let/var | `e.target` | âœ— |
| `t` | `any` | let/var | `ue.get(e).programs` | âœ— |
| `r` | `number` | let/var | `0` | âœ— |
| `e` | `boolean` | let/var | `!1` | âœ— |
| `t` | `any` | let/var | `w.texture.format` | âœ— |
| `e` | `any` | let/var | `w.texture.type` | âœ— |
| `t` | `boolean` | let/var | `e===S\|\|e===Tt\|\|e===xt\|\|e===Mt\|\|e===At\|\|e===bt` | âœ— |
| `i` | `any` | let/var | `n.r` | âœ— |
| `a` | `any` | let/var | `n.g` | âœ— |
| `o` | `any` | let/var | `n.b` | âœ— |
| `o` | `boolean` | let/var | `i.isMesh&&i.matrixWorld.determinant()<0` | âœ— |
| `a` | `any` | let/var | `t.fog` | âœ— |
| `o` | `any` | let/var | `r.isMeshStandardMaterial?t.environment:null` | âœ— |
| `s` | `any` | let/var | `null===w?C.outputColorSpace:!0===w.isXRRenderTarget?w.texture.colorSpace:F` | âœ— |
| `c` | `boolean` | let/var | `!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize` | âœ— |
| `d` | `boolean` | let/var | `!!n.attributes.tangent&&(!!r.normalMap\|\|r.anisotropy>0)` | âœ— |
| `u` | `boolean` | let/var | `!!n.morphAttributes.position` | âœ— |
| `f` | `boolean` | let/var | `!!n.morphAttributes.normal` | âœ— |
| `p` | `boolean` | let/var | `!!n.morphAttributes.color` | âœ— |
| `m` | `number` | let/var | `D` | âœ— |
| `h` | `any` | let/var | `n.morphAttributes.position\|\|n.morphAttributes.normal\|\|n.morphAttributes.c...` | âœ— |
| `_` | `any` | let/var | `void 0!==h?h.length:0` | âœ— |
| `v` | `any` | let/var | `R.state.lights` | âœ— |
| `t` | `boolean` | let/var | `e===N&&r.id===y` | âœ— |
| `E` | `boolean` | let/var | `!1` | âœ— |
| `S` | `any` | let/var | `g.currentProgram` | âœ— |
| `T` | `boolean` | let/var | `!1` | âœ— |
| `M` | `boolean` | let/var | `!1` | âœ— |
| `x` | `boolean` | let/var | `!1` | âœ— |
| `b` | `any` | let/var | `g.uniforms` | âœ— |
| `t` | `any` | let/var | `A.map.cameraPosition` | âœ— |
| `e` | `any` | let/var | `i.skeleton` | âœ— |
| `L` | `any` | let/var | `n.morphAttributes` | âœ— |
| `P` | `any` | let/var | `*not shown*` | âœ— |
| `U` | `any` | let/var | `*not shown*` | âœ— |
| `e` | `any` | let/var | `r.uniformsGroups` | âœ— |
| `n` | `any` | let/var | `e[t]` | âœ— |
| `l` | `any` | let/var | `n.index` | âœ— |
| `c` | `number` | let/var | `1` | âœ— |
| `d` | `any` | let/var | `n.drawRange` | âœ— |
| `u` | `any` | let/var | `n.attributes.position` | âœ— |
| `f` | `number` | let/var | `d.start*c` | âœ— |
| `p` | `number` | let/var | `(d.start+d.count)*c` | âœ— |
| `m` | `number` | let/var | `p-f` | âœ— |
| `h` | `any` | let/var | `*not shown*` | âœ— |
| `_` | `any` | let/var | `Le` | âœ— |
| `e` | `any` | let/var | `r.linewidth` | âœ— |
| `e` | `any` | let/var | `i._multiDrawStarts` | âœ— |
| `t` | `any` | let/var | `i._multiDrawCounts` | âœ— |
| `n` | `any` | let/var | `i._multiDrawCount` | âœ— |
| `a` | `any` | let/var | `l?_e.get(l).bytesPerElement:1` | âœ— |
| `e` | `any` | let/var | `void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0` | âœ— |
| `r` | `Set<any>` | let/var | `new Set` | âœ— |
| `t` | `any` | let/var | `e.material` | âœ— |
| `a` | `any` | let/var | `t[i]` | âœ— |
| `ze` | `any` | let/var | `null` | âœ— |
| `Xe` | `any` | let/var | `new An` | âœ— |
| `i` | `any` | let/var | `e.material` | âœ— |
| `i` | `any` | let/var | `e.material` | âœ— |
| `r` | `any` | let/var | `t.groups` | âœ— |
| `o` | `any` | let/var | `r[a]` | âœ— |
| `s` | `any` | let/var | `i[o.materialIndex]` | âœ— |
| `i` | `any` | let/var | `e.children` | âœ— |
| `i` | `any` | let/var | `e.opaque` | âœ— |
| `a` | `any` | let/var | `e.transmissive` | âœ— |
| `o` | `any` | let/var | `e.transparent` | âœ— |
| `i` | `any` | let/var | `R.state.transmissionRenderTarget[r.id]` | âœ— |
| `a` | `any` | let/var | `r.viewport\|\|O` | âœ— |
| `u` | `number` | let/var | `C.toneMapping` | âœ— |
| `f` | `any` | let/var | `r.viewport` | âœ— |
| `e` | `boolean` | let/var | `!1` | âœ— |
| `a` | `any` | let/var | `t[i]` | âœ— |
| `o` | `any` | let/var | `a.object` | âœ— |
| `s` | `any` | let/var | `a.geometry` | âœ— |
| `l` | `any` | let/var | `a.material` | âœ— |
| `d` | `any` | let/var | `a.group` | âœ— |
| `t` | `any` | let/var | `l.side` | âœ— |
| `r` | `any` | let/var | `!0===t.isScene?t.overrideMaterial:null` | âœ— |
| `a` | `any` | let/var | `e[i]` | âœ— |
| `o` | `any` | let/var | `a.object` | âœ— |
| `s` | `any` | let/var | `a.geometry` | âœ— |
| `l` | `any` | let/var | `a.group` | âœ— |
| `c` | `any` | let/var | `a.material` | âœ— |
| `i` | `any` | let/var | `R.state.lights` | âœ— |
| `a` | `any` | let/var | `R.state.shadowsArray` | âœ— |
| `o` | `any` | let/var | `i.state.version` | âœ— |
| `c` | `any` | let/var | `r.programs` | âœ— |
| `u` | `any` | let/var | `r.uniforms` | âœ— |
| `n` | `any` | let/var | `R.state.shadowsArray` | âœ— |
| `r` | `any` | let/var | `x.opaque` | âœ— |
| `i` | `any` | let/var | `x.transmissive` | âœ— |
| `n` | `any` | let/var | `t.cameras` | âœ— |
| `r` | `any` | let/var | `n[t]` | âœ— |
| `r` | `boolean` | let/var | `!0` | âœ— |
| `i` | `any` | let/var | `null` | âœ— |
| `a` | `boolean` | let/var | `!1` | âœ— |
| `o` | `boolean` | let/var | `!1` | âœ— |
| `t` | `any` | let/var | `e.depthTexture` | âœ— |
| `l` | `any` | let/var | `e.texture` | âœ— |
| `c` | `any` | let/var | `ue.get(e).__webglFramebuffer` | âœ— |
| `r` | `number` | let/var | `t` | âœ— |
| `l` | `any` | let/var | `ue.get(e).__webglFramebuffer` | âœ— |
| `o` | `any` | let/var | `e.textures[s]` | âœ— |
| `l` | `any` | let/var | `o.format` | âœ— |
| `c` | `any` | let/var | `o.type` | âœ— |
| `e` | `any` | let/var | `null!==w?ue.get(w).__webglFramebuffer:null` | âœ— |
| `l` | `any` | let/var | `ue.get(e).__webglFramebuffer` | âœ— |
| `o` | `any` | let/var | `e.textures[s]` | âœ— |
| `c` | `any` | let/var | `o.format` | âœ— |
| `d` | `any` | let/var | `o.type` | âœ— |
| `f` | `any` | let/var | `null!==w?ue.get(w).__webglFramebuffer:null` | âœ— |
| `o` | `any` | let/var | `null!==t?t.x:0` | âœ— |
| `s` | `any` | let/var | `null!==t?t.y:0` | âœ— |
| `o` | `any` | let/var | `*not shown*` | âœ— |
| `s` | `any` | let/var | `*not shown*` | âœ— |
| `l` | `any` | let/var | `*not shown*` | âœ— |
| `c` | `any` | let/var | `*not shown*` | âœ— |
| `d` | `any` | let/var | `*not shown*` | âœ— |
| `u` | `any` | let/var | `*not shown*` | âœ— |
| `f` | `any` | let/var | `*not shown*` | âœ— |
| `p` | `any` | let/var | `*not shown*` | âœ— |
| `m` | `any` | let/var | `*not shown*` | âœ— |
| `h` | `any` | let/var | `e.isCompressedTexture?e.mipmaps[a]:e.image` | âœ— |
| `v` | `any` | let/var | `*not shown*` | âœ— |
| `R` | `any` | let/var | `e.isDataArrayTexture\|\|e.isData3DTexture` | âœ— |
| `A` | `any` | let/var | `t.isDataArrayTexture\|\|t.isData3DTexture` | âœ— |


---

## Re-exports

| Type | Source | Exported Names |
|------|--------|----------------|
| named | `./three.core.min.js` | AdditiveAnimationBlendMode, AlwaysStencilFunc, AmbientLight, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrowHelper, AttachedBindMode, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BasicDepthPacking, BasicShadowMap, BatchedMesh, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxHelper, BufferGeometryLoader, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CircleGeometry, Clock, ColorKeyframeTrack, CompressedArrayTexture, CompressedCubeTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, Controls, CubeCamera, CubeTextureLoader, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceFrontBack, Curve, CurvePath, CylinderGeometry, Cylindrical, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DetachedBindMode, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DodecahedronGeometry, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualStencilFunc, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, Fog, FogExp2, FramebufferTexture, FrustumArray, GLBufferAttribute, GLSL1, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HemisphereLight, HemisphereLightHelper, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InterpolationSamplingMode, InterpolationSamplingType, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, MOUSE, Material, MaterialLoader, MathUtils, Matrix2, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NeverStencilFunc, NormalAnimationBlendMode, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, OctahedronGeometry, Path, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RGBDepthPacking, RGBIntegerFormat, RGDepthPacking, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RenderTarget, RenderTarget3D, ReplaceStencilOp, RingGeometry, Scene, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, TOUCH, TetrahedronGeometry, TextureLoader, TextureUtils, Timer, TimestampQuery, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, UVMapping, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, VectorKeyframeTrack, VideoFrameTexture, VideoTexture, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroSlopeEnding, ZeroStencilOp |


---

## Functions

### `An(): { start: () => void; stop: () => void; setAnimationLoop: (e: any) => void; setContext: (t: any) => void; }`

**Returns:** `{ start: () => void; stop: () => void; setAnimationLoop: (e: any) => void; setContext: (t: any) => void; }`

**Calls:**

- `n`
- `e.requestAnimationFrame`
- `e.cancelAnimationFrame`

<details><summary>Code</summary>

```typescript
function An(){let e=null,t=!1,n=null,r=null;function i(t,a){n(t,a),r=e.requestAnimationFrame(i)}return{start:function(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(i),t=!0)},stop:function(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}
```
</details>

### `i(t: any, a: any): void`

**Parameters:**

- **`t`** `any`
- **`a`** `any`

**Returns:** `void`

**Calls:**

- `n`
- `e.requestAnimationFrame`

<details><summary>Code</summary>

```typescript
function i(t,a){n(t,a),r=e.requestAnimationFrame(i)}
```
</details>

### `start(): void`

**Returns:** `void`

**Calls:**

- `e.requestAnimationFrame`

<details><summary>Code</summary>

```typescript
function(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(i),t=!0)}
```
</details>

### `stop(): void`

**Returns:** `void`

**Calls:**

- `e.cancelAnimationFrame`

<details><summary>Code</summary>

```typescript
function(){e.cancelAnimationFrame(r),t=!1}
```
</details>

### `setAnimationLoop(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){n=e}
```
</details>

### `setContext(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(t){e=t}
```
</details>

### `start(): void`

**Returns:** `void`

**Calls:**

- `e.requestAnimationFrame`

<details><summary>Code</summary>

```typescript
function(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(i),t=!0)}
```
</details>

### `stop(): void`

**Returns:** `void`

**Calls:**

- `e.cancelAnimationFrame`

<details><summary>Code</summary>

```typescript
function(){e.cancelAnimationFrame(r),t=!1}
```
</details>

### `setAnimationLoop(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){n=e}
```
</details>

### `setContext(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(t){e=t}
```
</details>

### `bn(e: any): { get: (e: any) => any; remove: (n: any) => void; update: (n: any, r: any) => any; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ get: (e: any) => any; remove: (n: any) => void; update: (n: any, r: any) => any; }`

**Calls:**

- `t.get`
- `e.deleteBuffer`
- `t.delete`
- `t.set`
- `complex_call_8772`
- `e.createBuffer`
- `e.bindBuffer`
- `e.bufferData`
- `t.onUploadCallback`
- `complex_call_9806`
- `e.bufferSubData`
- `a.sort`
- `Math.max`
- `n.clearUpdateRanges`
- `n.onUploadCallback`

<details><summary>Code</summary>

```typescript
function bn(e){const t=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),t.get(e)},remove:function(n){n.isInterleavedBufferAttribute&&(n=n.data);const r=t.get(n);r&&(e.deleteBuffer(r.buffer),t.delete(n))},update:function(n,r){if(n.isInterleavedBufferAttribute&&(n=n.data),n.isGLBufferAttribute){const e=t.get(n);return void((!e||e.version<n.version)&&t.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}const i=t.get(n);if(void 0===i)t.set(n,function(t,n){const r=t.array,i=t.usage,a=r.byteLength,o=e.createBuffer();let s;if(e.bindBuffer(n,o),e.bufferData(n,r,i),t.onUploadCallback(),r instanceof Float32Array)s=e.FLOAT;else if("undefined"!=typeof Float16Array&&r instanceof Float16Array)s=e.HALF_FLOAT;else if(r instanceof Uint16Array)s=t.isFloat16BufferAttribute?e.HALF_FLOAT:e.UNSIGNED_SHORT;else if(r instanceof Int16Array)s=e.SHORT;else if(r instanceof Uint32Array)s=e.UNSIGNED_INT;else if(r instanceof Int32Array)s=e.INT;else if(r instanceof Int8Array)s=e.BYTE;else if(r instanceof Uint8Array)s=e.UNSIGNED_BYTE;else{if(!(r instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+r);s=e.UNSIGNED_BYTE}return{buffer:o,type:s,bytesPerElement:r.BYTES_PER_ELEMENT,version:t.version,size:a}}(n,r));else if(i.version<n.version){if(i.size!==n.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(t,n,r){const i=n.array,a=n.updateRanges;if(e.bindBuffer(r,t),0===a.length)e.bufferSubData(r,0,i);else{a.sort((e,t)=>e.start-t.start);let t=0;for(let e=1;e<a.length;e++){const n=a[t],r=a[e];r.start<=n.start+n.count+1?n.count=Math.max(n.count,r.start+r.count-n.start):(++t,a[t]=r)}a.length=t+1;for(let t=0,n=a.length;t<n;t++){const n=a[t];e.bufferSubData(r,n.start*i.BYTES_PER_ELEMENT,i,n.start,n.count)}n.clearUpdateRanges()}n.onUploadCallback()}(i.buffer,n,r),i.version=n.version}}}}
```
</details>

### `get(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `t.get`

<details><summary>Code</summary>

```typescript
function(e){return e.isInterleavedBufferAttribute&&(e=e.data),t.get(e)}
```
</details>

### `remove(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `t.get`
- `e.deleteBuffer`
- `t.delete`

<details><summary>Code</summary>

```typescript
function(n){n.isInterleavedBufferAttribute&&(n=n.data);const r=t.get(n);r&&(e.deleteBuffer(r.buffer),t.delete(n))}
```
</details>

### `update(n: any, r: any): any`

**Parameters:**

- **`n`** `any`
- **`r`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `t.set`
- `complex_call_8772`
- `e.createBuffer`
- `e.bindBuffer`
- `e.bufferData`
- `t.onUploadCallback`
- `complex_call_9806`
- `e.bufferSubData`
- `a.sort`
- `Math.max`
- `n.clearUpdateRanges`
- `n.onUploadCallback`

<details><summary>Code</summary>

```typescript
function(n,r){if(n.isInterleavedBufferAttribute&&(n=n.data),n.isGLBufferAttribute){const e=t.get(n);return void((!e||e.version<n.version)&&t.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}const i=t.get(n);if(void 0===i)t.set(n,function(t,n){const r=t.array,i=t.usage,a=r.byteLength,o=e.createBuffer();let s;if(e.bindBuffer(n,o),e.bufferData(n,r,i),t.onUploadCallback(),r instanceof Float32Array)s=e.FLOAT;else if("undefined"!=typeof Float16Array&&r instanceof Float16Array)s=e.HALF_FLOAT;else if(r instanceof Uint16Array)s=t.isFloat16BufferAttribute?e.HALF_FLOAT:e.UNSIGNED_SHORT;else if(r instanceof Int16Array)s=e.SHORT;else if(r instanceof Uint32Array)s=e.UNSIGNED_INT;else if(r instanceof Int32Array)s=e.INT;else if(r instanceof Int8Array)s=e.BYTE;else if(r instanceof Uint8Array)s=e.UNSIGNED_BYTE;else{if(!(r instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+r);s=e.UNSIGNED_BYTE}return{buffer:o,type:s,bytesPerElement:r.BYTES_PER_ELEMENT,version:t.version,size:a}}(n,r));else if(i.version<n.version){if(i.size!==n.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(t,n,r){const i=n.array,a=n.updateRanges;if(e.bindBuffer(r,t),0===a.length)e.bufferSubData(r,0,i);else{a.sort((e,t)=>e.start-t.start);let t=0;for(let e=1;e<a.length;e++){const n=a[t],r=a[e];r.start<=n.start+n.count+1?n.count=Math.max(n.count,r.start+r.count-n.start):(++t,a[t]=r)}a.length=t+1;for(let t=0,n=a.length;t<n;t++){const n=a[t];e.bufferSubData(r,n.start*i.BYTES_PER_ELEMENT,i,n.start,n.count)}n.clearUpdateRanges()}n.onUploadCallback()}(i.buffer,n,r),i.version=n.version}}
```
</details>

### `get(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `t.get`

<details><summary>Code</summary>

```typescript
function(e){return e.isInterleavedBufferAttribute&&(e=e.data),t.get(e)}
```
</details>

### `remove(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `t.get`
- `e.deleteBuffer`
- `t.delete`

<details><summary>Code</summary>

```typescript
function(n){n.isInterleavedBufferAttribute&&(n=n.data);const r=t.get(n);r&&(e.deleteBuffer(r.buffer),t.delete(n))}
```
</details>

### `update(n: any, r: any): any`

**Parameters:**

- **`n`** `any`
- **`r`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `t.set`
- `complex_call_8772`
- `e.createBuffer`
- `e.bindBuffer`
- `e.bufferData`
- `t.onUploadCallback`
- `complex_call_9806`
- `e.bufferSubData`
- `a.sort`
- `Math.max`
- `n.clearUpdateRanges`
- `n.onUploadCallback`

<details><summary>Code</summary>

```typescript
function(n,r){if(n.isInterleavedBufferAttribute&&(n=n.data),n.isGLBufferAttribute){const e=t.get(n);return void((!e||e.version<n.version)&&t.set(n,{buffer:n.buffer,type:n.type,bytesPerElement:n.elementSize,version:n.version}))}const i=t.get(n);if(void 0===i)t.set(n,function(t,n){const r=t.array,i=t.usage,a=r.byteLength,o=e.createBuffer();let s;if(e.bindBuffer(n,o),e.bufferData(n,r,i),t.onUploadCallback(),r instanceof Float32Array)s=e.FLOAT;else if("undefined"!=typeof Float16Array&&r instanceof Float16Array)s=e.HALF_FLOAT;else if(r instanceof Uint16Array)s=t.isFloat16BufferAttribute?e.HALF_FLOAT:e.UNSIGNED_SHORT;else if(r instanceof Int16Array)s=e.SHORT;else if(r instanceof Uint32Array)s=e.UNSIGNED_INT;else if(r instanceof Int32Array)s=e.INT;else if(r instanceof Int8Array)s=e.BYTE;else if(r instanceof Uint8Array)s=e.UNSIGNED_BYTE;else{if(!(r instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+r);s=e.UNSIGNED_BYTE}return{buffer:o,type:s,bytesPerElement:r.BYTES_PER_ELEMENT,version:t.version,size:a}}(n,r));else if(i.version<n.version){if(i.size!==n.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");!function(t,n,r){const i=n.array,a=n.updateRanges;if(e.bindBuffer(r,t),0===a.length)e.bufferSubData(r,0,i);else{a.sort((e,t)=>e.start-t.start);let t=0;for(let e=1;e<a.length;e++){const n=a[t],r=a[e];r.start<=n.start+n.count+1?n.count=Math.max(n.count,r.start+r.count-n.start):(++t,a[t]=r)}a.length=t+1;for(let t=0,n=a.length;t<n;t++){const n=a[t];e.bufferSubData(r,n.start*i.BYTES_PER_ELEMENT,i,n.start,n.count)}n.clearUpdateRanges()}n.onUploadCallback()}(i.buffer,n,r),i.version=n.version}}
```
</details>

### `yn(e: any, t: any, r: any, i: any, u: any, f: any, v: any): { getClearColor: () => $r; setClearColor: (e: any, t?: number) => void; getClearAlpha: () => number; setClearAlpha: (e: any) => void; render: (t: any) => void; addToRenderList: (t: any, n: any) => void; dispose: () => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`r`** `any`
- **`i`** `any`
- **`u`** `any`
- **`f`** `any`
- **`v`** `any`

**Returns:** `{ getClearColor: () => $r; setClearColor: (e: any, t?: number) => void; getClearAlpha: () => number; setClearAlpha: (e: any) => void; render: (t: any) => void; addToRenderList: (t: any, n: any) => void; dispose: () => void; }`

**Calls:**

- `(e.backgroundBlurriness>0?r:t).get`
- `t.getRGB`
- `g (from ./three.core.min.js)`
- `i.buffers.color.setClear`
- `E.set`
- `C`
- `b`
- `e.xr.getEnvironmentBlendMode`
- `i.buffers.depth.setTest`
- `i.buffers.depth.setMask`
- `i.buffers.color.setMask`
- `e.clear`
- `d (from ./three.core.min.js)`
- `T.geometry.deleteAttribute`
- `this.matrixWorld.copyPosition`
- `Object.defineProperty`
- `u.update`
- `Dn.copy`
- `T.material.uniforms.backgroundRotation.value.setFromMatrix4`
- `wn.makeRotationFromEuler`
- `p.getTransfer`
- `T.layers.enableAll`
- `t.unshift`
- `S.geometry.deleteAttribute`
- `r.updateMatrix`
- `S.material.uniforms.uvTransform.value.copy`
- `S.layers.enableAll`
- `T.geometry.dispose`
- `T.material.dispose`
- `S.geometry.dispose`
- `S.material.dispose`

<details><summary>Code</summary>

```typescript
function yn(e,t,r,i,u,f,v){const E=new n(0);let S,T,M=!0===f?0:1,x=null,R=0,A=null;function b(e){let n=!0===e.isScene?e.background:null;if(n&&n.isTexture){n=(e.backgroundBlurriness>0?r:t).get(n)}return n}function C(t,n){t.getRGB(Un,g(e)),i.buffers.color.setClear(Un.r,Un.g,Un.b,n,v)}return{getClearColor:function(){return E},setClearColor:function(e,t=1){E.set(e),M=t,C(E,M)},getClearAlpha:function(){return M},setClearAlpha:function(e){M=e,C(E,M)},render:function(t){let n=!1;const r=b(t);null===r?C(E,M):r&&r.isColor&&(C(r,1),n=!0);const a=e.xr.getEnvironmentBlendMode();"additive"===a?i.buffers.color.setClear(0,0,0,1,v):"alpha-blend"===a&&i.buffers.color.setClear(0,0,0,0,v),(e.autoClear||n)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil))},addToRenderList:function(t,n){const r=b(n);r&&(r.isCubeTexture||r.mapping===a)?(void 0===T&&(T=new o(new s(1,1,1),new l({name:"BackgroundCubeMaterial",uniforms:d(Pn.backgroundCube.uniforms),vertexShader:Pn.backgroundCube.vertexShader,fragmentShader:Pn.backgroundCube.fragmentShader,side:c,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),T.geometry.deleteAttribute("normal"),T.geometry.deleteAttribute("uv"),T.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(T.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),u.update(T)),Dn.copy(n.backgroundRotation),Dn.x*=-1,Dn.y*=-1,Dn.z*=-1,r.isCubeTexture&&!1===r.isRenderTargetTexture&&(Dn.y*=-1,Dn.z*=-1),T.material.uniforms.envMap.value=r,T.material.uniforms.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,T.material.uniforms.backgroundBlurriness.value=n.backgroundBlurriness,T.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,T.material.uniforms.backgroundRotation.value.setFromMatrix4(wn.makeRotationFromEuler(Dn)),T.material.toneMapped=p.getTransfer(r.colorSpace)!==m,x===r&&R===r.version&&A===e.toneMapping||(T.material.needsUpdate=!0,x=r,R=r.version,A=e.toneMapping),T.layers.enableAll(),t.unshift(T,T.geometry,T.material,0,0,null)):r&&r.isTexture&&(void 0===S&&(S=new o(new h(2,2),new l({name:"BackgroundMaterial",uniforms:d(Pn.background.uniforms),vertexShader:Pn.background.vertexShader,fragmentShader:Pn.background.fragmentShader,side:_,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),S.geometry.deleteAttribute("normal"),Object.defineProperty(S.material,"map",{get:function(){return this.uniforms.t2D.value}}),u.update(S)),S.material.uniforms.t2D.value=r,S.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,S.material.toneMapped=p.getTransfer(r.colorSpace)!==m,!0===r.matrixAutoUpdate&&r.updateMatrix(),S.material.uniforms.uvTransform.value.copy(r.matrix),x===r&&R===r.version&&A===e.toneMapping||(S.material.needsUpdate=!0,x=r,R=r.version,A=e.toneMapping),S.layers.enableAll(),t.unshift(S,S.geometry,S.material,0,0,null))},dispose:function(){void 0!==T&&(T.geometry.dispose(),T.material.dispose(),T=void 0),void 0!==S&&(S.geometry.dispose(),S.material.dispose(),S=void 0)}}}
```
</details>

### `b(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `(e.backgroundBlurriness>0?r:t).get`

<details><summary>Code</summary>

```typescript
function b(e){let n=!0===e.isScene?e.background:null;if(n&&n.isTexture){n=(e.backgroundBlurriness>0?r:t).get(n)}return n}
```
</details>

### `C(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `t.getRGB`
- `g (from ./three.core.min.js)`
- `i.buffers.color.setClear`

<details><summary>Code</summary>

```typescript
function C(t,n){t.getRGB(Un,g(e)),i.buffers.color.setClear(Un.r,Un.g,Un.b,n,v)}
```
</details>

### `getClearColor(): $r`

**Returns:** `$r`

<details><summary>Code</summary>

```typescript
function(){return E}
```
</details>

### `setClearColor(e: any, t: number): void`

**Parameters:**

- **`e`** `any`
- **`t`** `number`

**Returns:** `void`

**Calls:**

- `E.set`
- `C`

<details><summary>Code</summary>

```typescript
function(e,t=1){E.set(e),M=t,C(E,M)}
```
</details>

### `getClearAlpha(): number`

**Returns:** `number`

<details><summary>Code</summary>

```typescript
function(){return M}
```
</details>

### `setClearAlpha(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `C`

<details><summary>Code</summary>

```typescript
function(e){M=e,C(E,M)}
```
</details>

### `render(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `b`
- `C`
- `e.xr.getEnvironmentBlendMode`
- `i.buffers.color.setClear`
- `i.buffers.depth.setTest`
- `i.buffers.depth.setMask`
- `i.buffers.color.setMask`
- `e.clear`

<details><summary>Code</summary>

```typescript
function(t){let n=!1;const r=b(t);null===r?C(E,M):r&&r.isColor&&(C(r,1),n=!0);const a=e.xr.getEnvironmentBlendMode();"additive"===a?i.buffers.color.setClear(0,0,0,1,v):"alpha-blend"===a&&i.buffers.color.setClear(0,0,0,0,v),(e.autoClear||n)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil))}
```
</details>

### `addToRenderList(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `b`
- `d (from ./three.core.min.js)`
- `T.geometry.deleteAttribute`
- `this.matrixWorld.copyPosition`
- `Object.defineProperty`
- `u.update`
- `Dn.copy`
- `T.material.uniforms.backgroundRotation.value.setFromMatrix4`
- `wn.makeRotationFromEuler`
- `p.getTransfer`
- `T.layers.enableAll`
- `t.unshift`
- `S.geometry.deleteAttribute`
- `r.updateMatrix`
- `S.material.uniforms.uvTransform.value.copy`
- `S.layers.enableAll`

<details><summary>Code</summary>

```typescript
function(t,n){const r=b(n);r&&(r.isCubeTexture||r.mapping===a)?(void 0===T&&(T=new o(new s(1,1,1),new l({name:"BackgroundCubeMaterial",uniforms:d(Pn.backgroundCube.uniforms),vertexShader:Pn.backgroundCube.vertexShader,fragmentShader:Pn.backgroundCube.fragmentShader,side:c,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),T.geometry.deleteAttribute("normal"),T.geometry.deleteAttribute("uv"),T.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(T.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),u.update(T)),Dn.copy(n.backgroundRotation),Dn.x*=-1,Dn.y*=-1,Dn.z*=-1,r.isCubeTexture&&!1===r.isRenderTargetTexture&&(Dn.y*=-1,Dn.z*=-1),T.material.uniforms.envMap.value=r,T.material.uniforms.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,T.material.uniforms.backgroundBlurriness.value=n.backgroundBlurriness,T.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,T.material.uniforms.backgroundRotation.value.setFromMatrix4(wn.makeRotationFromEuler(Dn)),T.material.toneMapped=p.getTransfer(r.colorSpace)!==m,x===r&&R===r.version&&A===e.toneMapping||(T.material.needsUpdate=!0,x=r,R=r.version,A=e.toneMapping),T.layers.enableAll(),t.unshift(T,T.geometry,T.material,0,0,null)):r&&r.isTexture&&(void 0===S&&(S=new o(new h(2,2),new l({name:"BackgroundMaterial",uniforms:d(Pn.background.uniforms),vertexShader:Pn.background.vertexShader,fragmentShader:Pn.background.fragmentShader,side:_,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),S.geometry.deleteAttribute("normal"),Object.defineProperty(S.material,"map",{get:function(){return this.uniforms.t2D.value}}),u.update(S)),S.material.uniforms.t2D.value=r,S.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,S.material.toneMapped=p.getTransfer(r.colorSpace)!==m,!0===r.matrixAutoUpdate&&r.updateMatrix(),S.material.uniforms.uvTransform.value.copy(r.matrix),x===r&&R===r.version&&A===e.toneMapping||(S.material.needsUpdate=!0,x=r,R=r.version,A=e.toneMapping),S.layers.enableAll(),t.unshift(S,S.geometry,S.material,0,0,null))}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.envMap.value}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.envMap.value}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.t2D.value}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.t2D.value}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `T.geometry.dispose`
- `T.material.dispose`
- `S.geometry.dispose`
- `S.material.dispose`

<details><summary>Code</summary>

```typescript
function(){void 0!==T&&(T.geometry.dispose(),T.material.dispose(),T=void 0),void 0!==S&&(S.geometry.dispose(),S.material.dispose(),S=void 0)}
```
</details>

### `getClearColor(): $r`

**Returns:** `$r`

<details><summary>Code</summary>

```typescript
function(){return E}
```
</details>

### `setClearColor(e: any, t: number): void`

**Parameters:**

- **`e`** `any`
- **`t`** `number`

**Returns:** `void`

**Calls:**

- `E.set`
- `C`

<details><summary>Code</summary>

```typescript
function(e,t=1){E.set(e),M=t,C(E,M)}
```
</details>

### `getClearAlpha(): number`

**Returns:** `number`

<details><summary>Code</summary>

```typescript
function(){return M}
```
</details>

### `setClearAlpha(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `C`

<details><summary>Code</summary>

```typescript
function(e){M=e,C(E,M)}
```
</details>

### `render(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `b`
- `C`
- `e.xr.getEnvironmentBlendMode`
- `i.buffers.color.setClear`
- `i.buffers.depth.setTest`
- `i.buffers.depth.setMask`
- `i.buffers.color.setMask`
- `e.clear`

<details><summary>Code</summary>

```typescript
function(t){let n=!1;const r=b(t);null===r?C(E,M):r&&r.isColor&&(C(r,1),n=!0);const a=e.xr.getEnvironmentBlendMode();"additive"===a?i.buffers.color.setClear(0,0,0,1,v):"alpha-blend"===a&&i.buffers.color.setClear(0,0,0,0,v),(e.autoClear||n)&&(i.buffers.depth.setTest(!0),i.buffers.depth.setMask(!0),i.buffers.color.setMask(!0),e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil))}
```
</details>

### `addToRenderList(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `b`
- `d (from ./three.core.min.js)`
- `T.geometry.deleteAttribute`
- `this.matrixWorld.copyPosition`
- `Object.defineProperty`
- `u.update`
- `Dn.copy`
- `T.material.uniforms.backgroundRotation.value.setFromMatrix4`
- `wn.makeRotationFromEuler`
- `p.getTransfer`
- `T.layers.enableAll`
- `t.unshift`
- `S.geometry.deleteAttribute`
- `r.updateMatrix`
- `S.material.uniforms.uvTransform.value.copy`
- `S.layers.enableAll`

<details><summary>Code</summary>

```typescript
function(t,n){const r=b(n);r&&(r.isCubeTexture||r.mapping===a)?(void 0===T&&(T=new o(new s(1,1,1),new l({name:"BackgroundCubeMaterial",uniforms:d(Pn.backgroundCube.uniforms),vertexShader:Pn.backgroundCube.vertexShader,fragmentShader:Pn.backgroundCube.fragmentShader,side:c,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),T.geometry.deleteAttribute("normal"),T.geometry.deleteAttribute("uv"),T.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(T.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),u.update(T)),Dn.copy(n.backgroundRotation),Dn.x*=-1,Dn.y*=-1,Dn.z*=-1,r.isCubeTexture&&!1===r.isRenderTargetTexture&&(Dn.y*=-1,Dn.z*=-1),T.material.uniforms.envMap.value=r,T.material.uniforms.flipEnvMap.value=r.isCubeTexture&&!1===r.isRenderTargetTexture?-1:1,T.material.uniforms.backgroundBlurriness.value=n.backgroundBlurriness,T.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,T.material.uniforms.backgroundRotation.value.setFromMatrix4(wn.makeRotationFromEuler(Dn)),T.material.toneMapped=p.getTransfer(r.colorSpace)!==m,x===r&&R===r.version&&A===e.toneMapping||(T.material.needsUpdate=!0,x=r,R=r.version,A=e.toneMapping),T.layers.enableAll(),t.unshift(T,T.geometry,T.material,0,0,null)):r&&r.isTexture&&(void 0===S&&(S=new o(new h(2,2),new l({name:"BackgroundMaterial",uniforms:d(Pn.background.uniforms),vertexShader:Pn.background.vertexShader,fragmentShader:Pn.background.fragmentShader,side:_,depthTest:!1,depthWrite:!1,fog:!1,allowOverride:!1})),S.geometry.deleteAttribute("normal"),Object.defineProperty(S.material,"map",{get:function(){return this.uniforms.t2D.value}}),u.update(S)),S.material.uniforms.t2D.value=r,S.material.uniforms.backgroundIntensity.value=n.backgroundIntensity,S.material.toneMapped=p.getTransfer(r.colorSpace)!==m,!0===r.matrixAutoUpdate&&r.updateMatrix(),S.material.uniforms.uvTransform.value.copy(r.matrix),x===r&&R===r.version&&A===e.toneMapping||(S.material.needsUpdate=!0,x=r,R=r.version,A=e.toneMapping),S.layers.enableAll(),t.unshift(S,S.geometry,S.material,0,0,null))}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.envMap.value}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.envMap.value}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.t2D.value}
```
</details>

### `get(): any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(){return this.uniforms.t2D.value}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `T.geometry.dispose`
- `T.material.dispose`
- `S.geometry.dispose`
- `S.material.dispose`

<details><summary>Code</summary>

```typescript
function(){void 0!==T&&(T.geometry.dispose(),T.material.dispose(),T=void 0),void 0!==S&&(S.geometry.dispose(),S.material.dispose(),S=void 0)}
```
</details>

### `In(e: any, t: any): { setup: (n: any, i: any, l: any, h: any, _: any) => void; reset: () => void; resetDefaultState: () => void; dispose: () => void; releaseStatesOfGeometry: (e: any) => void; releaseStatesOfProgram: (e: any) => void; initAttributes: () => void; enableAttribute: (e: any) => void; disableUnusedAttributes: () => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `{ setup: (n: any, i: any, l: any, h: any, _: any) => void; reset: () => void; resetDefaultState: () => void; dispose: () => void; releaseStatesOfGeometry: (e: any) => void; releaseStatesOfProgram: (e: any) => void; initAttributes: () => void; enableAttribute: (e: any) => void; disableUnusedAttributes: () => void; }`

**Calls:**

- `e.getParameter`
- `c`
- `e.bindVertexArray`
- `e.deleteVertexArray`
- `f`
- `e.enableVertexAttribArray`
- `e.vertexAttribDivisor`
- `e.disableVertexAttribArray`
- `e.vertexAttribIPointer`
- `e.vertexAttribPointer`
- `_`
- `s`
- `complex_call_166692`
- `e.createVertexArray`
- `complex_call_166922`
- `n.getAttributes`
- `complex_call_167346`
- `t.update`
- `complex_call_167783`
- `d`
- `i.getAttributes`
- `t.get`
- `u`
- `e.bindBuffer`
- `m`
- `e.vertexAttrib2fv`
- `e.vertexAttrib3fv`
- `e.vertexAttrib4fv`
- `e.vertexAttrib1fv`
- `p`
- `h`
- `l`

<details><summary>Code</summary>

```typescript
function In(e,t){const n=e.getParameter(e.MAX_VERTEX_ATTRIBS),r={},i=c(null);let a=i,o=!1;function s(t){return e.bindVertexArray(t)}function l(t){return e.deleteVertexArray(t)}function c(e){const t=[],r=[],i=[];for(let e=0;e<n;e++)t[e]=0,r[e]=0,i[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:r,attributeDivisors:i,object:e,attributes:{},index:null}}function d(){const e=a.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function u(e){f(e,0)}function f(t,n){const r=a.newAttributes,i=a.enabledAttributes,o=a.attributeDivisors;r[t]=1,0===i[t]&&(e.enableVertexAttribArray(t),i[t]=1),o[t]!==n&&(e.vertexAttribDivisor(t,n),o[t]=n)}function p(){const t=a.newAttributes,n=a.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==t[r]&&(e.disableVertexAttribArray(r),n[r]=0)}function m(t,n,r,i,a,o,s){!0===s?e.vertexAttribIPointer(t,n,r,a,o):e.vertexAttribPointer(t,n,r,i,a,o)}function h(){_(),o=!0,a!==i&&(a=i,s(a.object))}function _(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:function(n,i,l,h,_){let g=!1;const E=function(t,n,i){const a=!0===i.wireframe;let o=r[t.id];void 0===o&&(o={},r[t.id]=o);let s=o[n.id];void 0===s&&(s={},o[n.id]=s);let l=s[a];void 0===l&&(l=c(e.createVertexArray()),s[a]=l);return l}(h,l,i);a!==E&&(a=E,s(a.object)),g=function(e,t,n,r){const i=a.attributes,o=t.attributes;let s=0;const l=n.getAttributes();for(const t in l){if(l[t].location>=0){const n=i[t];let r=o[t];if(void 0===r&&("instanceMatrix"===t&&e.instanceMatrix&&(r=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(r=e.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;s++}}return a.attributesNum!==s||a.index!==r}(n,h,l,_),g&&function(e,t,n,r){const i={},o=t.attributes;let s=0;const l=n.getAttributes();for(const t in l){if(l[t].location>=0){let n=o[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[t]=r,s++}}a.attributes=i,a.attributesNum=s,a.index=r}(n,h,l,_),null!==_&&t.update(_,e.ELEMENT_ARRAY_BUFFER),(g||o)&&(o=!1,function(n,r,i,a){d();const o=a.attributes,s=i.getAttributes(),l=r.defaultAttributeValues;for(const r in s){const i=s[r];if(i.location>=0){let s=o[r];if(void 0===s&&("instanceMatrix"===r&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===r&&n.instanceColor&&(s=n.instanceColor)),void 0!==s){const r=s.normalized,o=s.itemSize,l=t.get(s);if(void 0===l)continue;const c=l.buffer,d=l.type,p=l.bytesPerElement,h=d===e.INT||d===e.UNSIGNED_INT||s.gpuType===v;if(s.isInterleavedBufferAttribute){const t=s.data,l=t.stride,_=s.offset;if(t.isInstancedInterleavedBuffer){for(let e=0;e<i.locationSize;e++)f(i.location+e,t.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=t.meshPerAttribute*t.count)}else for(let e=0;e<i.locationSize;e++)u(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,o/i.locationSize,d,r,l*p,(_+o/i.locationSize*e)*p,h)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<i.locationSize;e++)f(i.location+e,s.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<i.locationSize;e++)u(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,o/i.locationSize,d,r,o*p,o/i.locationSize*e*p,h)}}else if(void 0!==l){const t=l[r];if(void 0!==t)switch(t.length){case 2:e.vertexAttrib2fv(i.location,t);break;case 3:e.vertexAttrib3fv(i.location,t);break;case 4:e.vertexAttrib4fv(i.location,t);break;default:e.vertexAttrib1fv(i.location,t)}}}}p()}(n,i,l,h),null!==_&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.get(_).buffer))},reset:h,resetDefaultState:_,dispose:function(){h();for(const e in r){const t=r[e];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete r[e]}},releaseStatesOfGeometry:function(e){if(void 0===r[e.id])return;const t=r[e.id];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete r[e.id]},releaseStatesOfProgram:function(e){for(const t in r){const n=r[t];if(void 0===n[e.id])continue;const i=n[e.id];for(const e in i)l(i[e].object),delete i[e];delete n[e.id]}},initAttributes:d,enableAttribute:u,disableUnusedAttributes:p}}
```
</details>

### `s(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.bindVertexArray`

<details><summary>Code</summary>

```typescript
function s(t){return e.bindVertexArray(t)}
```
</details>

### `l(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.deleteVertexArray`

<details><summary>Code</summary>

```typescript
function l(t){return e.deleteVertexArray(t)}
```
</details>

### `c(e: any): { geometry: any; program: any; wireframe: boolean; newAttributes: number[]; enabledAttributes: number[]; attributeDivisors: number[]; object: any; attributes: {}; index: any; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ geometry: any; program: any; wireframe: boolean; newAttributes: number[]; enabledAttributes: number[]; attributeDivisors: number[]; object: any; attributes: {}; index: any; }`

<details><summary>Code</summary>

```typescript
function c(e){const t=[],r=[],i=[];for(let e=0;e<n;e++)t[e]=0,r[e]=0,i[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:r,attributeDivisors:i,object:e,attributes:{},index:null}}
```
</details>

### `d(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function d(){const e=a.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}
```
</details>

### `u(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `f`

<details><summary>Code</summary>

```typescript
function u(e){f(e,0)}
```
</details>

### `f(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.enableVertexAttribArray`
- `e.vertexAttribDivisor`

<details><summary>Code</summary>

```typescript
function f(t,n){const r=a.newAttributes,i=a.enabledAttributes,o=a.attributeDivisors;r[t]=1,0===i[t]&&(e.enableVertexAttribArray(t),i[t]=1),o[t]!==n&&(e.vertexAttribDivisor(t,n),o[t]=n)}
```
</details>

### `p(): void`

**Returns:** `void`

**Calls:**

- `e.disableVertexAttribArray`

<details><summary>Code</summary>

```typescript
function p(){const t=a.newAttributes,n=a.enabledAttributes;for(let r=0,i=n.length;r<i;r++)n[r]!==t[r]&&(e.disableVertexAttribArray(r),n[r]=0)}
```
</details>

### `m(t: any, n: any, r: any, i: any, a: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `e.vertexAttribIPointer`
- `e.vertexAttribPointer`

<details><summary>Code</summary>

```typescript
function m(t,n,r,i,a,o,s){!0===s?e.vertexAttribIPointer(t,n,r,a,o):e.vertexAttribPointer(t,n,r,i,a,o)}
```
</details>

### `h(): void`

**Returns:** `void`

**Calls:**

- `_`
- `s`

<details><summary>Code</summary>

```typescript
function h(){_(),o=!0,a!==i&&(a=i,s(a.object))}
```
</details>

### `_(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function _(){i.geometry=null,i.program=null,i.wireframe=!1}
```
</details>

### `setup(n: any, i: any, l: any, h: any, _: any): void`

**Parameters:**

- **`n`** `any`
- **`i`** `any`
- **`l`** `any`
- **`h`** `any`
- **`_`** `any`

**Returns:** `void`

**Calls:**

- `complex_call_166692`
- `c`
- `e.createVertexArray`
- `s`
- `complex_call_166922`
- `n.getAttributes`
- `complex_call_167346`
- `t.update`
- `complex_call_167783`
- `d`
- `i.getAttributes`
- `t.get`
- `f`
- `u`
- `e.bindBuffer`
- `m`
- `e.vertexAttrib2fv`
- `e.vertexAttrib3fv`
- `e.vertexAttrib4fv`
- `e.vertexAttrib1fv`
- `p`

<details><summary>Code</summary>

```typescript
function(n,i,l,h,_){let g=!1;const E=function(t,n,i){const a=!0===i.wireframe;let o=r[t.id];void 0===o&&(o={},r[t.id]=o);let s=o[n.id];void 0===s&&(s={},o[n.id]=s);let l=s[a];void 0===l&&(l=c(e.createVertexArray()),s[a]=l);return l}(h,l,i);a!==E&&(a=E,s(a.object)),g=function(e,t,n,r){const i=a.attributes,o=t.attributes;let s=0;const l=n.getAttributes();for(const t in l){if(l[t].location>=0){const n=i[t];let r=o[t];if(void 0===r&&("instanceMatrix"===t&&e.instanceMatrix&&(r=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(r=e.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;s++}}return a.attributesNum!==s||a.index!==r}(n,h,l,_),g&&function(e,t,n,r){const i={},o=t.attributes;let s=0;const l=n.getAttributes();for(const t in l){if(l[t].location>=0){let n=o[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[t]=r,s++}}a.attributes=i,a.attributesNum=s,a.index=r}(n,h,l,_),null!==_&&t.update(_,e.ELEMENT_ARRAY_BUFFER),(g||o)&&(o=!1,function(n,r,i,a){d();const o=a.attributes,s=i.getAttributes(),l=r.defaultAttributeValues;for(const r in s){const i=s[r];if(i.location>=0){let s=o[r];if(void 0===s&&("instanceMatrix"===r&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===r&&n.instanceColor&&(s=n.instanceColor)),void 0!==s){const r=s.normalized,o=s.itemSize,l=t.get(s);if(void 0===l)continue;const c=l.buffer,d=l.type,p=l.bytesPerElement,h=d===e.INT||d===e.UNSIGNED_INT||s.gpuType===v;if(s.isInterleavedBufferAttribute){const t=s.data,l=t.stride,_=s.offset;if(t.isInstancedInterleavedBuffer){for(let e=0;e<i.locationSize;e++)f(i.location+e,t.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=t.meshPerAttribute*t.count)}else for(let e=0;e<i.locationSize;e++)u(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,o/i.locationSize,d,r,l*p,(_+o/i.locationSize*e)*p,h)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<i.locationSize;e++)f(i.location+e,s.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<i.locationSize;e++)u(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,o/i.locationSize,d,r,o*p,o/i.locationSize*e*p,h)}}else if(void 0!==l){const t=l[r];if(void 0!==t)switch(t.length){case 2:e.vertexAttrib2fv(i.location,t);break;case 3:e.vertexAttrib3fv(i.location,t);break;case 4:e.vertexAttrib4fv(i.location,t);break;default:e.vertexAttrib1fv(i.location,t)}}}}p()}(n,i,l,h),null!==_&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.get(_).buffer))}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `h`
- `l`

<details><summary>Code</summary>

```typescript
function(){h();for(const e in r){const t=r[e];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete r[e]}}
```
</details>

### `releaseStatesOfGeometry(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `l`

<details><summary>Code</summary>

```typescript
function(e){if(void 0===r[e.id])return;const t=r[e.id];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete r[e.id]}
```
</details>

### `releaseStatesOfProgram(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `l`

<details><summary>Code</summary>

```typescript
function(e){for(const t in r){const n=r[t];if(void 0===n[e.id])continue;const i=n[e.id];for(const e in i)l(i[e].object),delete i[e];delete n[e.id]}}
```
</details>

### `setup(n: any, i: any, l: any, h: any, _: any): void`

**Parameters:**

- **`n`** `any`
- **`i`** `any`
- **`l`** `any`
- **`h`** `any`
- **`_`** `any`

**Returns:** `void`

**Calls:**

- `complex_call_166692`
- `c`
- `e.createVertexArray`
- `s`
- `complex_call_166922`
- `n.getAttributes`
- `complex_call_167346`
- `t.update`
- `complex_call_167783`
- `d`
- `i.getAttributes`
- `t.get`
- `f`
- `u`
- `e.bindBuffer`
- `m`
- `e.vertexAttrib2fv`
- `e.vertexAttrib3fv`
- `e.vertexAttrib4fv`
- `e.vertexAttrib1fv`
- `p`

<details><summary>Code</summary>

```typescript
function(n,i,l,h,_){let g=!1;const E=function(t,n,i){const a=!0===i.wireframe;let o=r[t.id];void 0===o&&(o={},r[t.id]=o);let s=o[n.id];void 0===s&&(s={},o[n.id]=s);let l=s[a];void 0===l&&(l=c(e.createVertexArray()),s[a]=l);return l}(h,l,i);a!==E&&(a=E,s(a.object)),g=function(e,t,n,r){const i=a.attributes,o=t.attributes;let s=0;const l=n.getAttributes();for(const t in l){if(l[t].location>=0){const n=i[t];let r=o[t];if(void 0===r&&("instanceMatrix"===t&&e.instanceMatrix&&(r=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(r=e.instanceColor)),void 0===n)return!0;if(n.attribute!==r)return!0;if(r&&n.data!==r.data)return!0;s++}}return a.attributesNum!==s||a.index!==r}(n,h,l,_),g&&function(e,t,n,r){const i={},o=t.attributes;let s=0;const l=n.getAttributes();for(const t in l){if(l[t].location>=0){let n=o[t];void 0===n&&("instanceMatrix"===t&&e.instanceMatrix&&(n=e.instanceMatrix),"instanceColor"===t&&e.instanceColor&&(n=e.instanceColor));const r={};r.attribute=n,n&&n.data&&(r.data=n.data),i[t]=r,s++}}a.attributes=i,a.attributesNum=s,a.index=r}(n,h,l,_),null!==_&&t.update(_,e.ELEMENT_ARRAY_BUFFER),(g||o)&&(o=!1,function(n,r,i,a){d();const o=a.attributes,s=i.getAttributes(),l=r.defaultAttributeValues;for(const r in s){const i=s[r];if(i.location>=0){let s=o[r];if(void 0===s&&("instanceMatrix"===r&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===r&&n.instanceColor&&(s=n.instanceColor)),void 0!==s){const r=s.normalized,o=s.itemSize,l=t.get(s);if(void 0===l)continue;const c=l.buffer,d=l.type,p=l.bytesPerElement,h=d===e.INT||d===e.UNSIGNED_INT||s.gpuType===v;if(s.isInterleavedBufferAttribute){const t=s.data,l=t.stride,_=s.offset;if(t.isInstancedInterleavedBuffer){for(let e=0;e<i.locationSize;e++)f(i.location+e,t.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=t.meshPerAttribute*t.count)}else for(let e=0;e<i.locationSize;e++)u(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,o/i.locationSize,d,r,l*p,(_+o/i.locationSize*e)*p,h)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<i.locationSize;e++)f(i.location+e,s.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===a._maxInstanceCount&&(a._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<i.locationSize;e++)u(i.location+e);e.bindBuffer(e.ARRAY_BUFFER,c);for(let e=0;e<i.locationSize;e++)m(i.location+e,o/i.locationSize,d,r,o*p,o/i.locationSize*e*p,h)}}else if(void 0!==l){const t=l[r];if(void 0!==t)switch(t.length){case 2:e.vertexAttrib2fv(i.location,t);break;case 3:e.vertexAttrib3fv(i.location,t);break;case 4:e.vertexAttrib4fv(i.location,t);break;default:e.vertexAttrib1fv(i.location,t)}}}}p()}(n,i,l,h),null!==_&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t.get(_).buffer))}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `h`
- `l`

<details><summary>Code</summary>

```typescript
function(){h();for(const e in r){const t=r[e];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete r[e]}}
```
</details>

### `releaseStatesOfGeometry(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `l`

<details><summary>Code</summary>

```typescript
function(e){if(void 0===r[e.id])return;const t=r[e.id];for(const e in t){const n=t[e];for(const e in n)l(n[e].object),delete n[e];delete t[e]}delete r[e.id]}
```
</details>

### `releaseStatesOfProgram(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `l`

<details><summary>Code</summary>

```typescript
function(e){for(const t in r){const n=r[t];if(void 0===n[e.id])continue;const i=n[e.id];for(const e in i)l(i[e].object),delete i[e];delete n[e.id]}}
```
</details>

### `Nn(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.drawArraysInstanced`
- `n.update`
- `e.drawArrays`
- `t.get("WEBGL_multi_draw").multiDrawArraysWEBGL`
- `t.get`
- `i`
- `l.multiDrawArraysInstancedWEBGL`

<details><summary>Code</summary>

```typescript
function Nn(e,t,n){let r;function i(t,i,a){0!==a&&(e.drawArraysInstanced(r,t,i,a),n.update(i,r,a))}this.setMode=function(e){r=e},this.render=function(t,i){e.drawArrays(r,t,i),n.update(i,r,1)},this.renderInstances=i,this.renderMultiDraw=function(e,i,a){if(0===a)return;t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r,e,0,i,0,a);let o=0;for(let e=0;e<a;e++)o+=i[e];n.update(o,r,1)},this.renderMultiDrawInstances=function(e,a,o,s){if(0===o)return;const l=t.get("WEBGL_multi_draw");if(null===l)for(let t=0;t<e.length;t++)i(e[t],a[t],s[t]);else{l.multiDrawArraysInstancedWEBGL(r,e,0,a,0,s,0,o);let t=0;for(let e=0;e<o;e++)t+=a[e]*s[e];n.update(t,r,1)}}}
```
</details>

### `i(t: any, i: any, a: any): void`

**Parameters:**

- **`t`** `any`
- **`i`** `any`
- **`a`** `any`

**Returns:** `void`

**Calls:**

- `e.drawArraysInstanced`
- `n.update`

<details><summary>Code</summary>

```typescript
function i(t,i,a){0!==a&&(e.drawArraysInstanced(r,t,i,a),n.update(i,r,a))}
```
</details>

### `On(e: any, t: any, n: any, r: any): { isWebGL2: boolean; getMaxAnisotropy: () => any; getMaxPrecision: (t: any) => "highp" | "mediump" | "lowp"; textureFormatReadable: (t: any) => boolean; textureTypeReadable: (n: any) => boolean; ... 12 more ...; maxSamples: any; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `{ isWebGL2: boolean; getMaxAnisotropy: () => any; getMaxPrecision: (t: any) => "highp" | "mediump" | "lowp"; textureFormatReadable: (t: any) => boolean; textureTypeReadable: (n: any) => boolean; ... 12 more ...; maxSamples: any; }`

**Calls:**

- `e.getShaderPrecisionFormat`
- `a`
- `console.warn`
- `t.has`
- `e.getParameter`
- `t.get`
- `r.convert`

<details><summary>Code</summary>

```typescript
function On(e,t,n,r){let i;function a(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let o=void 0!==n.precision?n.precision:"highp";const s=a(o);s!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",s,"instead."),o=s);const l=!0===n.logarithmicDepthBuffer,c=!0===n.reversedDepthBuffer&&t.has("EXT_clip_control"),d=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),u=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);return{isWebGL2:!0,getMaxAnisotropy:function(){if(void 0!==i)return i;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");i=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i},getMaxPrecision:a,textureFormatReadable:function(t){return t===M||r.convert(t)===e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)},textureTypeReadable:function(n){const i=n===E&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(n!==S&&r.convert(n)!==e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE)&&n!==T&&!i)},precision:o,logarithmicDepthBuffer:l,reversedDepthBuffer:c,maxTextures:d,maxVertexTextures:u,maxTextureSize:e.getParameter(e.MAX_TEXTURE_SIZE),maxCubemapSize:e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes:e.getParameter(e.MAX_VERTEX_ATTRIBS),maxVertexUniforms:e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings:e.getParameter(e.MAX_VARYING_VECTORS),maxFragmentUniforms:e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures:u>0,maxSamples:e.getParameter(e.MAX_SAMPLES)}}
```
</details>

### `a(t: any): "highp" | "mediump" | "lowp"`

**Parameters:**

- **`t`** `any`

**Returns:** `"highp" | "mediump" | "lowp"`

**Calls:**

- `e.getShaderPrecisionFormat`

<details><summary>Code</summary>

```typescript
function a(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}
```
</details>

### `getMaxAnisotropy(): any`

**Returns:** `any`

**Calls:**

- `t.has`
- `t.get`
- `e.getParameter`

<details><summary>Code</summary>

```typescript
function(){if(void 0!==i)return i;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");i=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}
```
</details>

### `textureFormatReadable(t: any): boolean`

**Parameters:**

- **`t`** `any`

**Returns:** `boolean`

**Calls:**

- `r.convert`
- `e.getParameter`

<details><summary>Code</summary>

```typescript
function(t){return t===M||r.convert(t)===e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)}
```
</details>

### `textureTypeReadable(n: any): boolean`

**Parameters:**

- **`n`** `any`

**Returns:** `boolean`

**Calls:**

- `t.has`
- `r.convert`
- `e.getParameter`

<details><summary>Code</summary>

```typescript
function(n){const i=n===E&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(n!==S&&r.convert(n)!==e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE)&&n!==T&&!i)}
```
</details>

### `getMaxAnisotropy(): any`

**Returns:** `any`

**Calls:**

- `t.has`
- `t.get`
- `e.getParameter`

<details><summary>Code</summary>

```typescript
function(){if(void 0!==i)return i;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");i=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}
```
</details>

### `textureFormatReadable(t: any): boolean`

**Parameters:**

- **`t`** `any`

**Returns:** `boolean`

**Calls:**

- `r.convert`
- `e.getParameter`

<details><summary>Code</summary>

```typescript
function(t){return t===M||r.convert(t)===e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)}
```
</details>

### `textureTypeReadable(n: any): boolean`

**Parameters:**

- **`n`** `any`

**Returns:** `boolean`

**Calls:**

- `t.has`
- `r.convert`
- `e.getParameter`

<details><summary>Code</summary>

```typescript
function(n){const i=n===E&&(t.has("EXT_color_buffer_half_float")||t.has("EXT_color_buffer_float"));return!(n!==S&&r.convert(n)!==e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE)&&n!==T&&!i)}
```
</details>

### `Fn(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `l.getNormalMatrix`
- `s.copy(e[t]).applyMatrix4`
- `s.normal.toArray`
- `d`
- `t.get`
- `complex_call_173382`

<details><summary>Code</summary>

```typescript
function Fn(t){const n=this;let r=null,i=0,a=!1,o=!1;const s=new x,l=new e,c={value:null,needsUpdate:!1};function d(e,t,r,i){const a=null!==e?e.length:0;let o=null;if(0!==a){if(o=c.value,!0!==i||null===o){const n=r+4*a,i=t.matrixWorldInverse;l.getNormalMatrix(i),(null===o||o.length<n)&&(o=new Float32Array(n));for(let t=0,n=r;t!==a;++t,n+=4)s.copy(e[t]).applyMatrix4(i,l),s.normal.toArray(o,n),o[n+3]=s.constant}c.value=o,c.needsUpdate=!0}return n.numPlanes=a,n.numIntersection=0,o}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t){const n=0!==e.length||t||0!==i||a;return a=t,i=e.length,n},this.beginShadows=function(){o=!0,d(null)},this.endShadows=function(){o=!1},this.setGlobalState=function(e,t){r=d(e,t,0)},this.setState=function(e,s,l){const u=e.clippingPlanes,f=e.clipIntersection,p=e.clipShadows,m=t.get(e);if(!a||null===u||0===u.length||o&&!p)o?d(null):function(){c.value!==r&&(c.value=r,c.needsUpdate=i>0);n.numPlanes=i,n.numIntersection=0}();else{const e=o?0:i,t=4*e;let n=m.clippingState||null;c.value=n,n=d(u,s,t,l);for(let e=0;e!==t;++e)n[e]=r[e];m.clippingState=n,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=e}}}
```
</details>

### `d(e: any, t: any, r: any, i: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `any`

**Calls:**

- `l.getNormalMatrix`
- `s.copy(e[t]).applyMatrix4`
- `s.normal.toArray`

<details><summary>Code</summary>

```typescript
function d(e,t,r,i){const a=null!==e?e.length:0;let o=null;if(0!==a){if(o=c.value,!0!==i||null===o){const n=r+4*a,i=t.matrixWorldInverse;l.getNormalMatrix(i),(null===o||o.length<n)&&(o=new Float32Array(n));for(let t=0,n=r;t!==a;++t,n+=4)s.copy(e[t]).applyMatrix4(i,l),s.normal.toArray(o,n),o[n+3]=s.constant}c.value=o,c.needsUpdate=!0}return n.numPlanes=a,n.numIntersection=0,o}
```
</details>

### `Bn(e: any): { get: (i: any) => any; dispose: () => void; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ get: (i: any) => any; dispose: () => void; }`

**Calls:**

- `n.removeEventListener`
- `t.get`
- `t.delete`
- `i.dispose`
- `t.has`
- `n`
- `o.fromEquirectangularTexture`
- `t.set`
- `i.addEventListener`

<details><summary>Code</summary>

```typescript
function Bn(e){let t=new WeakMap;function n(e,t){return t===R?e.mapping=C:t===A&&(e.mapping=L),e}function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const a=i.mapping;if(a===R||a===A){if(t.has(i)){return n(t.get(i).texture,i.mapping)}{const a=i.image;if(a&&a.height>0){const o=new b(a.height);return o.fromEquirectangularTexture(e,i),t.set(i,o),i.addEventListener("dispose",r),n(o.texture,i.mapping)}return null}}}return i},dispose:function(){t=new WeakMap}}}
```
</details>

### `n(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function n(e,t){return t===R?e.mapping=C:t===A&&(e.mapping=L),e}
```
</details>

### `r(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `n.removeEventListener`
- `t.get`
- `t.delete`
- `i.dispose`

<details><summary>Code</summary>

```typescript
function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}
```
</details>

### `get(i: any): any`

**Parameters:**

- **`i`** `any`

**Returns:** `any`

**Calls:**

- `t.has`
- `n`
- `t.get`
- `o.fromEquirectangularTexture`
- `t.set`
- `i.addEventListener`

<details><summary>Code</summary>

```typescript
function(i){if(i&&i.isTexture){const a=i.mapping;if(a===R||a===A){if(t.has(i)){return n(t.get(i).texture,i.mapping)}{const a=i.image;if(a&&a.height>0){const o=new b(a.height);return o.fromEquirectangularTexture(e,i),t.set(i,o),i.addEventListener("dispose",r),n(o.texture,i.mapping)}return null}}}return i}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=new WeakMap}
```
</details>

### `get(i: any): any`

**Parameters:**

- **`i`** `any`

**Returns:** `any`

**Calls:**

- `t.has`
- `n`
- `t.get`
- `o.fromEquirectangularTexture`
- `t.set`
- `i.addEventListener`

<details><summary>Code</summary>

```typescript
function(i){if(i&&i.isTexture){const a=i.mapping;if(a===R||a===A){if(t.has(i)){return n(t.get(i).texture,i.mapping)}{const a=i.image;if(a&&a.height>0){const o=new b(a.height);return o.fromEquirectangularTexture(e,i),t.set(i,o),i.addEventListener("dispose",r),n(o.texture,i.mapping)}return null}}}return i}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=new WeakMap}
```
</details>

### `$n.fromScene(e: any, t: number, n: number, r: number, i: {}): zs`

**Parameters:**

- **`e`** `any`
- **`t`** `number`
- **`n`** `number`
- **`r`** `number`
- **`i`** `{}`

**Returns:** `zs`

**Calls:**

- `this._renderer.getRenderTarget`
- `this._renderer.getActiveCubeFace`
- `this._renderer.getActiveMipmapLevel`
- `this._setSize`
- `this._allocateTargets`
- `this._sceneToCubeUV`
- `this._blur`
- `this._applyPMREM`
- `this._cleanup`

<details><summary>Code</summary>

```typescript
fromScene(e,t=0,n=.1,r=100,i={}){const{size:a=256,position:o=Zn}=i;kn=this._renderer.getRenderTarget(),Wn=this._renderer.getActiveCubeFace(),Xn=this._renderer.getActiveMipmapLevel(),Yn=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,r,s,o),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}
```
</details>

### `$n.fromEquirectangular(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `this._fromTexture`

<details><summary>Code</summary>

```typescript
fromEquirectangular(e,t=null){return this._fromTexture(e,t)}
```
</details>

### `$n.fromCubemap(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `this._fromTexture`

<details><summary>Code</summary>

```typescript
fromCubemap(e,t=null){return this._fromTexture(e,t)}
```
</details>

### `$n.compileCubemapShader(): void`

**Returns:** `void`

**Calls:**

- `tr`
- `this._compileMaterial`

<details><summary>Code</summary>

```typescript
compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=tr(),this._compileMaterial(this._cubemapMaterial))}
```
</details>

### `$n.compileEquirectangularShader(): void`

**Returns:** `void`

**Calls:**

- `er`
- `this._compileMaterial`

<details><summary>Code</summary>

```typescript
compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=er(),this._compileMaterial(this._equirectMaterial))}
```
</details>

### `$n.dispose(): void`

**Returns:** `void`

**Calls:**

- `this._dispose`
- `this._cubemapMaterial.dispose`
- `this._equirectMaterial.dispose`

<details><summary>Code</summary>

```typescript
dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}
```
</details>

### `$n._setSize(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `Math.floor`
- `Math.log2`
- `Math.pow`

<details><summary>Code</summary>

```typescript
_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}
```
</details>

### `$n._dispose(): void`

**Returns:** `void`

**Calls:**

- `this._blurMaterial.dispose`
- `this._pingPongRenderTarget.dispose`
- `this._lodPlanes[e].dispose`

<details><summary>Code</summary>

```typescript
_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}
```
</details>

### `$n._cleanup(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `this._renderer.setRenderTarget`
- `Jn`

<details><summary>Code</summary>

```typescript
_cleanup(e){this._renderer.setRenderTarget(kn,Wn,Xn),this._renderer.xr.enabled=Yn,e.scissorTest=!1,Jn(e,0,0,e.width,e.height)}
```
</details>

### `$n._fromTexture(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `this._setSize`
- `this._renderer.getRenderTarget`
- `this._renderer.getActiveCubeFace`
- `this._renderer.getActiveMipmapLevel`
- `this._allocateTargets`
- `this._textureToCubeUV`
- `this._applyPMREM`
- `this._cleanup`

<details><summary>Code</summary>

```typescript
_fromTexture(e,t){e.mapping===C||e.mapping===L?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),kn=this._renderer.getRenderTarget(),Wn=this._renderer.getActiveCubeFace(),Xn=this._renderer.getActiveMipmapLevel(),Yn=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}
```
</details>

### `$n._allocateTargets(): zs`

**Returns:** `zs`

**Calls:**

- `Math.max`
- `Qn`
- `this._dispose`
- `complex_call_177076`
- `Math.pow`
- `n.push`
- `r.push`
- `g.set`
- `v.set`
- `E.set`
- `S.setAttribute`
- `t.push`
- `complex_call_177781`
- `nr`

<details><summary>Code</summary>

```typescript
_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:B,minFilter:B,generateMipmaps:!1,type:E,format:M,colorSpace:F,depthBuffer:!1},r=Qn(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Qn(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){const t=[],n=[],r=[];let i=e;const a=e-4+1+Hn.length;for(let o=0;o<a;o++){const a=Math.pow(2,i);n.push(a);let s=1/a;o>e-4?s=Hn[o-e+4-1]:0===o&&(s=0),r.push(s);const l=1/(a-2),c=-l,d=1+l,u=[c,c,d,c,d,d,c,c,d,d,c,d],f=6,p=6,m=3,h=2,_=1,g=new Float32Array(m*p*f),v=new Float32Array(h*p*f),E=new Float32Array(_*p*f);for(let e=0;e<f;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];g.set(r,m*p*e),v.set(u,h*p*e);const i=[e,e,e,e,e,e];E.set(i,_*p*e)}const S=new N;S.setAttribute("position",new O(g,m)),S.setAttribute("uv",new O(v,h)),S.setAttribute("faceIndex",new O(E,_)),t.push(S),i>4&&i--}return{lodPlanes:t,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(e,t,n){const r=new Float32Array(Gn),a=new i(0,1,0),o=new l({name:"SphericalGaussianBlur",defines:{n:Gn,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:a}},vertexShader:nr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1});return o}(r,e,t)}return r}
```
</details>

### `$n._compileMaterial(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `this._renderer.compile`

<details><summary>Code</summary>

```typescript
_compileMaterial(e){const t=new o(this._lodPlanes[0],e);this._renderer.compile(t,Vn)}
```
</details>

### `$n._sceneToCubeUV(e: any, t: any, n: any, r: any, i: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `void`

**Calls:**

- `u.getClearColor`
- `u.state.buffers.depth.getReversed`
- `u.setRenderTarget`
- `u.clearDepth`
- `m.color.copy`
- `a.up.set`
- `a.position.set`
- `a.lookAt`
- `Jn`
- `u.render`
- `h.geometry.dispose`
- `h.material.dispose`

<details><summary>Code</summary>

```typescript
_sceneToCubeUV(e,t,n,r,i){const a=new U(90,1,t,n),l=[1,-1,1,1,1,1],d=[1,1,1,-1,-1,-1],u=this._renderer,f=u.autoClear,p=u.toneMapping;u.getClearColor(zn),u.toneMapping=D,u.autoClear=!1;u.state.buffers.depth.getReversed()&&(u.setRenderTarget(r),u.clearDepth(),u.setRenderTarget(null));const m=new w({name:"PMREM.Background",side:c,depthWrite:!1,depthTest:!1}),h=new o(new s,m);let _=!1;const g=e.background;g?g.isColor&&(m.color.copy(g),e.background=null,_=!0):(m.color.copy(zn),_=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(a.up.set(0,l[t],0),a.position.set(i.x,i.y,i.z),a.lookAt(i.x+d[t],i.y,i.z)):1===n?(a.up.set(0,0,l[t]),a.position.set(i.x,i.y,i.z),a.lookAt(i.x,i.y+d[t],i.z)):(a.up.set(0,l[t],0),a.position.set(i.x,i.y,i.z),a.lookAt(i.x,i.y,i.z+d[t]));const o=this._cubeSize;Jn(r,n*o,t>2?o:0,o,o),u.setRenderTarget(r),_&&u.render(h,a),u.render(e,a)}h.geometry.dispose(),h.material.dispose(),u.toneMapping=p,u.autoClear=f,e.background=g}
```
</details>

### `$n._textureToCubeUV(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `tr`
- `er`
- `Jn`
- `n.setRenderTarget`
- `n.render`

<details><summary>Code</summary>

```typescript
_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===C||e.mapping===L;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=tr()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=er());const i=r?this._cubemapMaterial:this._equirectMaterial,a=new o(this._lodPlanes[0],i);i.uniforms.envMap.value=e;const s=this._cubeSize;Jn(t,0,0,3*s,2*s),n.setRenderTarget(t),n.render(a,Vn)}
```
</details>

### `$n._applyPMREM(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `Math.sqrt`
- `this._blur`

<details><summary>Code</summary>

```typescript
_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let t=1;t<r;t++){const n=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),i=jn[(r-t-1)%jn.length];this._blur(e,t-1,t,n,i)}t.autoClear=n}
```
</details>

### `$n._blur(e: any, t: any, n: any, r: any, i: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `void`

**Calls:**

- `this._halfBlur`

<details><summary>Code</summary>

```typescript
_blur(e,t,n,r,i){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,r,"latitudinal",i),this._halfBlur(a,e,n,n,r,"longitudinal",i)}
```
</details>

### `$n._halfBlur(e: any, t: any, n: any, r: any, i: any, a: any, s: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `console.error`
- `isFinite`
- `Math.floor`
- `console.warn`
- `Math.exp`
- `_.push`
- `Jn`
- `l.setRenderTarget`
- `l.render`

<details><summary>Code</summary>

```typescript
_halfBlur(e,t,n,r,i,a,s){const l=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const d=new o(this._lodPlanes[r],c),u=c.uniforms,f=this._sizeLods[n]-1,p=isFinite(i)?Math.PI/(2*f):2*Math.PI/39,m=i/p,h=isFinite(i)?1+Math.floor(3*m):Gn;h>Gn&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${h} samples when the maximum is set to 20`);const _=[];let g=0;for(let e=0;e<Gn;++e){const t=e/m,n=Math.exp(-t*t/2);_.push(n),0===e?g+=n:e<h&&(g+=2*n)}for(let e=0;e<_.length;e++)_[e]=_[e]/g;u.envMap.value=e.texture,u.samples.value=h,u.weights.value=_,u.latitudinal.value="latitudinal"===a,s&&(u.poleAxis.value=s);const{_lodMax:v}=this;u.dTheta.value=p,u.mipInt.value=v-n;const E=this._sizeLods[r];Jn(t,3*E*(r>v-4?r-v+4:0),4*(this._cubeSize-E),3*E,2*E),l.setRenderTarget(t),l.render(d,Vn)}
```
</details>

### `Qn(e: any, t: any, n: any): zs`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `zs`

<details><summary>Code</summary>

```typescript
function Qn(e,t,n){const r=new I(e,t,n);return r.texture.mapping=a,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}
```
</details>

### `Jn(e: any, t: any, n: any, r: any, i: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `void`

**Calls:**

- `e.viewport.set`
- `e.scissor.set`

<details><summary>Code</summary>

```typescript
function Jn(e,t,n,r,i){e.viewport.set(t,n,r,i),e.scissor.set(t,n,r,i)}
```
</details>

### `er(): Xn`

**Returns:** `Xn`

**Calls:**

- `nr`

<details><summary>Code</summary>

```typescript
function er(){return new l({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:nr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1})}
```
</details>

### `tr(): Xn`

**Returns:** `Xn`

**Calls:**

- `nr`

<details><summary>Code</summary>

```typescript
function tr(){return new l({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:nr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1})}
```
</details>

### `nr(): string`

**Returns:** `string`

<details><summary>Code</summary>

```typescript
function nr(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}
```
</details>

### `rr(e: any): { get: (i: any) => any; dispose: () => void; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ get: (i: any) => any; dispose: () => void; }`

**Calls:**

- `n.removeEventListener`
- `t.get`
- `t.delete`
- `i.dispose`
- `n.fromEquirectangular`
- `n.fromCubemap`
- `t.set`
- `complex_call_185604`
- `i.addEventListener`
- `n.dispose`

<details><summary>Code</summary>

```typescript
function rr(e){let t=new WeakMap,n=null;function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}return{get:function(i){if(i&&i.isTexture){const a=i.mapping,o=a===R||a===A,s=a===C||a===L;if(o||s){let a=t.get(i);const l=void 0!==a?a.texture.pmremVersion:0;if(i.isRenderTargetTexture&&i.pmremVersion!==l)return null===n&&(n=new $n(e)),a=o?n.fromEquirectangular(i,a):n.fromCubemap(i,a),a.texture.pmremVersion=i.pmremVersion,t.set(i,a),a.texture;if(void 0!==a)return a.texture;{const l=i.image;return o&&l&&l.height>0||s&&l&&function(e){let t=0;const n=6;for(let r=0;r<n;r++)void 0!==e[r]&&t++;return t===n}(l)?(null===n&&(n=new $n(e)),a=o?n.fromEquirectangular(i):n.fromCubemap(i),a.texture.pmremVersion=i.pmremVersion,t.set(i,a),i.addEventListener("dispose",r),a.texture):null}}}return i},dispose:function(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}}}
```
</details>

### `r(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `n.removeEventListener`
- `t.get`
- `t.delete`
- `i.dispose`

<details><summary>Code</summary>

```typescript
function r(e){const n=e.target;n.removeEventListener("dispose",r);const i=t.get(n);void 0!==i&&(t.delete(n),i.dispose())}
```
</details>

### `get(i: any): any`

**Parameters:**

- **`i`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `n.fromEquirectangular`
- `n.fromCubemap`
- `t.set`
- `complex_call_185604`
- `i.addEventListener`

<details><summary>Code</summary>

```typescript
function(i){if(i&&i.isTexture){const a=i.mapping,o=a===R||a===A,s=a===C||a===L;if(o||s){let a=t.get(i);const l=void 0!==a?a.texture.pmremVersion:0;if(i.isRenderTargetTexture&&i.pmremVersion!==l)return null===n&&(n=new $n(e)),a=o?n.fromEquirectangular(i,a):n.fromCubemap(i,a),a.texture.pmremVersion=i.pmremVersion,t.set(i,a),a.texture;if(void 0!==a)return a.texture;{const l=i.image;return o&&l&&l.height>0||s&&l&&function(e){let t=0;const n=6;for(let r=0;r<n;r++)void 0!==e[r]&&t++;return t===n}(l)?(null===n&&(n=new $n(e)),a=o?n.fromEquirectangular(i):n.fromCubemap(i),a.texture.pmremVersion=i.pmremVersion,t.set(i,a),i.addEventListener("dispose",r),a.texture):null}}}return i}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `n.dispose`

<details><summary>Code</summary>

```typescript
function(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}
```
</details>

### `get(i: any): any`

**Parameters:**

- **`i`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `n.fromEquirectangular`
- `n.fromCubemap`
- `t.set`
- `complex_call_185604`
- `i.addEventListener`

<details><summary>Code</summary>

```typescript
function(i){if(i&&i.isTexture){const a=i.mapping,o=a===R||a===A,s=a===C||a===L;if(o||s){let a=t.get(i);const l=void 0!==a?a.texture.pmremVersion:0;if(i.isRenderTargetTexture&&i.pmremVersion!==l)return null===n&&(n=new $n(e)),a=o?n.fromEquirectangular(i,a):n.fromCubemap(i,a),a.texture.pmremVersion=i.pmremVersion,t.set(i,a),a.texture;if(void 0!==a)return a.texture;{const l=i.image;return o&&l&&l.height>0||s&&l&&function(e){let t=0;const n=6;for(let r=0;r<n;r++)void 0!==e[r]&&t++;return t===n}(l)?(null===n&&(n=new $n(e)),a=o?n.fromEquirectangular(i):n.fromCubemap(i),a.texture.pmremVersion=i.pmremVersion,t.set(i,a),i.addEventListener("dispose",r),a.texture):null}}}return i}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `n.dispose`

<details><summary>Code</summary>

```typescript
function(){t=new WeakMap,null!==n&&(n.dispose(),n=null)}
```
</details>

### `ir(e: any): { has: (e: any) => boolean; init: () => void; get: (e: any) => any; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ has: (e: any) => boolean; init: () => void; get: (e: any) => any; }`

**Calls:**

- `e.getExtension`
- `n`
- `H (from ./three.core.min.js)`

<details><summary>Code</summary>

```typescript
function ir(e){const t={};function n(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r}return{has:function(e){return null!==n(e)},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(e){const t=n(e);return null===t&&H("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}
```
</details>

### `n(n: any): any`

**Parameters:**

- **`n`** `any`

**Returns:** `any`

**Calls:**

- `e.getExtension`

<details><summary>Code</summary>

```typescript
function n(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r}
```
</details>

### `has(e: any): boolean`

**Parameters:**

- **`e`** `any`

**Returns:** `boolean`

**Calls:**

- `n`

<details><summary>Code</summary>

```typescript
function(e){return null!==n(e)}
```
</details>

### `init(): void`

**Returns:** `void`

**Calls:**

- `n`

<details><summary>Code</summary>

```typescript
function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")}
```
</details>

### `get(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `n`
- `H (from ./three.core.min.js)`

<details><summary>Code</summary>

```typescript
function(e){const t=n(e);return null===t&&H("THREE.WebGLRenderer: "+e+" extension not supported."),t}
```
</details>

### `has(e: any): boolean`

**Parameters:**

- **`e`** `any`

**Returns:** `boolean`

**Calls:**

- `n`

<details><summary>Code</summary>

```typescript
function(e){return null!==n(e)}
```
</details>

### `init(): void`

**Returns:** `void`

**Calls:**

- `n`

<details><summary>Code</summary>

```typescript
function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")}
```
</details>

### `get(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `n`
- `H (from ./three.core.min.js)`

<details><summary>Code</summary>

```typescript
function(e){const t=n(e);return null===t&&H("THREE.WebGLRenderer: "+e+" extension not supported."),t}
```
</details>

### `ar(e: any, t: any, n: any, r: any): { get: (e: any, t: any) => any; update: (n: any) => void; getWireframeAttribute: (e: any) => any; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `{ get: (e: any, t: any) => any; update: (n: any) => void; getWireframeAttribute: (e: any) => any; }`

**Calls:**

- `t.remove`
- `s.removeEventListener`
- `a.get`
- `a.delete`
- `r.releaseStatesOfGeometry`
- `n.push`
- `z (from ./three.core.min.js)`
- `a.set`
- `t.addEventListener`
- `t.update`
- `s`

<details><summary>Code</summary>

```typescript
function ar(e,t,n,r){const i={},a=new WeakMap;function o(e){const s=e.target;null!==s.index&&t.remove(s.index);for(const e in s.attributes)t.remove(s.attributes[e]);s.removeEventListener("dispose",o),delete i[s.id];const l=a.get(s);l&&(t.remove(l),a.delete(s)),r.releaseStatesOfGeometry(s),!0===s.isInstancedBufferGeometry&&delete s._maxInstanceCount,n.memory.geometries--}function s(e){const n=[],r=e.index,i=e.attributes.position;let o=0;if(null!==r){const e=r.array;o=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],i=e[t+1],a=e[t+2];n.push(r,i,i,a,a,r)}}else{if(void 0===i)return;{const e=i.array;o=i.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,i=t+2;n.push(e,r,r,i,i,e)}}}const s=new(z(n)?G:V)(n,1);s.version=o;const l=a.get(e);l&&t.remove(l),a.set(e,s)}return{get:function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",o),i[t.id]=!0,n.memory.geometries++),t},update:function(n){const r=n.attributes;for(const n in r)t.update(r[n],e.ARRAY_BUFFER)},getWireframeAttribute:function(e){const t=a.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&s(e)}else s(e);return a.get(e)}}}
```
</details>

### `o(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.remove`
- `s.removeEventListener`
- `a.get`
- `a.delete`
- `r.releaseStatesOfGeometry`

<details><summary>Code</summary>

```typescript
function o(e){const s=e.target;null!==s.index&&t.remove(s.index);for(const e in s.attributes)t.remove(s.attributes[e]);s.removeEventListener("dispose",o),delete i[s.id];const l=a.get(s);l&&(t.remove(l),a.delete(s)),r.releaseStatesOfGeometry(s),!0===s.isInstancedBufferGeometry&&delete s._maxInstanceCount,n.memory.geometries--}
```
</details>

### `s(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `n.push`
- `z (from ./three.core.min.js)`
- `a.get`
- `t.remove`
- `a.set`

<details><summary>Code</summary>

```typescript
function s(e){const n=[],r=e.index,i=e.attributes.position;let o=0;if(null!==r){const e=r.array;o=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],i=e[t+1],a=e[t+2];n.push(r,i,i,a,a,r)}}else{if(void 0===i)return;{const e=i.array;o=i.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,i=t+2;n.push(e,r,r,i,i,e)}}}const s=new(z(n)?G:V)(n,1);s.version=o;const l=a.get(e);l&&t.remove(l),a.set(e,s)}
```
</details>

### `get(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `t.addEventListener`

<details><summary>Code</summary>

```typescript
function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",o),i[t.id]=!0,n.memory.geometries++),t}
```
</details>

### `update(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `t.update`

<details><summary>Code</summary>

```typescript
function(n){const r=n.attributes;for(const n in r)t.update(r[n],e.ARRAY_BUFFER)}
```
</details>

### `getWireframeAttribute(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `a.get`
- `s`

<details><summary>Code</summary>

```typescript
function(e){const t=a.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&s(e)}else s(e);return a.get(e)}
```
</details>

### `get(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `t.addEventListener`

<details><summary>Code</summary>

```typescript
function(e,t){return!0===i[t.id]||(t.addEventListener("dispose",o),i[t.id]=!0,n.memory.geometries++),t}
```
</details>

### `update(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `t.update`

<details><summary>Code</summary>

```typescript
function(n){const r=n.attributes;for(const n in r)t.update(r[n],e.ARRAY_BUFFER)}
```
</details>

### `getWireframeAttribute(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `a.get`
- `s`

<details><summary>Code</summary>

```typescript
function(e){const t=a.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&s(e)}else s(e);return a.get(e)}
```
</details>

### `or(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.drawElementsInstanced`
- `n.update`
- `e.drawElements`
- `t.get("WEBGL_multi_draw").multiDrawElementsWEBGL`
- `t.get`
- `o`
- `d.multiDrawElementsInstancedWEBGL`

<details><summary>Code</summary>

```typescript
function or(e,t,n){let r,i,a;function o(t,o,s){0!==s&&(e.drawElementsInstanced(r,o,i,t*a,s),n.update(o,r,s))}this.setMode=function(e){r=e},this.setIndex=function(e){i=e.type,a=e.bytesPerElement},this.render=function(t,o){e.drawElements(r,o,i,t*a),n.update(o,r,1)},this.renderInstances=o,this.renderMultiDraw=function(e,a,o){if(0===o)return;t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r,a,0,i,e,0,o);let s=0;for(let e=0;e<o;e++)s+=a[e];n.update(s,r,1)},this.renderMultiDrawInstances=function(e,s,l,c){if(0===l)return;const d=t.get("WEBGL_multi_draw");if(null===d)for(let t=0;t<e.length;t++)o(e[t]/a,s[t],c[t]);else{d.multiDrawElementsInstancedWEBGL(r,s,0,i,e,0,c,0,l);let t=0;for(let e=0;e<l;e++)t+=s[e]*c[e];n.update(t,r,1)}}}
```
</details>

### `o(t: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `e.drawElementsInstanced`
- `n.update`

<details><summary>Code</summary>

```typescript
function o(t,o,s){0!==s&&(e.drawElementsInstanced(r,o,i,t*a,s),n.update(o,r,s))}
```
</details>

### `sr(e: any): { memory: { geometries: number; textures: number; }; render: { frame: number; calls: number; triangles: number; points: number; lines: number; }; programs: any; autoReset: boolean; reset: () => void; update: (n: any, r: any, i: any) => void; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ memory: { geometries: number; textures: number; }; render: { frame: number; calls: number; triangles: number; points: number; lines: number; }; programs: any; autoReset: boolean; reset: () => void; update: (n: any, r: any, i: any) => void; }`

**Calls:**

- `console.error`

<details><summary>Code</summary>

```typescript
function sr(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(n,r,i){switch(t.calls++,r){case e.TRIANGLES:t.triangles+=i*(n/3);break;case e.LINES:t.lines+=i*(n/2);break;case e.LINE_STRIP:t.lines+=i*(n-1);break;case e.LINE_LOOP:t.lines+=i*n;break;case e.POINTS:t.points+=i*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}}}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}
```
</details>

### `update(n: any, r: any, i: any): void`

**Parameters:**

- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `void`

**Calls:**

- `console.error`

<details><summary>Code</summary>

```typescript
function(n,r,i){switch(t.calls++,r){case e.TRIANGLES:t.triangles+=i*(n/3);break;case e.LINES:t.lines+=i*(n/2);break;case e.LINE_STRIP:t.lines+=i*(n-1);break;case e.LINE_LOOP:t.lines+=i*n;break;case e.POINTS:t.points+=i*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}
```
</details>

### `update(n: any, r: any, i: any): void`

**Parameters:**

- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `void`

**Calls:**

- `console.error`

<details><summary>Code</summary>

```typescript
function(n,r,i){switch(t.calls++,r){case e.TRIANGLES:t.triangles+=i*(n/3);break;case e.LINES:t.lines+=i*(n/2);break;case e.LINE_STRIP:t.lines+=i*(n-1);break;case e.LINE_LOOP:t.lines+=i*n;break;case e.POINTS:t.points+=i*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}
```
</details>

### `lr(e: any, n: any, r: any): { update: (o: any, s: any, l: any) => void; }`

**Parameters:**

- **`e`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `{ update: (o: any, s: any, l: any) => void; }`

**Calls:**

- `i.get`
- `f.texture.dispose`
- `Math.ceil`
- `a.fromBufferAttribute`
- `R.dispose`
- `i.delete`
- `s.removeEventListener`
- `i.set`
- `s.addEventListener`
- `l.getUniforms().setValue`

<details><summary>Code</summary>

```typescript
function lr(e,n,r){const i=new WeakMap,a=new k;return{update:function(o,s,l){const c=o.morphTargetInfluences,d=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,u=void 0!==d?d.length:0;let f=i.get(s);if(void 0===f||f.count!==u){void 0!==f&&f.texture.dispose();const p=void 0!==s.morphAttributes.position,m=void 0!==s.morphAttributes.normal,h=void 0!==s.morphAttributes.color,_=s.morphAttributes.position||[],g=s.morphAttributes.normal||[],v=s.morphAttributes.color||[];let E=0;!0===p&&(E=1),!0===m&&(E=2),!0===h&&(E=3);let S=s.attributes.position.count*E,M=1;S>n.maxTextureSize&&(M=Math.ceil(S/n.maxTextureSize),S=n.maxTextureSize);const x=new Float32Array(S*M*4*u),R=new W(x,S,M,u);R.type=T,R.needsUpdate=!0;const A=4*E;for(let C=0;C<u;C++){const L=_[C],P=g[C],U=v[C],D=S*M*4*C;for(let w=0;w<L.count;w++){const y=w*A;!0===p&&(a.fromBufferAttribute(L,w),x[D+y+0]=a.x,x[D+y+1]=a.y,x[D+y+2]=a.z,x[D+y+3]=0),!0===m&&(a.fromBufferAttribute(P,w),x[D+y+4]=a.x,x[D+y+5]=a.y,x[D+y+6]=a.z,x[D+y+7]=0),!0===h&&(a.fromBufferAttribute(U,w),x[D+y+8]=a.x,x[D+y+9]=a.y,x[D+y+10]=a.z,x[D+y+11]=4===U.itemSize?a.w:1)}}function b(){R.dispose(),i.delete(s),s.removeEventListener("dispose",b)}f={count:u,texture:R,size:new t(S,M)},i.set(s,f),s.addEventListener("dispose",b)}if(!0===o.isInstancedMesh&&null!==o.morphTexture)l.getUniforms().setValue(e,"morphTexture",o.morphTexture,r);else{let I=0;for(let O=0;O<c.length;O++)I+=c[O];const N=s.morphTargetsRelative?1:1-I;l.getUniforms().setValue(e,"morphTargetBaseInfluence",N),l.getUniforms().setValue(e,"morphTargetInfluences",c)}l.getUniforms().setValue(e,"morphTargetsTexture",f.texture,r),l.getUniforms().setValue(e,"morphTargetsTextureSize",f.size)}}}
```
</details>

### `update(o: any, s: any, l: any): void`

**Parameters:**

- **`o`** `any`
- **`s`** `any`
- **`l`** `any`

**Returns:** `void`

**Calls:**

- `i.get`
- `f.texture.dispose`
- `Math.ceil`
- `a.fromBufferAttribute`
- `R.dispose`
- `i.delete`
- `s.removeEventListener`
- `i.set`
- `s.addEventListener`
- `l.getUniforms().setValue`

<details><summary>Code</summary>

```typescript
function(o,s,l){const c=o.morphTargetInfluences,d=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,u=void 0!==d?d.length:0;let f=i.get(s);if(void 0===f||f.count!==u){void 0!==f&&f.texture.dispose();const p=void 0!==s.morphAttributes.position,m=void 0!==s.morphAttributes.normal,h=void 0!==s.morphAttributes.color,_=s.morphAttributes.position||[],g=s.morphAttributes.normal||[],v=s.morphAttributes.color||[];let E=0;!0===p&&(E=1),!0===m&&(E=2),!0===h&&(E=3);let S=s.attributes.position.count*E,M=1;S>n.maxTextureSize&&(M=Math.ceil(S/n.maxTextureSize),S=n.maxTextureSize);const x=new Float32Array(S*M*4*u),R=new W(x,S,M,u);R.type=T,R.needsUpdate=!0;const A=4*E;for(let C=0;C<u;C++){const L=_[C],P=g[C],U=v[C],D=S*M*4*C;for(let w=0;w<L.count;w++){const y=w*A;!0===p&&(a.fromBufferAttribute(L,w),x[D+y+0]=a.x,x[D+y+1]=a.y,x[D+y+2]=a.z,x[D+y+3]=0),!0===m&&(a.fromBufferAttribute(P,w),x[D+y+4]=a.x,x[D+y+5]=a.y,x[D+y+6]=a.z,x[D+y+7]=0),!0===h&&(a.fromBufferAttribute(U,w),x[D+y+8]=a.x,x[D+y+9]=a.y,x[D+y+10]=a.z,x[D+y+11]=4===U.itemSize?a.w:1)}}function b(){R.dispose(),i.delete(s),s.removeEventListener("dispose",b)}f={count:u,texture:R,size:new t(S,M)},i.set(s,f),s.addEventListener("dispose",b)}if(!0===o.isInstancedMesh&&null!==o.morphTexture)l.getUniforms().setValue(e,"morphTexture",o.morphTexture,r);else{let I=0;for(let O=0;O<c.length;O++)I+=c[O];const N=s.morphTargetsRelative?1:1-I;l.getUniforms().setValue(e,"morphTargetBaseInfluence",N),l.getUniforms().setValue(e,"morphTargetInfluences",c)}l.getUniforms().setValue(e,"morphTargetsTexture",f.texture,r),l.getUniforms().setValue(e,"morphTargetsTextureSize",f.size)}
```
</details>

### `b(): void`

**Returns:** `void`

**Calls:**

- `R.dispose`
- `i.delete`
- `s.removeEventListener`

<details><summary>Code</summary>

```typescript
function b(){R.dispose(),i.delete(s),s.removeEventListener("dispose",b)}
```
</details>

### `update(o: any, s: any, l: any): void`

**Parameters:**

- **`o`** `any`
- **`s`** `any`
- **`l`** `any`

**Returns:** `void`

**Calls:**

- `i.get`
- `f.texture.dispose`
- `Math.ceil`
- `a.fromBufferAttribute`
- `R.dispose`
- `i.delete`
- `s.removeEventListener`
- `i.set`
- `s.addEventListener`
- `l.getUniforms().setValue`

<details><summary>Code</summary>

```typescript
function(o,s,l){const c=o.morphTargetInfluences,d=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,u=void 0!==d?d.length:0;let f=i.get(s);if(void 0===f||f.count!==u){void 0!==f&&f.texture.dispose();const p=void 0!==s.morphAttributes.position,m=void 0!==s.morphAttributes.normal,h=void 0!==s.morphAttributes.color,_=s.morphAttributes.position||[],g=s.morphAttributes.normal||[],v=s.morphAttributes.color||[];let E=0;!0===p&&(E=1),!0===m&&(E=2),!0===h&&(E=3);let S=s.attributes.position.count*E,M=1;S>n.maxTextureSize&&(M=Math.ceil(S/n.maxTextureSize),S=n.maxTextureSize);const x=new Float32Array(S*M*4*u),R=new W(x,S,M,u);R.type=T,R.needsUpdate=!0;const A=4*E;for(let C=0;C<u;C++){const L=_[C],P=g[C],U=v[C],D=S*M*4*C;for(let w=0;w<L.count;w++){const y=w*A;!0===p&&(a.fromBufferAttribute(L,w),x[D+y+0]=a.x,x[D+y+1]=a.y,x[D+y+2]=a.z,x[D+y+3]=0),!0===m&&(a.fromBufferAttribute(P,w),x[D+y+4]=a.x,x[D+y+5]=a.y,x[D+y+6]=a.z,x[D+y+7]=0),!0===h&&(a.fromBufferAttribute(U,w),x[D+y+8]=a.x,x[D+y+9]=a.y,x[D+y+10]=a.z,x[D+y+11]=4===U.itemSize?a.w:1)}}function b(){R.dispose(),i.delete(s),s.removeEventListener("dispose",b)}f={count:u,texture:R,size:new t(S,M)},i.set(s,f),s.addEventListener("dispose",b)}if(!0===o.isInstancedMesh&&null!==o.morphTexture)l.getUniforms().setValue(e,"morphTexture",o.morphTexture,r);else{let I=0;for(let O=0;O<c.length;O++)I+=c[O];const N=s.morphTargetsRelative?1:1-I;l.getUniforms().setValue(e,"morphTargetBaseInfluence",N),l.getUniforms().setValue(e,"morphTargetInfluences",c)}l.getUniforms().setValue(e,"morphTargetsTexture",f.texture,r),l.getUniforms().setValue(e,"morphTargetsTextureSize",f.size)}
```
</details>

### `cr(e: any, t: any, n: any, r: any): { update: (o: any) => any; dispose: () => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `{ update: (o: any) => any; dispose: () => void; }`

**Calls:**

- `t.removeEventListener`
- `n.remove`
- `t.get`
- `i.get`
- `t.update`
- `i.set`
- `o.hasEventListener`
- `o.addEventListener`
- `n.update`
- `e.update`

<details><summary>Code</summary>

```typescript
function cr(e,t,n,r){let i=new WeakMap;function a(e){const t=e.target;t.removeEventListener("dispose",a),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:function(o){const s=r.render.frame,l=o.geometry,c=t.get(o,l);if(i.get(c)!==s&&(t.update(c),i.set(c,s)),o.isInstancedMesh&&(!1===o.hasEventListener("dispose",a)&&o.addEventListener("dispose",a),i.get(o)!==s&&(n.update(o.instanceMatrix,e.ARRAY_BUFFER),null!==o.instanceColor&&n.update(o.instanceColor,e.ARRAY_BUFFER),i.set(o,s))),o.isSkinnedMesh){const e=o.skeleton;i.get(e)!==s&&(e.update(),i.set(e,s))}return c},dispose:function(){i=new WeakMap}}}
```
</details>

### `a(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.removeEventListener`
- `n.remove`

<details><summary>Code</summary>

```typescript
function a(e){const t=e.target;t.removeEventListener("dispose",a),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}
```
</details>

### `update(o: any): any`

**Parameters:**

- **`o`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `i.get`
- `t.update`
- `i.set`
- `o.hasEventListener`
- `o.addEventListener`
- `n.update`
- `e.update`

<details><summary>Code</summary>

```typescript
function(o){const s=r.render.frame,l=o.geometry,c=t.get(o,l);if(i.get(c)!==s&&(t.update(c),i.set(c,s)),o.isInstancedMesh&&(!1===o.hasEventListener("dispose",a)&&o.addEventListener("dispose",a),i.get(o)!==s&&(n.update(o.instanceMatrix,e.ARRAY_BUFFER),null!==o.instanceColor&&n.update(o.instanceColor,e.ARRAY_BUFFER),i.set(o,s))),o.isSkinnedMesh){const e=o.skeleton;i.get(e)!==s&&(e.update(),i.set(e,s))}return c}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){i=new WeakMap}
```
</details>

### `update(o: any): any`

**Parameters:**

- **`o`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `i.get`
- `t.update`
- `i.set`
- `o.hasEventListener`
- `o.addEventListener`
- `n.update`
- `e.update`

<details><summary>Code</summary>

```typescript
function(o){const s=r.render.frame,l=o.geometry,c=t.get(o,l);if(i.get(c)!==s&&(t.update(c),i.set(c,s)),o.isInstancedMesh&&(!1===o.hasEventListener("dispose",a)&&o.addEventListener("dispose",a),i.get(o)!==s&&(n.update(o.instanceMatrix,e.ARRAY_BUFFER),null!==o.instanceColor&&n.update(o.instanceColor,e.ARRAY_BUFFER),i.set(o,s))),o.isSkinnedMesh){const e=o.skeleton;i.get(e)!==s&&(e.update(),i.set(e,s))}return c}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){i=new WeakMap}
```
</details>

### `Sr(e: any, t: any, n: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `r.toArray`
- `e[r].toArray`

<details><summary>Code</summary>

```typescript
function Sr(e,t,n){const r=e[0];if(r<=0||r>0)return e;const i=t*n;let a=hr[i];if(void 0===a&&(a=new Float32Array(i),hr[i]=a),0!==t){r.toArray(a,0);for(let r=1,i=0;r!==t;++r)i+=n,e[r].toArray(a,i)}return a}
```
</details>

### `Tr(e: any, t: any): boolean`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `boolean`

<details><summary>Code</summary>

```typescript
function Tr(e,t){if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0}
```
</details>

### `Mr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function Mr(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}
```
</details>

### `xr(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.allocateTextureUnit`

<details><summary>Code</summary>

```typescript
function xr(e,t){let n=_r[t];void 0===n&&(n=new Int32Array(t),_r[t]=n);for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}
```
</details>

### `Rr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform1f`

<details><summary>Code</summary>

```typescript
function Rr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}
```
</details>

### `Ar(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform2f`
- `Tr`
- `e.uniform2fv`
- `Mr`

<details><summary>Code</summary>

```typescript
function Ar(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(Tr(n,t))return;e.uniform2fv(this.addr,t),Mr(n,t)}}
```
</details>

### `br(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform3f`
- `Tr`
- `e.uniform3fv`
- `Mr`

<details><summary>Code</summary>

```typescript
function br(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(Tr(n,t))return;e.uniform3fv(this.addr,t),Mr(n,t)}}
```
</details>

### `Cr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform4f`
- `Tr`
- `e.uniform4fv`
- `Mr`

<details><summary>Code</summary>

```typescript
function Cr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(Tr(n,t))return;e.uniform4fv(this.addr,t),Mr(n,t)}}
```
</details>

### `Lr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Tr`
- `e.uniformMatrix2fv`
- `Mr`
- `Er.set`

<details><summary>Code</summary>

```typescript
function Lr(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(Tr(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),Mr(n,t)}else{if(Tr(n,r))return;Er.set(r),e.uniformMatrix2fv(this.addr,!1,Er),Mr(n,r)}}
```
</details>

### `Pr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Tr`
- `e.uniformMatrix3fv`
- `Mr`
- `vr.set`

<details><summary>Code</summary>

```typescript
function Pr(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(Tr(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),Mr(n,t)}else{if(Tr(n,r))return;vr.set(r),e.uniformMatrix3fv(this.addr,!1,vr),Mr(n,r)}}
```
</details>

### `Ur(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Tr`
- `e.uniformMatrix4fv`
- `Mr`
- `gr.set`

<details><summary>Code</summary>

```typescript
function Ur(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(Tr(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),Mr(n,t)}else{if(Tr(n,r))return;gr.set(r),e.uniformMatrix4fv(this.addr,!1,gr),Mr(n,r)}}
```
</details>

### `Dr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform1i`

<details><summary>Code</summary>

```typescript
function Dr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}
```
</details>

### `wr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform2i`
- `Tr`
- `e.uniform2iv`
- `Mr`

<details><summary>Code</summary>

```typescript
function wr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2i(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(Tr(n,t))return;e.uniform2iv(this.addr,t),Mr(n,t)}}
```
</details>

### `yr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform3i`
- `Tr`
- `e.uniform3iv`
- `Mr`

<details><summary>Code</summary>

```typescript
function yr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3i(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else{if(Tr(n,t))return;e.uniform3iv(this.addr,t),Mr(n,t)}}
```
</details>

### `Ir(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform4i`
- `Tr`
- `e.uniform4iv`
- `Mr`

<details><summary>Code</summary>

```typescript
function Ir(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4i(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(Tr(n,t))return;e.uniform4iv(this.addr,t),Mr(n,t)}}
```
</details>

### `Nr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform1ui`

<details><summary>Code</summary>

```typescript
function Nr(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}
```
</details>

### `Or(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform2ui`
- `Tr`
- `e.uniform2uiv`
- `Mr`

<details><summary>Code</summary>

```typescript
function Or(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2ui(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(Tr(n,t))return;e.uniform2uiv(this.addr,t),Mr(n,t)}}
```
</details>

### `Fr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform3ui`
- `Tr`
- `e.uniform3uiv`
- `Mr`

<details><summary>Code</summary>

```typescript
function Fr(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3ui(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else{if(Tr(n,t))return;e.uniform3uiv(this.addr,t),Mr(n,t)}}
```
</details>

### `Br(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform4ui`
- `Tr`
- `e.uniform4uiv`
- `Mr`

<details><summary>Code</summary>

```typescript
function Br(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4ui(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(Tr(n,t))return;e.uniform4uiv(this.addr,t),Mr(n,t)}}
```
</details>

### `Hr(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `n.allocateTextureUnit`
- `e.uniform1i`
- `n.setTexture2D`

<details><summary>Code</summary>

```typescript
function Hr(e,t,n){const r=this.cache,i=n.allocateTextureUnit();let a;r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),this.type===e.SAMPLER_2D_SHADOW?(ur.compareFunction=K,a=ur):a=dr,n.setTexture2D(t||a,i)}
```
</details>

### `Gr(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `n.allocateTextureUnit`
- `e.uniform1i`
- `n.setTexture3D`

<details><summary>Code</summary>

```typescript
function Gr(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(t||pr,i)}
```
</details>

### `Vr(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `n.allocateTextureUnit`
- `e.uniform1i`
- `n.setTextureCube`

<details><summary>Code</summary>

```typescript
function Vr(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(t||mr,i)}
```
</details>

### `zr(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `n.allocateTextureUnit`
- `e.uniform1i`
- `n.setTexture2DArray`

<details><summary>Code</summary>

```typescript
function zr(e,t,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(e.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(t||fr,i)}
```
</details>

### `kr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform1fv`

<details><summary>Code</summary>

```typescript
function kr(e,t){e.uniform1fv(this.addr,t)}
```
</details>

### `Wr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Sr`
- `e.uniform2fv`

<details><summary>Code</summary>

```typescript
function Wr(e,t){const n=Sr(t,this.size,2);e.uniform2fv(this.addr,n)}
```
</details>

### `Xr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Sr`
- `e.uniform3fv`

<details><summary>Code</summary>

```typescript
function Xr(e,t){const n=Sr(t,this.size,3);e.uniform3fv(this.addr,n)}
```
</details>

### `Yr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Sr`
- `e.uniform4fv`

<details><summary>Code</summary>

```typescript
function Yr(e,t){const n=Sr(t,this.size,4);e.uniform4fv(this.addr,n)}
```
</details>

### `Kr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Sr`
- `e.uniformMatrix2fv`

<details><summary>Code</summary>

```typescript
function Kr(e,t){const n=Sr(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}
```
</details>

### `qr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Sr`
- `e.uniformMatrix3fv`

<details><summary>Code</summary>

```typescript
function qr(e,t){const n=Sr(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}
```
</details>

### `jr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `Sr`
- `e.uniformMatrix4fv`

<details><summary>Code</summary>

```typescript
function jr(e,t){const n=Sr(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}
```
</details>

### `Zr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform1iv`

<details><summary>Code</summary>

```typescript
function Zr(e,t){e.uniform1iv(this.addr,t)}
```
</details>

### `$r(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform2iv`

<details><summary>Code</summary>

```typescript
function $r(e,t){e.uniform2iv(this.addr,t)}
```
</details>

### `Qr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform3iv`

<details><summary>Code</summary>

```typescript
function Qr(e,t){e.uniform3iv(this.addr,t)}
```
</details>

### `Jr(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform4iv`

<details><summary>Code</summary>

```typescript
function Jr(e,t){e.uniform4iv(this.addr,t)}
```
</details>

### `ei(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform1uiv`

<details><summary>Code</summary>

```typescript
function ei(e,t){e.uniform1uiv(this.addr,t)}
```
</details>

### `ti(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform2uiv`

<details><summary>Code</summary>

```typescript
function ti(e,t){e.uniform2uiv(this.addr,t)}
```
</details>

### `ni(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform3uiv`

<details><summary>Code</summary>

```typescript
function ni(e,t){e.uniform3uiv(this.addr,t)}
```
</details>

### `ri(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.uniform4uiv`

<details><summary>Code</summary>

```typescript
function ri(e,t){e.uniform4uiv(this.addr,t)}
```
</details>

### `ii(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `xr`
- `Tr`
- `e.uniform1iv`
- `Mr`
- `n.setTexture2D`

<details><summary>Code</summary>

```typescript
function ii(e,t,n){const r=this.cache,i=t.length,a=xr(n,i);Tr(r,a)||(e.uniform1iv(this.addr,a),Mr(r,a));for(let e=0;e!==i;++e)n.setTexture2D(t[e]||dr,a[e])}
```
</details>

### `ai(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `xr`
- `Tr`
- `e.uniform1iv`
- `Mr`
- `n.setTexture3D`

<details><summary>Code</summary>

```typescript
function ai(e,t,n){const r=this.cache,i=t.length,a=xr(n,i);Tr(r,a)||(e.uniform1iv(this.addr,a),Mr(r,a));for(let e=0;e!==i;++e)n.setTexture3D(t[e]||pr,a[e])}
```
</details>

### `oi(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `xr`
- `Tr`
- `e.uniform1iv`
- `Mr`
- `n.setTextureCube`

<details><summary>Code</summary>

```typescript
function oi(e,t,n){const r=this.cache,i=t.length,a=xr(n,i);Tr(r,a)||(e.uniform1iv(this.addr,a),Mr(r,a));for(let e=0;e!==i;++e)n.setTextureCube(t[e]||mr,a[e])}
```
</details>

### `si(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `xr`
- `Tr`
- `e.uniform1iv`
- `Mr`
- `n.setTexture2DArray`

<details><summary>Code</summary>

```typescript
function si(e,t,n){const r=this.cache,i=t.length,a=xr(n,i);Tr(r,a)||(e.uniform1iv(this.addr,a),Mr(r,a));for(let e=0;e!==i;++e)n.setTexture2DArray(t[e]||fr,a[e])}
```
</details>

### `di.setValue(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `a.setValue`

<details><summary>Code</summary>

```typescript
setValue(e,t,n){const r=this.seq;for(let i=0,a=r.length;i!==a;++i){const a=r[i];a.setValue(e,t[a.id],n)}}
```
</details>

### `fi(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.seq.push`

<details><summary>Code</summary>

```typescript
function fi(e,t){e.seq.push(t),e.map[t.id]=t}
```
</details>

### `pi(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `ui.exec`
- `fi`

<details><summary>Code</summary>

```typescript
function pi(e,t,n){const r=e.name,i=r.length;for(ui.lastIndex=0;;){const a=ui.exec(r),o=ui.lastIndex;let s=a[1];const l="]"===a[2],c=a[3];if(l&&(s|=0),void 0===c||"["===c&&o+2===i){fi(n,void 0===c?new li(s,e,t):new ci(s,e,t));break}{let e=n.map[s];void 0===e&&(e=new di(s),fi(n,e)),n=e}}}
```
</details>

### `mi.setValue(e: any, t: any, n: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `i.setValue`

<details><summary>Code</summary>

```typescript
setValue(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)}
```
</details>

### `mi.setOptional(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `this.setValue`

<details><summary>Code</summary>

```typescript
setOptional(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)}
```
</details>

### `mi.upload(e: any, t: any, n: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `a.setValue`

<details><summary>Code</summary>

```typescript
static upload(e,t,n,r){for(let i=0,a=t.length;i!==a;++i){const a=t[i],o=n[a.id];!1!==o.needsUpdate&&a.setValue(e,o.value,r)}}
```
</details>

### `mi.seqWithValue(e: any, t: any): any[]`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any[]`

**Calls:**

- `n.push`

<details><summary>Code</summary>

```typescript
static seqWithValue(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n}
```
</details>

### `hi(e: any, t: any, n: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `e.createShader`
- `e.shaderSource`
- `e.compileShader`

<details><summary>Code</summary>

```typescript
function hi(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}
```
</details>

### `vi(e: any, t: any, n: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `e.getShaderParameter`
- `(e.getShaderInfoLog(t)||"").trim`
- `e.getShaderInfoLog`
- `/ERROR: 0:(\d+)/.exec`
- `parseInt`
- `n.toUpperCase`
- `complex_call_200310`
- `e.split`
- `Math.max`
- `Math.min`
- `r.push`
- `r.join`
- `e.getShaderSource`

<details><summary>Code</summary>

```typescript
function vi(e,t,n){const r=e.getShaderParameter(t,e.COMPILE_STATUS),i=(e.getShaderInfoLog(t)||"").trim();if(r&&""===i)return"";const a=/ERROR: 0:(\d+)/.exec(i);if(a){const r=parseInt(a[1]);return n.toUpperCase()+"\n\n"+i+"\n\n"+function(e,t){const n=e.split("\n"),r=[],i=Math.max(t-6,0),a=Math.min(t+6,n.length);for(let e=i;e<a;e++){const i=e+1;r.push(`${i===t?">":" "} ${i}: ${n[e]}`)}return r.join("\n")}(e.getShaderSource(t),r)}return i}
```
</details>

### `Ei(e: any, t: any): string`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `string`

**Calls:**

- `complex_call_200547`
- `p._getMatrix`
- `gi.elements.map`
- `e.toFixed`
- `p.getTransfer`
- `console.warn`
- `[`vec4 ${e}( vec4 value ) {`,`\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join`

<details><summary>Code</summary>

```typescript
function Ei(e,t){const n=function(e){p._getMatrix(gi,p.workingColorSpace,e);const t=`mat3( ${gi.elements.map(e=>e.toFixed(4))} )`;switch(p.getTransfer(e)){case se:return[t,"LinearTransferOETF"];case m:return[t,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",e),[t,"LinearTransferOETF"]}}(t);return[`vec4 ${e}( vec4 value ) {`,`\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,"}"].join("\n")}
```
</details>

### `Si(e: any, t: any): string`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `string`

**Calls:**

- `console.warn`

<details><summary>Code</summary>

```typescript
function Si(e,t){let n;switch(t){case oe:n="Linear";break;case ae:n="Reinhard";break;case ie:n="Cineon";break;case re:n="ACESFilmic";break;case ne:n="AgX";break;case te:n="Neutral";break;case ee:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}
```
</details>

### `Mi(): string`

**Returns:** `string`

**Calls:**

- `p.getLuminanceCoefficients`
- `["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${Ti.x.toFixed(4)}, ${Ti.y.toFixed(4)}, ${Ti.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join`
- `Ti.x.toFixed`
- `Ti.y.toFixed`
- `Ti.z.toFixed`

<details><summary>Code</summary>

```typescript
function Mi(){p.getLuminanceCoefficients(Ti);return["float luminance( const in vec3 rgb ) {",`\tconst vec3 weights = vec3( ${Ti.x.toFixed(4)}, ${Ti.y.toFixed(4)}, ${Ti.z.toFixed(4)} );`,"\treturn dot( weights, rgb );","}"].join("\n")}
```
</details>

### `xi(e: any): boolean`

**Parameters:**

- **`e`** `any`

**Returns:** `boolean`

<details><summary>Code</summary>

```typescript
function xi(e){return""!==e}
```
</details>

### `Ri(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace`

<details><summary>Code</summary>

```typescript
function Ri(e,t){const n=t.numSpotLightShadows+t.numSpotLightMaps-t.numSpotLightShadowsWithMaps;return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}
```
</details>

### `Ai(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace`

<details><summary>Code</summary>

```typescript
function Ai(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}
```
</details>

### `Ci(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `e.replace`

<details><summary>Code</summary>

```typescript
function Ci(e){return e.replace(bi,Pi)}
```
</details>

### `Pi(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `Li.get`
- `console.warn`
- `Ci`

<details><summary>Code</summary>

```typescript
function Pi(e,t){let n=Cn[t];if(void 0===n){const e=Li.get(t);if(void 0===e)throw new Error("Can not resolve #include <"+t+">");n=Cn[e],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',t,e)}return Ci(n)}
```
</details>

### `Di(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `e.replace`

<details><summary>Code</summary>

```typescript
function Di(e){return e.replace(Ui,wi)}
```
</details>

### `wi(e: any, t: any, n: any, r: any): string`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `string`

**Calls:**

- `parseInt`
- `r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace`

<details><summary>Code</summary>

```typescript
function wi(e,t,n,r){let i="";for(let e=parseInt(t);e<parseInt(n);e++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return i}
```
</details>

### `yi(e: any): string`

**Parameters:**

- **`e`** `any`

**Returns:** `string`

<details><summary>Code</summary>

```typescript
function yi(e){let t=`precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}
```
</details>

### `Ii(e: any, t: any, n: any, r: any): this`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `this`

**Calls:**

- `e.getContext`
- `complex_call_204131`
- `complex_call_204324`
- `complex_call_204481`
- `complex_call_204596`
- `complex_call_204795`
- `Math.log2`
- `Math.max`
- `Math.pow`
- `complex_call_204971`
- `[e.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",e.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(xi).join`
- `complex_call_205168`
- `t.push`
- `t.join`
- `i.createProgram`
- `["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h].filter(xi).join`
- `[yi(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reversedDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(xi).join`
- `[yi(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.envMap?"#define "+u:"",n.envMap?"#define "+f:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reversedDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==D?"#define TONE_MAPPING":"",n.toneMapping!==D?Cn.tonemapping_pars_fragment:"",n.toneMapping!==D?Si("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Cn.colorspace_pars_fragment,Ei("linearToOutputTexel",n.outputColorSpace),Mi(),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(xi).join`
- `Ci`
- `Ri`
- `Ai`
- `Di`
- `[m,"#define attribute in","#define varying out","#define texture2D texture"].join`
- `["#define varying in",n.glslVersion===Z?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===Z?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join`
- `hi`
- `i.getProgramInfoLog`
- `i.getShaderInfoLog`
- `n.trim`
- `r.trim`
- `a.trim`
- `i.getProgramParameter`
- `e.debug.onShaderError`
- `vi`
- `console.error`
- `i.getError`
- `console.warn`
- `i.deleteShader`
- `complex_call_216016`
- `e.getProgramParameter`
- `e.getActiveAttrib`
- `e.getAttribLocation`
- `i.attachShader`
- `i.bindAttribLocation`
- `i.linkProgram`
- `R`
- `r.releaseStatesOfProgram`
- `i.deleteProgram`

<details><summary>Code</summary>

```typescript
function Ii(e,t,n,r){const i=e.getContext(),o=n.defines;let s=n.vertexShader,l=n.fragmentShader;const c=function(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===$?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===Q?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===J&&(t="SHADOWMAP_TYPE_VSM"),t}(n),d=function(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case C:case L:t="ENVMAP_TYPE_CUBE";break;case a:t="ENVMAP_TYPE_CUBE_UV"}return t}(n),u=function(e){let t="ENVMAP_MODE_REFLECTION";e.envMap&&e.envMapMode===L&&(t="ENVMAP_MODE_REFRACTION");return t}(n),f=function(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case de:t="ENVMAP_BLENDING_MULTIPLY";break;case ce:t="ENVMAP_BLENDING_MIX";break;case le:t="ENVMAP_BLENDING_ADD"}return t}(n),p=function(e){const t=e.envMapCubeUVHeight;if(null===t)return null;const n=Math.log2(t)-2,r=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,n),112)),texelHeight:r,maxMip:n}}(n),m=function(e){return[e.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",e.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(xi).join("\n")}(n),h=function(e){const t=[];for(const n in e){const r=e[n];!1!==r&&t.push("#define "+n+" "+r)}return t.join("\n")}(o),_=i.createProgram();let g,v,E=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(g=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h].filter(xi).join("\n"),g.length>0&&(g+="\n"),v=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h].filter(xi).join("\n"),v.length>0&&(v+="\n")):(g=[yi(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.batchingColor?"#define USE_BATCHING_COLOR":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reversedDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","\tuniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","\tattribute vec2 uv1;","#endif","#ifdef USE_UV2","\tattribute vec2 uv2;","#endif","#ifdef USE_UV3","\tattribute vec2 uv3;","#endif","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(xi).join("\n"),v=[yi(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,h,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+d:"",n.envMap?"#define "+u:"",n.envMap?"#define "+f:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.dispersion?"#define USE_DISPERSION":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&!1===n.flatShading?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor||n.batchingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+c:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.reversedDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==D?"#define TONE_MAPPING":"",n.toneMapping!==D?Cn.tonemapping_pars_fragment:"",n.toneMapping!==D?Si("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Cn.colorspace_pars_fragment,Ei("linearToOutputTexel",n.outputColorSpace),Mi(),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(xi).join("\n")),s=Ci(s),s=Ri(s,n),s=Ai(s,n),l=Ci(l),l=Ri(l,n),l=Ai(l,n),s=Di(s),l=Di(l),!0!==n.isRawShaderMaterial&&(E="#version 300 es\n",g=[m,"#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+g,v=["#define varying in",n.glslVersion===Z?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===Z?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+v);const S=E+g+s,T=E+v+l,M=hi(i,i.VERTEX_SHADER,S),x=hi(i,i.FRAGMENT_SHADER,T);function R(t){if(e.debug.checkShaderErrors){const n=i.getProgramInfoLog(_)||"",r=i.getShaderInfoLog(M)||"",a=i.getShaderInfoLog(x)||"",o=n.trim(),s=r.trim(),l=a.trim();let c=!0,d=!0;if(!1===i.getProgramParameter(_,i.LINK_STATUS))if(c=!1,"function"==typeof e.debug.onShaderError)e.debug.onShaderError(i,_,M,x);else{const e=vi(i,M,"vertex"),n=vi(i,x,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(_,i.VALIDATE_STATUS)+"\n\nMaterial Name: "+t.name+"\nMaterial Type: "+t.type+"\n\nProgram Info Log: "+o+"\n"+e+"\n"+n)}else""!==o?console.warn("THREE.WebGLProgram: Program Info Log:",o):""!==s&&""!==l||(d=!1);d&&(t.diagnostics={runnable:c,programLog:o,vertexShader:{log:s,prefix:g},fragmentShader:{log:l,prefix:v}})}i.deleteShader(M),i.deleteShader(x),A=new mi(i,_),b=function(e,t){const n={},r=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const r=e.getActiveAttrib(t,i),a=r.name;let o=1;r.type===e.FLOAT_MAT2&&(o=2),r.type===e.FLOAT_MAT3&&(o=3),r.type===e.FLOAT_MAT4&&(o=4),n[a]={type:r.type,location:e.getAttribLocation(t,a),locationSize:o}}return n}(i,_)}let A,b;i.attachShader(_,M),i.attachShader(_,x),void 0!==n.index0AttributeName?i.bindAttribLocation(_,0,n.index0AttributeName):!0===n.morphTargets&&i.bindAttribLocation(_,0,"position"),i.linkProgram(_),this.getUniforms=function(){return void 0===A&&R(this),A},this.getAttributes=function(){return void 0===b&&R(this),b};let P=!1===n.rendererExtensionParallelShaderCompile;return this.isReady=function(){return!1===P&&(P=i.getProgramParameter(_,37297)),P},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(_),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=_i++,this.cacheKey=t,this.usedTimes=1,this.program=_,this.vertexShader=M,this.fragmentShader=x,this}
```
</details>

### `R(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `i.getProgramInfoLog`
- `i.getShaderInfoLog`
- `n.trim`
- `r.trim`
- `a.trim`
- `i.getProgramParameter`
- `e.debug.onShaderError`
- `vi`
- `console.error`
- `i.getError`
- `console.warn`
- `i.deleteShader`
- `complex_call_216016`
- `e.getProgramParameter`
- `e.getActiveAttrib`
- `e.getAttribLocation`

<details><summary>Code</summary>

```typescript
function R(t){if(e.debug.checkShaderErrors){const n=i.getProgramInfoLog(_)||"",r=i.getShaderInfoLog(M)||"",a=i.getShaderInfoLog(x)||"",o=n.trim(),s=r.trim(),l=a.trim();let c=!0,d=!0;if(!1===i.getProgramParameter(_,i.LINK_STATUS))if(c=!1,"function"==typeof e.debug.onShaderError)e.debug.onShaderError(i,_,M,x);else{const e=vi(i,M,"vertex"),n=vi(i,x,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(_,i.VALIDATE_STATUS)+"\n\nMaterial Name: "+t.name+"\nMaterial Type: "+t.type+"\n\nProgram Info Log: "+o+"\n"+e+"\n"+n)}else""!==o?console.warn("THREE.WebGLProgram: Program Info Log:",o):""!==s&&""!==l||(d=!1);d&&(t.diagnostics={runnable:c,programLog:o,vertexShader:{log:s,prefix:g},fragmentShader:{log:l,prefix:v}})}i.deleteShader(M),i.deleteShader(x),A=new mi(i,_),b=function(e,t){const n={},r=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const r=e.getActiveAttrib(t,i),a=r.name;let o=1;r.type===e.FLOAT_MAT2&&(o=2),r.type===e.FLOAT_MAT3&&(o=3),r.type===e.FLOAT_MAT4&&(o=4),n[a]={type:r.type,location:e.getAttribLocation(t,a),locationSize:o}}return n}(i,_)}
```
</details>

### `Oi.update(e: any): this`

**Parameters:**

- **`e`** `any`

**Returns:** `this`

**Calls:**

- `this._getShaderStage`
- `this._getShaderCacheForMaterial`
- `a.has`
- `a.add`

<details><summary>Code</summary>

```typescript
update(e){const t=e.vertexShader,n=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return!1===a.has(r)&&(a.add(r),r.usedTimes++),!1===a.has(i)&&(a.add(i),i.usedTimes++),this}
```
</details>

### `Oi.remove(e: any): this`

**Parameters:**

- **`e`** `any`

**Returns:** `this`

**Calls:**

- `this.materialCache.get`
- `this.shaderCache.delete`
- `this.materialCache.delete`

<details><summary>Code</summary>

```typescript
remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}
```
</details>

### `Oi.getVertexShaderID(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `this._getShaderStage`

<details><summary>Code</summary>

```typescript
getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}
```
</details>

### `Oi.getFragmentShaderID(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `this._getShaderStage`

<details><summary>Code</summary>

```typescript
getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}
```
</details>

### `Oi.dispose(): void`

**Returns:** `void`

**Calls:**

- `this.shaderCache.clear`
- `this.materialCache.clear`

<details><summary>Code</summary>

```typescript
dispose(){this.shaderCache.clear(),this.materialCache.clear()}
```
</details>

### `Oi._getShaderCacheForMaterial(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `t.set`

<details><summary>Code</summary>

```typescript
_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return void 0===n&&(n=new Set,t.set(e,n)),n}
```
</details>

### `Oi._getShaderStage(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `t.get`
- `t.set`

<details><summary>Code</summary>

```typescript
_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return void 0===n&&(n=new Fi(e),t.set(e,n)),n}
```
</details>

### `Bi(e: any, t: any, n: any, r: any, i: any, o: any, s: any): { getParameters: (o: any, l: any, f: any, S: any, T: any) => { shaderID: any; shaderType: any; shaderName: any; vertexShader: any; fragmentShader: any; defines: any; customVertexShaderID: any; ... 120 more ...; customProgramCacheKey: any; }; ... 6 more ...; dispose: () => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `{ getParameters: (o: any, l: any, f: any, S: any, T: any) => { shaderID: any; shaderType: any; shaderName: any; vertexShader: any; fragmentShader: any; defines: any; customVertexShaderID: any; ... 120 more ...; customProgramCacheKey: any; }; ... 6 more ...; dispose: () => void; }`

**Calls:**

- `u.add`
- `(o.isMeshStandardMaterial?n:t).get`
- `i.getMaxPrecision`
- `console.warn`
- `d.update`
- `d.getVertexShaderID`
- `d.getFragmentShaderID`
- `e.getRenderTarget`
- `e.state.buffers.depth.getReversed`
- `E`
- `p.getTransfer`
- `r.has`
- `o.customProgramCacheKey`
- `u.has`
- `u.clear`
- `n.push`
- `complex_call_224897`
- `e.push`
- `complex_call_226159`
- `l.disableAll`
- `l.enable`
- `n.join`
- `ue.clone`
- `f.push`
- `f.indexOf`
- `f.pop`
- `e.destroy`
- `d.remove`
- `d.dispose`

<details><summary>Code</summary>

```typescript
function Bi(e,t,n,r,i,o,s){const l=new _e,d=new Oi,u=new Set,f=[],h=i.logarithmicDepthBuffer,_=i.vertexTextures;let g=i.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function E(e){return u.add(e),0===e?"uv":`uv${e}`}return{getParameters:function(o,l,f,S,T){const M=S.fog,x=T.geometry,R=o.isMeshStandardMaterial?S.environment:null,A=(o.isMeshStandardMaterial?n:t).get(o.envMap||R),b=A&&A.mapping===a?A.image.height:null,C=v[o.type];null!==o.precision&&(g=i.getMaxPrecision(o.precision),g!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",g,"instead."));const L=x.morphAttributes.position||x.morphAttributes.normal||x.morphAttributes.color,P=void 0!==L?L.length:0;let U,w,y,I,N=0;if(void 0!==x.morphAttributes.position&&(N=1),void 0!==x.morphAttributes.normal&&(N=2),void 0!==x.morphAttributes.color&&(N=3),C){const e=Pn[C];U=e.vertexShader,w=e.fragmentShader}else U=o.vertexShader,w=o.fragmentShader,d.update(o),y=d.getVertexShaderID(o),I=d.getFragmentShaderID(o);const O=e.getRenderTarget(),B=e.state.buffers.depth.getReversed(),H=!0===T.isInstancedMesh,G=!0===T.isBatchedMesh,V=!!o.map,z=!!o.matcap,k=!!A,W=!!o.aoMap,X=!!o.lightMap,Y=!!o.bumpMap,K=!!o.normalMap,q=!!o.displacementMap,j=!!o.emissiveMap,Z=!!o.metalnessMap,$=!!o.roughnessMap,Q=o.anisotropy>0,J=o.clearcoat>0,ee=o.dispersion>0,te=o.iridescence>0,ne=o.sheen>0,re=o.transmission>0,ie=Q&&!!o.anisotropyMap,ae=J&&!!o.clearcoatMap,oe=J&&!!o.clearcoatNormalMap,se=J&&!!o.clearcoatRoughnessMap,le=te&&!!o.iridescenceMap,ce=te&&!!o.iridescenceThicknessMap,de=ne&&!!o.sheenColorMap,ue=ne&&!!o.sheenRoughnessMap,_e=!!o.specularMap,ge=!!o.specularColorMap,ve=!!o.specularIntensityMap,Ee=re&&!!o.transmissionMap,Se=re&&!!o.thicknessMap,Te=!!o.gradientMap,Me=!!o.alphaMap,xe=o.alphaTest>0,Re=!!o.alphaHash,Ae=!!o.extensions;let be=D;o.toneMapped&&(null!==O&&!0!==O.isXRRenderTarget||(be=e.toneMapping));const Ce={shaderID:C,shaderType:o.type,shaderName:o.name,vertexShader:U,fragmentShader:w,defines:o.defines,customVertexShaderID:y,customFragmentShaderID:I,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:g,batching:G,batchingColor:G&&null!==T._colorsTexture,instancing:H,instancingColor:H&&null!==T.instanceColor,instancingMorph:H&&null!==T.morphTexture,supportsVertexTextures:_,outputColorSpace:null===O?e.outputColorSpace:!0===O.isXRRenderTarget?O.texture.colorSpace:F,alphaToCoverage:!!o.alphaToCoverage,map:V,matcap:z,envMap:k,envMapMode:k&&A.mapping,envMapCubeUVHeight:b,aoMap:W,lightMap:X,bumpMap:Y,normalMap:K,displacementMap:_&&q,emissiveMap:j,normalMapObjectSpace:K&&o.normalMapType===he,normalMapTangentSpace:K&&o.normalMapType===me,metalnessMap:Z,roughnessMap:$,anisotropy:Q,anisotropyMap:ie,clearcoat:J,clearcoatMap:ae,clearcoatNormalMap:oe,clearcoatRoughnessMap:se,dispersion:ee,iridescence:te,iridescenceMap:le,iridescenceThicknessMap:ce,sheen:ne,sheenColorMap:de,sheenRoughnessMap:ue,specularMap:_e,specularColorMap:ge,specularIntensityMap:ve,transmission:re,transmissionMap:Ee,thicknessMap:Se,gradientMap:Te,opaque:!1===o.transparent&&o.blending===pe&&!1===o.alphaToCoverage,alphaMap:Me,alphaTest:xe,alphaHash:Re,combine:o.combine,mapUv:V&&E(o.map.channel),aoMapUv:W&&E(o.aoMap.channel),lightMapUv:X&&E(o.lightMap.channel),bumpMapUv:Y&&E(o.bumpMap.channel),normalMapUv:K&&E(o.normalMap.channel),displacementMapUv:q&&E(o.displacementMap.channel),emissiveMapUv:j&&E(o.emissiveMap.channel),metalnessMapUv:Z&&E(o.metalnessMap.channel),roughnessMapUv:$&&E(o.roughnessMap.channel),anisotropyMapUv:ie&&E(o.anisotropyMap.channel),clearcoatMapUv:ae&&E(o.clearcoatMap.channel),clearcoatNormalMapUv:oe&&E(o.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:se&&E(o.clearcoatRoughnessMap.channel),iridescenceMapUv:le&&E(o.iridescenceMap.channel),iridescenceThicknessMapUv:ce&&E(o.iridescenceThicknessMap.channel),sheenColorMapUv:de&&E(o.sheenColorMap.channel),sheenRoughnessMapUv:ue&&E(o.sheenRoughnessMap.channel),specularMapUv:_e&&E(o.specularMap.channel),specularColorMapUv:ge&&E(o.specularColorMap.channel),specularIntensityMapUv:ve&&E(o.specularIntensityMap.channel),transmissionMapUv:Ee&&E(o.transmissionMap.channel),thicknessMapUv:Se&&E(o.thicknessMap.channel),alphaMapUv:Me&&E(o.alphaMap.channel),vertexTangents:!!x.attributes.tangent&&(K||Q),vertexColors:o.vertexColors,vertexAlphas:!0===o.vertexColors&&!!x.attributes.color&&4===x.attributes.color.itemSize,pointsUvs:!0===T.isPoints&&!!x.attributes.uv&&(V||Me),fog:!!M,useFog:!0===o.fog,fogExp2:!!M&&M.isFogExp2,flatShading:!0===o.flatShading&&!1===o.wireframe,sizeAttenuation:!0===o.sizeAttenuation,logarithmicDepthBuffer:h,reversedDepthBuffer:B,skinning:!0===T.isSkinnedMesh,morphTargets:void 0!==x.morphAttributes.position,morphNormals:void 0!==x.morphAttributes.normal,morphColors:void 0!==x.morphAttributes.color,morphTargetsCount:P,morphTextureStride:N,numDirLights:l.directional.length,numPointLights:l.point.length,numSpotLights:l.spot.length,numSpotLightMaps:l.spotLightMap.length,numRectAreaLights:l.rectArea.length,numHemiLights:l.hemi.length,numDirLightShadows:l.directionalShadowMap.length,numPointLightShadows:l.pointShadowMap.length,numSpotLightShadows:l.spotShadowMap.length,numSpotLightShadowsWithMaps:l.numSpotLightShadowsWithMaps,numLightProbes:l.numLightProbes,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:o.dithering,shadowMapEnabled:e.shadowMap.enabled&&f.length>0,shadowMapType:e.shadowMap.type,toneMapping:be,decodeVideoTexture:V&&!0===o.map.isVideoTexture&&p.getTransfer(o.map.colorSpace)===m,decodeVideoTextureEmissive:j&&!0===o.emissiveMap.isVideoTexture&&p.getTransfer(o.emissiveMap.colorSpace)===m,premultipliedAlpha:o.premultipliedAlpha,doubleSided:o.side===fe,flipSided:o.side===c,useDepthPacking:o.depthPacking>=0,depthPacking:o.depthPacking||0,index0AttributeName:o.index0AttributeName,extensionClipCullDistance:Ae&&!0===o.extensions.clipCullDistance&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Ae&&!0===o.extensions.multiDraw||G)&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:o.customProgramCacheKey()};return Ce.vertexUv1s=u.has(1),Ce.vertexUv2s=u.has(2),Ce.vertexUv3s=u.has(3),u.clear(),Ce},getProgramCacheKey:function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(!function(e,t){e.push(t.precision),e.push(t.outputColorSpace),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.mapUv),e.push(t.alphaMapUv),e.push(t.lightMapUv),e.push(t.aoMapUv),e.push(t.bumpMapUv),e.push(t.normalMapUv),e.push(t.displacementMapUv),e.push(t.emissiveMapUv),e.push(t.metalnessMapUv),e.push(t.roughnessMapUv),e.push(t.anisotropyMapUv),e.push(t.clearcoatMapUv),e.push(t.clearcoatNormalMapUv),e.push(t.clearcoatRoughnessMapUv),e.push(t.iridescenceMapUv),e.push(t.iridescenceThicknessMapUv),e.push(t.sheenColorMapUv),e.push(t.sheenRoughnessMapUv),e.push(t.specularMapUv),e.push(t.specularColorMapUv),e.push(t.specularIntensityMapUv),e.push(t.transmissionMapUv),e.push(t.thicknessMapUv),e.push(t.combine),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numSpotLightMaps),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.numSpotLightShadowsWithMaps),e.push(t.numLightProbes),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){l.disableAll(),t.supportsVertexTextures&&l.enable(0);t.instancing&&l.enable(1);t.instancingColor&&l.enable(2);t.instancingMorph&&l.enable(3);t.matcap&&l.enable(4);t.envMap&&l.enable(5);t.normalMapObjectSpace&&l.enable(6);t.normalMapTangentSpace&&l.enable(7);t.clearcoat&&l.enable(8);t.iridescence&&l.enable(9);t.alphaTest&&l.enable(10);t.vertexColors&&l.enable(11);t.vertexAlphas&&l.enable(12);t.vertexUv1s&&l.enable(13);t.vertexUv2s&&l.enable(14);t.vertexUv3s&&l.enable(15);t.vertexTangents&&l.enable(16);t.anisotropy&&l.enable(17);t.alphaHash&&l.enable(18);t.batching&&l.enable(19);t.dispersion&&l.enable(20);t.batchingColor&&l.enable(21);t.gradientMap&&l.enable(22);e.push(l.mask),l.disableAll(),t.fog&&l.enable(0);t.useFog&&l.enable(1);t.flatShading&&l.enable(2);t.logarithmicDepthBuffer&&l.enable(3);t.reversedDepthBuffer&&l.enable(4);t.skinning&&l.enable(5);t.morphTargets&&l.enable(6);t.morphNormals&&l.enable(7);t.morphColors&&l.enable(8);t.premultipliedAlpha&&l.enable(9);t.shadowMapEnabled&&l.enable(10);t.doubleSided&&l.enable(11);t.flipSided&&l.enable(12);t.useDepthPacking&&l.enable(13);t.dithering&&l.enable(14);t.transmission&&l.enable(15);t.sheen&&l.enable(16);t.opaque&&l.enable(17);t.pointsUvs&&l.enable(18);t.decodeVideoTexture&&l.enable(19);t.decodeVideoTextureEmissive&&l.enable(20);t.alphaToCoverage&&l.enable(21);e.push(l.mask)}(n,t),n.push(e.outputColorSpace)),n.push(t.customProgramCacheKey),n.join()},getUniforms:function(e){const t=v[e.type];let n;if(t){const e=Pn[t];n=ue.clone(e.uniforms)}else n=e.uniforms;return n},acquireProgram:function(t,n){let r;for(let e=0,t=f.length;e<t;e++){const t=f[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new Ii(e,n,t,o),f.push(r)),r},releaseProgram:function(e){if(0===--e.usedTimes){const t=f.indexOf(e);f[t]=f[f.length-1],f.pop(),e.destroy()}},releaseShaderCache:function(e){d.remove(e)},programs:f,dispose:function(){d.dispose()}}}
```
</details>

### `E(e: any): string`

**Parameters:**

- **`e`** `any`

**Returns:** `string`

**Calls:**

- `u.add`

<details><summary>Code</summary>

```typescript
function E(e){return u.add(e),0===e?"uv":`uv${e}`}
```
</details>

### `getParameters(o: any, l: any, f: any, S: any, T: any): { shaderID: any; shaderType: any; shaderName: any; vertexShader: any; fragmentShader: any; defines: any; customVertexShaderID: any; customFragmentShaderID: any; isRawShaderMaterial: boolean; ... 118 more ...; customProgramCacheKey: any; }`

**Parameters:**

- **`o`** `any`
- **`l`** `any`
- **`f`** `any`
- **`S`** `any`
- **`T`** `any`

**Returns:** `{ shaderID: any; shaderType: any; shaderName: any; vertexShader: any; fragmentShader: any; defines: any; customVertexShaderID: any; customFragmentShaderID: any; isRawShaderMaterial: boolean; ... 118 more ...; customProgramCacheKey: any; }`

**Calls:**

- `(o.isMeshStandardMaterial?n:t).get`
- `i.getMaxPrecision`
- `console.warn`
- `d.update`
- `d.getVertexShaderID`
- `d.getFragmentShaderID`
- `e.getRenderTarget`
- `e.state.buffers.depth.getReversed`
- `E`
- `p.getTransfer`
- `r.has`
- `o.customProgramCacheKey`
- `u.has`
- `u.clear`

<details><summary>Code</summary>

```typescript
function(o,l,f,S,T){const M=S.fog,x=T.geometry,R=o.isMeshStandardMaterial?S.environment:null,A=(o.isMeshStandardMaterial?n:t).get(o.envMap||R),b=A&&A.mapping===a?A.image.height:null,C=v[o.type];null!==o.precision&&(g=i.getMaxPrecision(o.precision),g!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",g,"instead."));const L=x.morphAttributes.position||x.morphAttributes.normal||x.morphAttributes.color,P=void 0!==L?L.length:0;let U,w,y,I,N=0;if(void 0!==x.morphAttributes.position&&(N=1),void 0!==x.morphAttributes.normal&&(N=2),void 0!==x.morphAttributes.color&&(N=3),C){const e=Pn[C];U=e.vertexShader,w=e.fragmentShader}else U=o.vertexShader,w=o.fragmentShader,d.update(o),y=d.getVertexShaderID(o),I=d.getFragmentShaderID(o);const O=e.getRenderTarget(),B=e.state.buffers.depth.getReversed(),H=!0===T.isInstancedMesh,G=!0===T.isBatchedMesh,V=!!o.map,z=!!o.matcap,k=!!A,W=!!o.aoMap,X=!!o.lightMap,Y=!!o.bumpMap,K=!!o.normalMap,q=!!o.displacementMap,j=!!o.emissiveMap,Z=!!o.metalnessMap,$=!!o.roughnessMap,Q=o.anisotropy>0,J=o.clearcoat>0,ee=o.dispersion>0,te=o.iridescence>0,ne=o.sheen>0,re=o.transmission>0,ie=Q&&!!o.anisotropyMap,ae=J&&!!o.clearcoatMap,oe=J&&!!o.clearcoatNormalMap,se=J&&!!o.clearcoatRoughnessMap,le=te&&!!o.iridescenceMap,ce=te&&!!o.iridescenceThicknessMap,de=ne&&!!o.sheenColorMap,ue=ne&&!!o.sheenRoughnessMap,_e=!!o.specularMap,ge=!!o.specularColorMap,ve=!!o.specularIntensityMap,Ee=re&&!!o.transmissionMap,Se=re&&!!o.thicknessMap,Te=!!o.gradientMap,Me=!!o.alphaMap,xe=o.alphaTest>0,Re=!!o.alphaHash,Ae=!!o.extensions;let be=D;o.toneMapped&&(null!==O&&!0!==O.isXRRenderTarget||(be=e.toneMapping));const Ce={shaderID:C,shaderType:o.type,shaderName:o.name,vertexShader:U,fragmentShader:w,defines:o.defines,customVertexShaderID:y,customFragmentShaderID:I,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:g,batching:G,batchingColor:G&&null!==T._colorsTexture,instancing:H,instancingColor:H&&null!==T.instanceColor,instancingMorph:H&&null!==T.morphTexture,supportsVertexTextures:_,outputColorSpace:null===O?e.outputColorSpace:!0===O.isXRRenderTarget?O.texture.colorSpace:F,alphaToCoverage:!!o.alphaToCoverage,map:V,matcap:z,envMap:k,envMapMode:k&&A.mapping,envMapCubeUVHeight:b,aoMap:W,lightMap:X,bumpMap:Y,normalMap:K,displacementMap:_&&q,emissiveMap:j,normalMapObjectSpace:K&&o.normalMapType===he,normalMapTangentSpace:K&&o.normalMapType===me,metalnessMap:Z,roughnessMap:$,anisotropy:Q,anisotropyMap:ie,clearcoat:J,clearcoatMap:ae,clearcoatNormalMap:oe,clearcoatRoughnessMap:se,dispersion:ee,iridescence:te,iridescenceMap:le,iridescenceThicknessMap:ce,sheen:ne,sheenColorMap:de,sheenRoughnessMap:ue,specularMap:_e,specularColorMap:ge,specularIntensityMap:ve,transmission:re,transmissionMap:Ee,thicknessMap:Se,gradientMap:Te,opaque:!1===o.transparent&&o.blending===pe&&!1===o.alphaToCoverage,alphaMap:Me,alphaTest:xe,alphaHash:Re,combine:o.combine,mapUv:V&&E(o.map.channel),aoMapUv:W&&E(o.aoMap.channel),lightMapUv:X&&E(o.lightMap.channel),bumpMapUv:Y&&E(o.bumpMap.channel),normalMapUv:K&&E(o.normalMap.channel),displacementMapUv:q&&E(o.displacementMap.channel),emissiveMapUv:j&&E(o.emissiveMap.channel),metalnessMapUv:Z&&E(o.metalnessMap.channel),roughnessMapUv:$&&E(o.roughnessMap.channel),anisotropyMapUv:ie&&E(o.anisotropyMap.channel),clearcoatMapUv:ae&&E(o.clearcoatMap.channel),clearcoatNormalMapUv:oe&&E(o.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:se&&E(o.clearcoatRoughnessMap.channel),iridescenceMapUv:le&&E(o.iridescenceMap.channel),iridescenceThicknessMapUv:ce&&E(o.iridescenceThicknessMap.channel),sheenColorMapUv:de&&E(o.sheenColorMap.channel),sheenRoughnessMapUv:ue&&E(o.sheenRoughnessMap.channel),specularMapUv:_e&&E(o.specularMap.channel),specularColorMapUv:ge&&E(o.specularColorMap.channel),specularIntensityMapUv:ve&&E(o.specularIntensityMap.channel),transmissionMapUv:Ee&&E(o.transmissionMap.channel),thicknessMapUv:Se&&E(o.thicknessMap.channel),alphaMapUv:Me&&E(o.alphaMap.channel),vertexTangents:!!x.attributes.tangent&&(K||Q),vertexColors:o.vertexColors,vertexAlphas:!0===o.vertexColors&&!!x.attributes.color&&4===x.attributes.color.itemSize,pointsUvs:!0===T.isPoints&&!!x.attributes.uv&&(V||Me),fog:!!M,useFog:!0===o.fog,fogExp2:!!M&&M.isFogExp2,flatShading:!0===o.flatShading&&!1===o.wireframe,sizeAttenuation:!0===o.sizeAttenuation,logarithmicDepthBuffer:h,reversedDepthBuffer:B,skinning:!0===T.isSkinnedMesh,morphTargets:void 0!==x.morphAttributes.position,morphNormals:void 0!==x.morphAttributes.normal,morphColors:void 0!==x.morphAttributes.color,morphTargetsCount:P,morphTextureStride:N,numDirLights:l.directional.length,numPointLights:l.point.length,numSpotLights:l.spot.length,numSpotLightMaps:l.spotLightMap.length,numRectAreaLights:l.rectArea.length,numHemiLights:l.hemi.length,numDirLightShadows:l.directionalShadowMap.length,numPointLightShadows:l.pointShadowMap.length,numSpotLightShadows:l.spotShadowMap.length,numSpotLightShadowsWithMaps:l.numSpotLightShadowsWithMaps,numLightProbes:l.numLightProbes,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:o.dithering,shadowMapEnabled:e.shadowMap.enabled&&f.length>0,shadowMapType:e.shadowMap.type,toneMapping:be,decodeVideoTexture:V&&!0===o.map.isVideoTexture&&p.getTransfer(o.map.colorSpace)===m,decodeVideoTextureEmissive:j&&!0===o.emissiveMap.isVideoTexture&&p.getTransfer(o.emissiveMap.colorSpace)===m,premultipliedAlpha:o.premultipliedAlpha,doubleSided:o.side===fe,flipSided:o.side===c,useDepthPacking:o.depthPacking>=0,depthPacking:o.depthPacking||0,index0AttributeName:o.index0AttributeName,extensionClipCullDistance:Ae&&!0===o.extensions.clipCullDistance&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Ae&&!0===o.extensions.multiDraw||G)&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:o.customProgramCacheKey()};return Ce.vertexUv1s=u.has(1),Ce.vertexUv2s=u.has(2),Ce.vertexUv3s=u.has(3),u.clear(),Ce}
```
</details>

### `getProgramCacheKey(t: any): string`

**Parameters:**

- **`t`** `any`

**Returns:** `string`

**Calls:**

- `n.push`
- `complex_call_224897`
- `e.push`
- `complex_call_226159`
- `l.disableAll`
- `l.enable`
- `n.join`

<details><summary>Code</summary>

```typescript
function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(!function(e,t){e.push(t.precision),e.push(t.outputColorSpace),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.mapUv),e.push(t.alphaMapUv),e.push(t.lightMapUv),e.push(t.aoMapUv),e.push(t.bumpMapUv),e.push(t.normalMapUv),e.push(t.displacementMapUv),e.push(t.emissiveMapUv),e.push(t.metalnessMapUv),e.push(t.roughnessMapUv),e.push(t.anisotropyMapUv),e.push(t.clearcoatMapUv),e.push(t.clearcoatNormalMapUv),e.push(t.clearcoatRoughnessMapUv),e.push(t.iridescenceMapUv),e.push(t.iridescenceThicknessMapUv),e.push(t.sheenColorMapUv),e.push(t.sheenRoughnessMapUv),e.push(t.specularMapUv),e.push(t.specularColorMapUv),e.push(t.specularIntensityMapUv),e.push(t.transmissionMapUv),e.push(t.thicknessMapUv),e.push(t.combine),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numSpotLightMaps),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.numSpotLightShadowsWithMaps),e.push(t.numLightProbes),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){l.disableAll(),t.supportsVertexTextures&&l.enable(0);t.instancing&&l.enable(1);t.instancingColor&&l.enable(2);t.instancingMorph&&l.enable(3);t.matcap&&l.enable(4);t.envMap&&l.enable(5);t.normalMapObjectSpace&&l.enable(6);t.normalMapTangentSpace&&l.enable(7);t.clearcoat&&l.enable(8);t.iridescence&&l.enable(9);t.alphaTest&&l.enable(10);t.vertexColors&&l.enable(11);t.vertexAlphas&&l.enable(12);t.vertexUv1s&&l.enable(13);t.vertexUv2s&&l.enable(14);t.vertexUv3s&&l.enable(15);t.vertexTangents&&l.enable(16);t.anisotropy&&l.enable(17);t.alphaHash&&l.enable(18);t.batching&&l.enable(19);t.dispersion&&l.enable(20);t.batchingColor&&l.enable(21);t.gradientMap&&l.enable(22);e.push(l.mask),l.disableAll(),t.fog&&l.enable(0);t.useFog&&l.enable(1);t.flatShading&&l.enable(2);t.logarithmicDepthBuffer&&l.enable(3);t.reversedDepthBuffer&&l.enable(4);t.skinning&&l.enable(5);t.morphTargets&&l.enable(6);t.morphNormals&&l.enable(7);t.morphColors&&l.enable(8);t.premultipliedAlpha&&l.enable(9);t.shadowMapEnabled&&l.enable(10);t.doubleSided&&l.enable(11);t.flipSided&&l.enable(12);t.useDepthPacking&&l.enable(13);t.dithering&&l.enable(14);t.transmission&&l.enable(15);t.sheen&&l.enable(16);t.opaque&&l.enable(17);t.pointsUvs&&l.enable(18);t.decodeVideoTexture&&l.enable(19);t.decodeVideoTextureEmissive&&l.enable(20);t.alphaToCoverage&&l.enable(21);e.push(l.mask)}(n,t),n.push(e.outputColorSpace)),n.push(t.customProgramCacheKey),n.join()}
```
</details>

### `getUniforms(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `ue.clone`

<details><summary>Code</summary>

```typescript
function(e){const t=v[e.type];let n;if(t){const e=Pn[t];n=ue.clone(e.uniforms)}else n=e.uniforms;return n}
```
</details>

### `acquireProgram(t: any, n: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `f.push`

<details><summary>Code</summary>

```typescript
function(t,n){let r;for(let e=0,t=f.length;e<t;e++){const t=f[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new Ii(e,n,t,o),f.push(r)),r}
```
</details>

### `releaseProgram(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `f.indexOf`
- `f.pop`
- `e.destroy`

<details><summary>Code</summary>

```typescript
function(e){if(0===--e.usedTimes){const t=f.indexOf(e);f[t]=f[f.length-1],f.pop(),e.destroy()}}
```
</details>

### `releaseShaderCache(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `d.remove`

<details><summary>Code</summary>

```typescript
function(e){d.remove(e)}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `d.dispose`

<details><summary>Code</summary>

```typescript
function(){d.dispose()}
```
</details>

### `getParameters(o: any, l: any, f: any, S: any, T: any): { shaderID: any; shaderType: any; shaderName: any; vertexShader: any; fragmentShader: any; defines: any; customVertexShaderID: any; customFragmentShaderID: any; isRawShaderMaterial: boolean; ... 118 more ...; customProgramCacheKey: any; }`

**Parameters:**

- **`o`** `any`
- **`l`** `any`
- **`f`** `any`
- **`S`** `any`
- **`T`** `any`

**Returns:** `{ shaderID: any; shaderType: any; shaderName: any; vertexShader: any; fragmentShader: any; defines: any; customVertexShaderID: any; customFragmentShaderID: any; isRawShaderMaterial: boolean; ... 118 more ...; customProgramCacheKey: any; }`

**Calls:**

- `(o.isMeshStandardMaterial?n:t).get`
- `i.getMaxPrecision`
- `console.warn`
- `d.update`
- `d.getVertexShaderID`
- `d.getFragmentShaderID`
- `e.getRenderTarget`
- `e.state.buffers.depth.getReversed`
- `E`
- `p.getTransfer`
- `r.has`
- `o.customProgramCacheKey`
- `u.has`
- `u.clear`

<details><summary>Code</summary>

```typescript
function(o,l,f,S,T){const M=S.fog,x=T.geometry,R=o.isMeshStandardMaterial?S.environment:null,A=(o.isMeshStandardMaterial?n:t).get(o.envMap||R),b=A&&A.mapping===a?A.image.height:null,C=v[o.type];null!==o.precision&&(g=i.getMaxPrecision(o.precision),g!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",g,"instead."));const L=x.morphAttributes.position||x.morphAttributes.normal||x.morphAttributes.color,P=void 0!==L?L.length:0;let U,w,y,I,N=0;if(void 0!==x.morphAttributes.position&&(N=1),void 0!==x.morphAttributes.normal&&(N=2),void 0!==x.morphAttributes.color&&(N=3),C){const e=Pn[C];U=e.vertexShader,w=e.fragmentShader}else U=o.vertexShader,w=o.fragmentShader,d.update(o),y=d.getVertexShaderID(o),I=d.getFragmentShaderID(o);const O=e.getRenderTarget(),B=e.state.buffers.depth.getReversed(),H=!0===T.isInstancedMesh,G=!0===T.isBatchedMesh,V=!!o.map,z=!!o.matcap,k=!!A,W=!!o.aoMap,X=!!o.lightMap,Y=!!o.bumpMap,K=!!o.normalMap,q=!!o.displacementMap,j=!!o.emissiveMap,Z=!!o.metalnessMap,$=!!o.roughnessMap,Q=o.anisotropy>0,J=o.clearcoat>0,ee=o.dispersion>0,te=o.iridescence>0,ne=o.sheen>0,re=o.transmission>0,ie=Q&&!!o.anisotropyMap,ae=J&&!!o.clearcoatMap,oe=J&&!!o.clearcoatNormalMap,se=J&&!!o.clearcoatRoughnessMap,le=te&&!!o.iridescenceMap,ce=te&&!!o.iridescenceThicknessMap,de=ne&&!!o.sheenColorMap,ue=ne&&!!o.sheenRoughnessMap,_e=!!o.specularMap,ge=!!o.specularColorMap,ve=!!o.specularIntensityMap,Ee=re&&!!o.transmissionMap,Se=re&&!!o.thicknessMap,Te=!!o.gradientMap,Me=!!o.alphaMap,xe=o.alphaTest>0,Re=!!o.alphaHash,Ae=!!o.extensions;let be=D;o.toneMapped&&(null!==O&&!0!==O.isXRRenderTarget||(be=e.toneMapping));const Ce={shaderID:C,shaderType:o.type,shaderName:o.name,vertexShader:U,fragmentShader:w,defines:o.defines,customVertexShaderID:y,customFragmentShaderID:I,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:g,batching:G,batchingColor:G&&null!==T._colorsTexture,instancing:H,instancingColor:H&&null!==T.instanceColor,instancingMorph:H&&null!==T.morphTexture,supportsVertexTextures:_,outputColorSpace:null===O?e.outputColorSpace:!0===O.isXRRenderTarget?O.texture.colorSpace:F,alphaToCoverage:!!o.alphaToCoverage,map:V,matcap:z,envMap:k,envMapMode:k&&A.mapping,envMapCubeUVHeight:b,aoMap:W,lightMap:X,bumpMap:Y,normalMap:K,displacementMap:_&&q,emissiveMap:j,normalMapObjectSpace:K&&o.normalMapType===he,normalMapTangentSpace:K&&o.normalMapType===me,metalnessMap:Z,roughnessMap:$,anisotropy:Q,anisotropyMap:ie,clearcoat:J,clearcoatMap:ae,clearcoatNormalMap:oe,clearcoatRoughnessMap:se,dispersion:ee,iridescence:te,iridescenceMap:le,iridescenceThicknessMap:ce,sheen:ne,sheenColorMap:de,sheenRoughnessMap:ue,specularMap:_e,specularColorMap:ge,specularIntensityMap:ve,transmission:re,transmissionMap:Ee,thicknessMap:Se,gradientMap:Te,opaque:!1===o.transparent&&o.blending===pe&&!1===o.alphaToCoverage,alphaMap:Me,alphaTest:xe,alphaHash:Re,combine:o.combine,mapUv:V&&E(o.map.channel),aoMapUv:W&&E(o.aoMap.channel),lightMapUv:X&&E(o.lightMap.channel),bumpMapUv:Y&&E(o.bumpMap.channel),normalMapUv:K&&E(o.normalMap.channel),displacementMapUv:q&&E(o.displacementMap.channel),emissiveMapUv:j&&E(o.emissiveMap.channel),metalnessMapUv:Z&&E(o.metalnessMap.channel),roughnessMapUv:$&&E(o.roughnessMap.channel),anisotropyMapUv:ie&&E(o.anisotropyMap.channel),clearcoatMapUv:ae&&E(o.clearcoatMap.channel),clearcoatNormalMapUv:oe&&E(o.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:se&&E(o.clearcoatRoughnessMap.channel),iridescenceMapUv:le&&E(o.iridescenceMap.channel),iridescenceThicknessMapUv:ce&&E(o.iridescenceThicknessMap.channel),sheenColorMapUv:de&&E(o.sheenColorMap.channel),sheenRoughnessMapUv:ue&&E(o.sheenRoughnessMap.channel),specularMapUv:_e&&E(o.specularMap.channel),specularColorMapUv:ge&&E(o.specularColorMap.channel),specularIntensityMapUv:ve&&E(o.specularIntensityMap.channel),transmissionMapUv:Ee&&E(o.transmissionMap.channel),thicknessMapUv:Se&&E(o.thicknessMap.channel),alphaMapUv:Me&&E(o.alphaMap.channel),vertexTangents:!!x.attributes.tangent&&(K||Q),vertexColors:o.vertexColors,vertexAlphas:!0===o.vertexColors&&!!x.attributes.color&&4===x.attributes.color.itemSize,pointsUvs:!0===T.isPoints&&!!x.attributes.uv&&(V||Me),fog:!!M,useFog:!0===o.fog,fogExp2:!!M&&M.isFogExp2,flatShading:!0===o.flatShading&&!1===o.wireframe,sizeAttenuation:!0===o.sizeAttenuation,logarithmicDepthBuffer:h,reversedDepthBuffer:B,skinning:!0===T.isSkinnedMesh,morphTargets:void 0!==x.morphAttributes.position,morphNormals:void 0!==x.morphAttributes.normal,morphColors:void 0!==x.morphAttributes.color,morphTargetsCount:P,morphTextureStride:N,numDirLights:l.directional.length,numPointLights:l.point.length,numSpotLights:l.spot.length,numSpotLightMaps:l.spotLightMap.length,numRectAreaLights:l.rectArea.length,numHemiLights:l.hemi.length,numDirLightShadows:l.directionalShadowMap.length,numPointLightShadows:l.pointShadowMap.length,numSpotLightShadows:l.spotShadowMap.length,numSpotLightShadowsWithMaps:l.numSpotLightShadowsWithMaps,numLightProbes:l.numLightProbes,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:o.dithering,shadowMapEnabled:e.shadowMap.enabled&&f.length>0,shadowMapType:e.shadowMap.type,toneMapping:be,decodeVideoTexture:V&&!0===o.map.isVideoTexture&&p.getTransfer(o.map.colorSpace)===m,decodeVideoTextureEmissive:j&&!0===o.emissiveMap.isVideoTexture&&p.getTransfer(o.emissiveMap.colorSpace)===m,premultipliedAlpha:o.premultipliedAlpha,doubleSided:o.side===fe,flipSided:o.side===c,useDepthPacking:o.depthPacking>=0,depthPacking:o.depthPacking||0,index0AttributeName:o.index0AttributeName,extensionClipCullDistance:Ae&&!0===o.extensions.clipCullDistance&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Ae&&!0===o.extensions.multiDraw||G)&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:o.customProgramCacheKey()};return Ce.vertexUv1s=u.has(1),Ce.vertexUv2s=u.has(2),Ce.vertexUv3s=u.has(3),u.clear(),Ce}
```
</details>

### `getProgramCacheKey(t: any): string`

**Parameters:**

- **`t`** `any`

**Returns:** `string`

**Calls:**

- `n.push`
- `complex_call_224897`
- `e.push`
- `complex_call_226159`
- `l.disableAll`
- `l.enable`
- `n.join`

<details><summary>Code</summary>

```typescript
function(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.customVertexShaderID),n.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(!function(e,t){e.push(t.precision),e.push(t.outputColorSpace),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.mapUv),e.push(t.alphaMapUv),e.push(t.lightMapUv),e.push(t.aoMapUv),e.push(t.bumpMapUv),e.push(t.normalMapUv),e.push(t.displacementMapUv),e.push(t.emissiveMapUv),e.push(t.metalnessMapUv),e.push(t.roughnessMapUv),e.push(t.anisotropyMapUv),e.push(t.clearcoatMapUv),e.push(t.clearcoatNormalMapUv),e.push(t.clearcoatRoughnessMapUv),e.push(t.iridescenceMapUv),e.push(t.iridescenceThicknessMapUv),e.push(t.sheenColorMapUv),e.push(t.sheenRoughnessMapUv),e.push(t.specularMapUv),e.push(t.specularColorMapUv),e.push(t.specularIntensityMapUv),e.push(t.transmissionMapUv),e.push(t.thicknessMapUv),e.push(t.combine),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numSpotLightMaps),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.numSpotLightShadowsWithMaps),e.push(t.numLightProbes),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(n,t),function(e,t){l.disableAll(),t.supportsVertexTextures&&l.enable(0);t.instancing&&l.enable(1);t.instancingColor&&l.enable(2);t.instancingMorph&&l.enable(3);t.matcap&&l.enable(4);t.envMap&&l.enable(5);t.normalMapObjectSpace&&l.enable(6);t.normalMapTangentSpace&&l.enable(7);t.clearcoat&&l.enable(8);t.iridescence&&l.enable(9);t.alphaTest&&l.enable(10);t.vertexColors&&l.enable(11);t.vertexAlphas&&l.enable(12);t.vertexUv1s&&l.enable(13);t.vertexUv2s&&l.enable(14);t.vertexUv3s&&l.enable(15);t.vertexTangents&&l.enable(16);t.anisotropy&&l.enable(17);t.alphaHash&&l.enable(18);t.batching&&l.enable(19);t.dispersion&&l.enable(20);t.batchingColor&&l.enable(21);t.gradientMap&&l.enable(22);e.push(l.mask),l.disableAll(),t.fog&&l.enable(0);t.useFog&&l.enable(1);t.flatShading&&l.enable(2);t.logarithmicDepthBuffer&&l.enable(3);t.reversedDepthBuffer&&l.enable(4);t.skinning&&l.enable(5);t.morphTargets&&l.enable(6);t.morphNormals&&l.enable(7);t.morphColors&&l.enable(8);t.premultipliedAlpha&&l.enable(9);t.shadowMapEnabled&&l.enable(10);t.doubleSided&&l.enable(11);t.flipSided&&l.enable(12);t.useDepthPacking&&l.enable(13);t.dithering&&l.enable(14);t.transmission&&l.enable(15);t.sheen&&l.enable(16);t.opaque&&l.enable(17);t.pointsUvs&&l.enable(18);t.decodeVideoTexture&&l.enable(19);t.decodeVideoTextureEmissive&&l.enable(20);t.alphaToCoverage&&l.enable(21);e.push(l.mask)}(n,t),n.push(e.outputColorSpace)),n.push(t.customProgramCacheKey),n.join()}
```
</details>

### `getUniforms(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `ue.clone`

<details><summary>Code</summary>

```typescript
function(e){const t=v[e.type];let n;if(t){const e=Pn[t];n=ue.clone(e.uniforms)}else n=e.uniforms;return n}
```
</details>

### `acquireProgram(t: any, n: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `f.push`

<details><summary>Code</summary>

```typescript
function(t,n){let r;for(let e=0,t=f.length;e<t;e++){const t=f[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new Ii(e,n,t,o),f.push(r)),r}
```
</details>

### `releaseProgram(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `f.indexOf`
- `f.pop`
- `e.destroy`

<details><summary>Code</summary>

```typescript
function(e){if(0===--e.usedTimes){const t=f.indexOf(e);f[t]=f[f.length-1],f.pop(),e.destroy()}}
```
</details>

### `releaseShaderCache(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `d.remove`

<details><summary>Code</summary>

```typescript
function(e){d.remove(e)}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `d.dispose`

<details><summary>Code</summary>

```typescript
function(){d.dispose()}
```
</details>

### `Hi(): { has: (t: any) => boolean; get: (t: any) => any; remove: (t: any) => void; update: (t: any, n: any, r: any) => void; dispose: () => void; }`

**Returns:** `{ has: (t: any) => boolean; get: (t: any) => any; remove: (t: any) => void; update: (t: any, n: any, r: any) => void; dispose: () => void; }`

**Calls:**

- `e.has`
- `e.get`
- `e.set`
- `e.delete`

<details><summary>Code</summary>

```typescript
function Hi(){let e=new WeakMap;return{has:function(t){return e.has(t)},get:function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n},remove:function(t){e.delete(t)},update:function(t,n,r){e.get(t)[n]=r},dispose:function(){e=new WeakMap}}}
```
</details>

### `has(t: any): boolean`

**Parameters:**

- **`t`** `any`

**Returns:** `boolean`

**Calls:**

- `e.has`

<details><summary>Code</summary>

```typescript
function(t){return e.has(t)}
```
</details>

### `get(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.get`
- `e.set`

<details><summary>Code</summary>

```typescript
function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n}
```
</details>

### `remove(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.delete`

<details><summary>Code</summary>

```typescript
function(t){e.delete(t)}
```
</details>

### `update(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.get`

<details><summary>Code</summary>

```typescript
function(t,n,r){e.get(t)[n]=r}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){e=new WeakMap}
```
</details>

### `has(t: any): boolean`

**Parameters:**

- **`t`** `any`

**Returns:** `boolean`

**Calls:**

- `e.has`

<details><summary>Code</summary>

```typescript
function(t){return e.has(t)}
```
</details>

### `get(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

**Calls:**

- `e.get`
- `e.set`

<details><summary>Code</summary>

```typescript
function(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n}
```
</details>

### `remove(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.delete`

<details><summary>Code</summary>

```typescript
function(t){e.delete(t)}
```
</details>

### `update(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.get`

<details><summary>Code</summary>

```typescript
function(t,n,r){e.get(t)[n]=r}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){e=new WeakMap}
```
</details>

### `Gi(e: any, t: any): number`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `number`

<details><summary>Code</summary>

```typescript
function Gi(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}
```
</details>

### `Vi(e: any, t: any): number`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `number`

<details><summary>Code</summary>

```typescript
function Vi(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}
```
</details>

### `zi(): { opaque: any[]; transmissive: any[]; transparent: any[]; init: () => void; push: (e: any, t: any, o: any, s: any, l: any, c: any) => void; unshift: (e: any, t: any, o: any, s: any, l: any, c: any) => void; finish: () => void; sort: (e: any, t: any) => void; }`

**Returns:** `{ opaque: any[]; transmissive: any[]; transparent: any[]; init: () => void; push: (e: any, t: any, o: any, s: any, l: any, c: any) => void; unshift: (e: any, t: any, o: any, s: any, l: any, c: any) => void; finish: () => void; sort: (e: any, t: any) => void; }`

**Calls:**

- `a`
- `r.push`
- `i.push`
- `n.push`
- `r.unshift`
- `i.unshift`
- `n.unshift`
- `n.sort`
- `r.sort`
- `i.sort`

<details><summary>Code</summary>

```typescript
function zi(){const e=[];let t=0;const n=[],r=[],i=[];function a(n,r,i,a,o,s){let l=e[t];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:a,renderOrder:n.renderOrder,z:o,group:s},e[t]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=a,l.renderOrder=n.renderOrder,l.z=o,l.group=s),t++,l}return{opaque:n,transmissive:r,transparent:i,init:function(){t=0,n.length=0,r.length=0,i.length=0},push:function(e,t,o,s,l,c){const d=a(e,t,o,s,l,c);o.transmission>0?r.push(d):!0===o.transparent?i.push(d):n.push(d)},unshift:function(e,t,o,s,l,c){const d=a(e,t,o,s,l,c);o.transmission>0?r.unshift(d):!0===o.transparent?i.unshift(d):n.unshift(d)},finish:function(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort:function(e,t){n.length>1&&n.sort(e||Gi),r.length>1&&r.sort(t||Vi),i.length>1&&i.sort(t||Vi)}}}
```
</details>

### `a(n: any, r: any, i: any, a: any, o: any, s: any): any`

**Parameters:**

- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function a(n,r,i,a,o,s){let l=e[t];return void 0===l?(l={id:n.id,object:n,geometry:r,material:i,groupOrder:a,renderOrder:n.renderOrder,z:o,group:s},e[t]=l):(l.id=n.id,l.object=n,l.geometry=r,l.material=i,l.groupOrder=a,l.renderOrder=n.renderOrder,l.z=o,l.group=s),t++,l}
```
</details>

### `init(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=0,n.length=0,r.length=0,i.length=0}
```
</details>

### `push(e: any, t: any, o: any, s: any, l: any, c: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`o`** `any`
- **`s`** `any`
- **`l`** `any`
- **`c`** `any`

**Returns:** `void`

**Calls:**

- `a`
- `r.push`
- `i.push`
- `n.push`

<details><summary>Code</summary>

```typescript
function(e,t,o,s,l,c){const d=a(e,t,o,s,l,c);o.transmission>0?r.push(d):!0===o.transparent?i.push(d):n.push(d)}
```
</details>

### `unshift(e: any, t: any, o: any, s: any, l: any, c: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`o`** `any`
- **`s`** `any`
- **`l`** `any`
- **`c`** `any`

**Returns:** `void`

**Calls:**

- `a`
- `r.unshift`
- `i.unshift`
- `n.unshift`

<details><summary>Code</summary>

```typescript
function(e,t,o,s,l,c){const d=a(e,t,o,s,l,c);o.transmission>0?r.unshift(d):!0===o.transparent?i.unshift(d):n.unshift(d)}
```
</details>

### `finish(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}}
```
</details>

### `sort(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `n.sort`
- `r.sort`
- `i.sort`

<details><summary>Code</summary>

```typescript
function(e,t){n.length>1&&n.sort(e||Gi),r.length>1&&r.sort(t||Vi),i.length>1&&i.sort(t||Vi)}
```
</details>

### `init(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=0,n.length=0,r.length=0,i.length=0}
```
</details>

### `push(e: any, t: any, o: any, s: any, l: any, c: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`o`** `any`
- **`s`** `any`
- **`l`** `any`
- **`c`** `any`

**Returns:** `void`

**Calls:**

- `a`
- `r.push`
- `i.push`
- `n.push`

<details><summary>Code</summary>

```typescript
function(e,t,o,s,l,c){const d=a(e,t,o,s,l,c);o.transmission>0?r.push(d):!0===o.transparent?i.push(d):n.push(d)}
```
</details>

### `unshift(e: any, t: any, o: any, s: any, l: any, c: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`o`** `any`
- **`s`** `any`
- **`l`** `any`
- **`c`** `any`

**Returns:** `void`

**Calls:**

- `a`
- `r.unshift`
- `i.unshift`
- `n.unshift`

<details><summary>Code</summary>

```typescript
function(e,t,o,s,l,c){const d=a(e,t,o,s,l,c);o.transmission>0?r.unshift(d):!0===o.transparent?i.unshift(d):n.unshift(d)}
```
</details>

### `finish(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){for(let n=t,r=e.length;n<r;n++){const t=e[n];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}}
```
</details>

### `sort(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `n.sort`
- `r.sort`
- `i.sort`

<details><summary>Code</summary>

```typescript
function(e,t){n.length>1&&n.sort(e||Gi),r.length>1&&r.sort(t||Vi),i.length>1&&i.sort(t||Vi)}
```
</details>

### `ki(): { get: (t: any, n: any) => any; dispose: () => void; }`

**Returns:** `{ get: (t: any, n: any) => any; dispose: () => void; }`

**Calls:**

- `e.get`
- `e.set`
- `r.push`

<details><summary>Code</summary>

```typescript
function ki(){let e=new WeakMap;return{get:function(t,n){const r=e.get(t);let i;return void 0===r?(i=new zi,e.set(t,[i])):n>=r.length?(i=new zi,r.push(i)):i=r[n],i},dispose:function(){e=new WeakMap}}}
```
</details>

### `get(t: any, n: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `e.get`
- `e.set`
- `r.push`

<details><summary>Code</summary>

```typescript
function(t,n){const r=e.get(t);let i;return void 0===r?(i=new zi,e.set(t,[i])):n>=r.length?(i=new zi,r.push(i)):i=r[n],i}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){e=new WeakMap}
```
</details>

### `get(t: any, n: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `e.get`
- `e.set`
- `r.push`

<details><summary>Code</summary>

```typescript
function(t,n){const r=e.get(t);let i;return void 0===r?(i=new zi,e.set(t,[i])):n>=r.length?(i=new zi,r.push(i)):i=r[n],i}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){e=new WeakMap}
```
</details>

### `Wi(): { get: (t: any) => any; }`

**Returns:** `{ get: (t: any) => any; }`

<details><summary>Code</summary>

```typescript
function Wi(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let r;switch(t.type){case"DirectionalLight":r={direction:new i,color:new n};break;case"SpotLight":r={position:new i,direction:new i,color:new n,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":r={position:new i,color:new n,distance:0,decay:0};break;case"HemisphereLight":r={direction:new i,skyColor:new n,groundColor:new n};break;case"RectAreaLight":r={color:new n,position:new i,halfWidth:new i,halfHeight:new i}}return e[t.id]=r,r}}}
```
</details>

### `get(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(t){if(void 0!==e[t.id])return e[t.id];let r;switch(t.type){case"DirectionalLight":r={direction:new i,color:new n};break;case"SpotLight":r={position:new i,direction:new i,color:new n,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":r={position:new i,color:new n,distance:0,decay:0};break;case"HemisphereLight":r={direction:new i,skyColor:new n,groundColor:new n};break;case"RectAreaLight":r={color:new n,position:new i,halfWidth:new i,halfHeight:new i}}return e[t.id]=r,r}
```
</details>

### `get(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(t){if(void 0!==e[t.id])return e[t.id];let r;switch(t.type){case"DirectionalLight":r={direction:new i,color:new n};break;case"SpotLight":r={position:new i,direction:new i,color:new n,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":r={position:new i,color:new n,distance:0,decay:0};break;case"HemisphereLight":r={direction:new i,skyColor:new n,groundColor:new n};break;case"RectAreaLight":r={color:new n,position:new i,halfWidth:new i,halfHeight:new i}}return e[t.id]=r,r}
```
</details>

### `Yi(e: any, t: any): number`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `number`

<details><summary>Code</summary>

```typescript
function Yi(e,t){return(t.castShadow?2:0)-(e.castShadow?2:0)+(t.map?1:0)-(e.map?1:0)}
```
</details>

### `Ki(e: any): { setup: (t: any) => void; setupView: (e: any, t: any) => void; state: { version: number; hash: { directionalLength: number; pointLength: number; spotLength: number; rectAreaLength: number; hemiLength: number; ... 4 more ...; numLightProbes: number; }; ... 20 more ...; numLightProbes: number; }; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ setup: (t: any) => void; setupView: (e: any, t: any) => void; state: { version: number; hash: { directionalLength: number; pointLength: number; spotLength: number; rectAreaLength: number; hemiLength: number; ... 4 more ...; numLightProbes: number; }; ... 20 more ...; numLightProbes: number; }; }`

**Calls:**

- `complex_call_230513`
- `a.probe.push`
- `a.probe[e].set`
- `t.sort`
- `a.probe[e].addScaledVector`
- `n.get`
- `e.color.copy(E.color).multiplyScalar`
- `r.get`
- `e.position.setFromMatrixPosition`
- `e.color.copy(S).multiplyScalar`
- `Math.cos`
- `t.updateMatrices`
- `e.halfWidth.set`
- `e.halfHeight.set`
- `e.skyColor.copy(E.color).multiplyScalar`
- `e.groundColor.copy(E.groundColor).multiplyScalar`
- `e.has`
- `e.direction.setFromMatrixPosition`
- `o.setFromMatrixPosition`
- `e.direction.sub`
- `e.direction.transformDirection`
- `e.position.applyMatrix4`
- `l.identity`
- `s.copy`
- `s.premultiply`
- `l.extractRotation`
- `e.halfWidth.applyMatrix4`
- `e.halfHeight.applyMatrix4`

<details><summary>Code</summary>

```typescript
function Ki(e){const n=new Wi,r=function(){const e={};return{get:function(n){if(void 0!==e[n.id])return e[n.id];let r;switch(n.type){case"DirectionalLight":case"SpotLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t};break;case"PointLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t,shadowCameraNear:1,shadowCameraFar:1e3}}return e[n.id]=r,r}}}(),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let e=0;e<9;e++)a.probe.push(new i);const o=new i,s=new f,l=new f;return{setup:function(t){let i=0,o=0,s=0;for(let e=0;e<9;e++)a.probe[e].set(0,0,0);let l=0,c=0,d=0,u=0,f=0,p=0,m=0,h=0,_=0,g=0,v=0;t.sort(Yi);for(let e=0,E=t.length;e<E;e++){const E=t[e],S=E.color,T=E.intensity,M=E.distance,x=E.shadow&&E.shadow.map?E.shadow.map.texture:null;if(E.isAmbientLight)i+=S.r*T,o+=S.g*T,s+=S.b*T;else if(E.isLightProbe){for(let e=0;e<9;e++)a.probe[e].addScaledVector(E.sh.coefficients[e],T);v++}else if(E.isDirectionalLight){const e=n.get(E);if(e.color.copy(E.color).multiplyScalar(E.intensity),E.castShadow){const e=E.shadow,t=r.get(E);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,a.directionalShadow[l]=t,a.directionalShadowMap[l]=x,a.directionalShadowMatrix[l]=E.shadow.matrix,p++}a.directional[l]=e,l++}else if(E.isSpotLight){const e=n.get(E);e.position.setFromMatrixPosition(E.matrixWorld),e.color.copy(S).multiplyScalar(T),e.distance=M,e.coneCos=Math.cos(E.angle),e.penumbraCos=Math.cos(E.angle*(1-E.penumbra)),e.decay=E.decay,a.spot[d]=e;const t=E.shadow;if(E.map&&(a.spotLightMap[_]=E.map,_++,t.updateMatrices(E),E.castShadow&&g++),a.spotLightMatrix[d]=t.matrix,E.castShadow){const e=r.get(E);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,a.spotShadow[d]=e,a.spotShadowMap[d]=x,h++}d++}else if(E.isRectAreaLight){const e=n.get(E);e.color.copy(S).multiplyScalar(T),e.halfWidth.set(.5*E.width,0,0),e.halfHeight.set(0,.5*E.height,0),a.rectArea[u]=e,u++}else if(E.isPointLight){const e=n.get(E);if(e.color.copy(E.color).multiplyScalar(E.intensity),e.distance=E.distance,e.decay=E.decay,E.castShadow){const e=E.shadow,t=r.get(E);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,t.shadowCameraNear=e.camera.near,t.shadowCameraFar=e.camera.far,a.pointShadow[c]=t,a.pointShadowMap[c]=x,a.pointShadowMatrix[c]=E.shadow.matrix,m++}a.point[c]=e,c++}else if(E.isHemisphereLight){const e=n.get(E);e.skyColor.copy(E.color).multiplyScalar(T),e.groundColor.copy(E.groundColor).multiplyScalar(T),a.hemi[f]=e,f++}}u>0&&(!0===e.has("OES_texture_float_linear")?(a.rectAreaLTC1=Ln.LTC_FLOAT_1,a.rectAreaLTC2=Ln.LTC_FLOAT_2):(a.rectAreaLTC1=Ln.LTC_HALF_1,a.rectAreaLTC2=Ln.LTC_HALF_2)),a.ambient[0]=i,a.ambient[1]=o,a.ambient[2]=s;const E=a.hash;E.directionalLength===l&&E.pointLength===c&&E.spotLength===d&&E.rectAreaLength===u&&E.hemiLength===f&&E.numDirectionalShadows===p&&E.numPointShadows===m&&E.numSpotShadows===h&&E.numSpotMaps===_&&E.numLightProbes===v||(a.directional.length=l,a.spot.length=d,a.rectArea.length=u,a.point.length=c,a.hemi.length=f,a.directionalShadow.length=p,a.directionalShadowMap.length=p,a.pointShadow.length=m,a.pointShadowMap.length=m,a.spotShadow.length=h,a.spotShadowMap.length=h,a.directionalShadowMatrix.length=p,a.pointShadowMatrix.length=m,a.spotLightMatrix.length=h+_-g,a.spotLightMap.length=_,a.numSpotLightShadowsWithMaps=g,a.numLightProbes=v,E.directionalLength=l,E.pointLength=c,E.spotLength=d,E.rectAreaLength=u,E.hemiLength=f,E.numDirectionalShadows=p,E.numPointShadows=m,E.numSpotShadows=h,E.numSpotMaps=_,E.numLightProbes=v,a.version=Xi++)},setupView:function(e,t){let n=0,r=0,i=0,c=0,d=0;const u=t.matrixWorldInverse;for(let t=0,f=e.length;t<f;t++){const f=e[t];if(f.isDirectionalLight){const e=a.directional[n];e.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(o),e.direction.transformDirection(u),n++}else if(f.isSpotLight){const e=a.spot[i];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),e.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(o),e.direction.transformDirection(u),i++}else if(f.isRectAreaLight){const e=a.rectArea[c];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),l.identity(),s.copy(f.matrixWorld),s.premultiply(u),l.extractRotation(s),e.halfWidth.set(.5*f.width,0,0),e.halfHeight.set(0,.5*f.height,0),e.halfWidth.applyMatrix4(l),e.halfHeight.applyMatrix4(l),c++}else if(f.isPointLight){const e=a.point[r];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),r++}else if(f.isHemisphereLight){const e=a.hemi[d];e.direction.setFromMatrixPosition(f.matrixWorld),e.direction.transformDirection(u),d++}}},state:a}}
```
</details>

### `get(n: any): any`

**Parameters:**

- **`n`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(n){if(void 0!==e[n.id])return e[n.id];let r;switch(n.type){case"DirectionalLight":case"SpotLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t};break;case"PointLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t,shadowCameraNear:1,shadowCameraFar:1e3}}return e[n.id]=r,r}
```
</details>

### `get(n: any): any`

**Parameters:**

- **`n`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(n){if(void 0!==e[n.id])return e[n.id];let r;switch(n.type){case"DirectionalLight":case"SpotLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t};break;case"PointLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t,shadowCameraNear:1,shadowCameraFar:1e3}}return e[n.id]=r,r}
```
</details>

### `get(n: any): any`

**Parameters:**

- **`n`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(n){if(void 0!==e[n.id])return e[n.id];let r;switch(n.type){case"DirectionalLight":case"SpotLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t};break;case"PointLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t,shadowCameraNear:1,shadowCameraFar:1e3}}return e[n.id]=r,r}
```
</details>

### `get(n: any): any`

**Parameters:**

- **`n`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function(n){if(void 0!==e[n.id])return e[n.id];let r;switch(n.type){case"DirectionalLight":case"SpotLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t};break;case"PointLight":r={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new t,shadowCameraNear:1,shadowCameraFar:1e3}}return e[n.id]=r,r}
```
</details>

### `setup(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `a.probe[e].set`
- `t.sort`
- `a.probe[e].addScaledVector`
- `n.get`
- `e.color.copy(E.color).multiplyScalar`
- `r.get`
- `e.position.setFromMatrixPosition`
- `e.color.copy(S).multiplyScalar`
- `Math.cos`
- `t.updateMatrices`
- `e.halfWidth.set`
- `e.halfHeight.set`
- `e.skyColor.copy(E.color).multiplyScalar`
- `e.groundColor.copy(E.groundColor).multiplyScalar`
- `e.has`

<details><summary>Code</summary>

```typescript
function(t){let i=0,o=0,s=0;for(let e=0;e<9;e++)a.probe[e].set(0,0,0);let l=0,c=0,d=0,u=0,f=0,p=0,m=0,h=0,_=0,g=0,v=0;t.sort(Yi);for(let e=0,E=t.length;e<E;e++){const E=t[e],S=E.color,T=E.intensity,M=E.distance,x=E.shadow&&E.shadow.map?E.shadow.map.texture:null;if(E.isAmbientLight)i+=S.r*T,o+=S.g*T,s+=S.b*T;else if(E.isLightProbe){for(let e=0;e<9;e++)a.probe[e].addScaledVector(E.sh.coefficients[e],T);v++}else if(E.isDirectionalLight){const e=n.get(E);if(e.color.copy(E.color).multiplyScalar(E.intensity),E.castShadow){const e=E.shadow,t=r.get(E);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,a.directionalShadow[l]=t,a.directionalShadowMap[l]=x,a.directionalShadowMatrix[l]=E.shadow.matrix,p++}a.directional[l]=e,l++}else if(E.isSpotLight){const e=n.get(E);e.position.setFromMatrixPosition(E.matrixWorld),e.color.copy(S).multiplyScalar(T),e.distance=M,e.coneCos=Math.cos(E.angle),e.penumbraCos=Math.cos(E.angle*(1-E.penumbra)),e.decay=E.decay,a.spot[d]=e;const t=E.shadow;if(E.map&&(a.spotLightMap[_]=E.map,_++,t.updateMatrices(E),E.castShadow&&g++),a.spotLightMatrix[d]=t.matrix,E.castShadow){const e=r.get(E);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,a.spotShadow[d]=e,a.spotShadowMap[d]=x,h++}d++}else if(E.isRectAreaLight){const e=n.get(E);e.color.copy(S).multiplyScalar(T),e.halfWidth.set(.5*E.width,0,0),e.halfHeight.set(0,.5*E.height,0),a.rectArea[u]=e,u++}else if(E.isPointLight){const e=n.get(E);if(e.color.copy(E.color).multiplyScalar(E.intensity),e.distance=E.distance,e.decay=E.decay,E.castShadow){const e=E.shadow,t=r.get(E);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,t.shadowCameraNear=e.camera.near,t.shadowCameraFar=e.camera.far,a.pointShadow[c]=t,a.pointShadowMap[c]=x,a.pointShadowMatrix[c]=E.shadow.matrix,m++}a.point[c]=e,c++}else if(E.isHemisphereLight){const e=n.get(E);e.skyColor.copy(E.color).multiplyScalar(T),e.groundColor.copy(E.groundColor).multiplyScalar(T),a.hemi[f]=e,f++}}u>0&&(!0===e.has("OES_texture_float_linear")?(a.rectAreaLTC1=Ln.LTC_FLOAT_1,a.rectAreaLTC2=Ln.LTC_FLOAT_2):(a.rectAreaLTC1=Ln.LTC_HALF_1,a.rectAreaLTC2=Ln.LTC_HALF_2)),a.ambient[0]=i,a.ambient[1]=o,a.ambient[2]=s;const E=a.hash;E.directionalLength===l&&E.pointLength===c&&E.spotLength===d&&E.rectAreaLength===u&&E.hemiLength===f&&E.numDirectionalShadows===p&&E.numPointShadows===m&&E.numSpotShadows===h&&E.numSpotMaps===_&&E.numLightProbes===v||(a.directional.length=l,a.spot.length=d,a.rectArea.length=u,a.point.length=c,a.hemi.length=f,a.directionalShadow.length=p,a.directionalShadowMap.length=p,a.pointShadow.length=m,a.pointShadowMap.length=m,a.spotShadow.length=h,a.spotShadowMap.length=h,a.directionalShadowMatrix.length=p,a.pointShadowMatrix.length=m,a.spotLightMatrix.length=h+_-g,a.spotLightMap.length=_,a.numSpotLightShadowsWithMaps=g,a.numLightProbes=v,E.directionalLength=l,E.pointLength=c,E.spotLength=d,E.rectAreaLength=u,E.hemiLength=f,E.numDirectionalShadows=p,E.numPointShadows=m,E.numSpotShadows=h,E.numSpotMaps=_,E.numLightProbes=v,a.version=Xi++)}
```
</details>

### `setupView(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.direction.setFromMatrixPosition`
- `o.setFromMatrixPosition`
- `e.direction.sub`
- `e.direction.transformDirection`
- `e.position.setFromMatrixPosition`
- `e.position.applyMatrix4`
- `l.identity`
- `s.copy`
- `s.premultiply`
- `l.extractRotation`
- `e.halfWidth.set`
- `e.halfHeight.set`
- `e.halfWidth.applyMatrix4`
- `e.halfHeight.applyMatrix4`

<details><summary>Code</summary>

```typescript
function(e,t){let n=0,r=0,i=0,c=0,d=0;const u=t.matrixWorldInverse;for(let t=0,f=e.length;t<f;t++){const f=e[t];if(f.isDirectionalLight){const e=a.directional[n];e.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(o),e.direction.transformDirection(u),n++}else if(f.isSpotLight){const e=a.spot[i];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),e.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(o),e.direction.transformDirection(u),i++}else if(f.isRectAreaLight){const e=a.rectArea[c];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),l.identity(),s.copy(f.matrixWorld),s.premultiply(u),l.extractRotation(s),e.halfWidth.set(.5*f.width,0,0),e.halfHeight.set(0,.5*f.height,0),e.halfWidth.applyMatrix4(l),e.halfHeight.applyMatrix4(l),c++}else if(f.isPointLight){const e=a.point[r];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),r++}else if(f.isHemisphereLight){const e=a.hemi[d];e.direction.setFromMatrixPosition(f.matrixWorld),e.direction.transformDirection(u),d++}}}
```
</details>

### `setup(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `a.probe[e].set`
- `t.sort`
- `a.probe[e].addScaledVector`
- `n.get`
- `e.color.copy(E.color).multiplyScalar`
- `r.get`
- `e.position.setFromMatrixPosition`
- `e.color.copy(S).multiplyScalar`
- `Math.cos`
- `t.updateMatrices`
- `e.halfWidth.set`
- `e.halfHeight.set`
- `e.skyColor.copy(E.color).multiplyScalar`
- `e.groundColor.copy(E.groundColor).multiplyScalar`
- `e.has`

<details><summary>Code</summary>

```typescript
function(t){let i=0,o=0,s=0;for(let e=0;e<9;e++)a.probe[e].set(0,0,0);let l=0,c=0,d=0,u=0,f=0,p=0,m=0,h=0,_=0,g=0,v=0;t.sort(Yi);for(let e=0,E=t.length;e<E;e++){const E=t[e],S=E.color,T=E.intensity,M=E.distance,x=E.shadow&&E.shadow.map?E.shadow.map.texture:null;if(E.isAmbientLight)i+=S.r*T,o+=S.g*T,s+=S.b*T;else if(E.isLightProbe){for(let e=0;e<9;e++)a.probe[e].addScaledVector(E.sh.coefficients[e],T);v++}else if(E.isDirectionalLight){const e=n.get(E);if(e.color.copy(E.color).multiplyScalar(E.intensity),E.castShadow){const e=E.shadow,t=r.get(E);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,a.directionalShadow[l]=t,a.directionalShadowMap[l]=x,a.directionalShadowMatrix[l]=E.shadow.matrix,p++}a.directional[l]=e,l++}else if(E.isSpotLight){const e=n.get(E);e.position.setFromMatrixPosition(E.matrixWorld),e.color.copy(S).multiplyScalar(T),e.distance=M,e.coneCos=Math.cos(E.angle),e.penumbraCos=Math.cos(E.angle*(1-E.penumbra)),e.decay=E.decay,a.spot[d]=e;const t=E.shadow;if(E.map&&(a.spotLightMap[_]=E.map,_++,t.updateMatrices(E),E.castShadow&&g++),a.spotLightMatrix[d]=t.matrix,E.castShadow){const e=r.get(E);e.shadowIntensity=t.intensity,e.shadowBias=t.bias,e.shadowNormalBias=t.normalBias,e.shadowRadius=t.radius,e.shadowMapSize=t.mapSize,a.spotShadow[d]=e,a.spotShadowMap[d]=x,h++}d++}else if(E.isRectAreaLight){const e=n.get(E);e.color.copy(S).multiplyScalar(T),e.halfWidth.set(.5*E.width,0,0),e.halfHeight.set(0,.5*E.height,0),a.rectArea[u]=e,u++}else if(E.isPointLight){const e=n.get(E);if(e.color.copy(E.color).multiplyScalar(E.intensity),e.distance=E.distance,e.decay=E.decay,E.castShadow){const e=E.shadow,t=r.get(E);t.shadowIntensity=e.intensity,t.shadowBias=e.bias,t.shadowNormalBias=e.normalBias,t.shadowRadius=e.radius,t.shadowMapSize=e.mapSize,t.shadowCameraNear=e.camera.near,t.shadowCameraFar=e.camera.far,a.pointShadow[c]=t,a.pointShadowMap[c]=x,a.pointShadowMatrix[c]=E.shadow.matrix,m++}a.point[c]=e,c++}else if(E.isHemisphereLight){const e=n.get(E);e.skyColor.copy(E.color).multiplyScalar(T),e.groundColor.copy(E.groundColor).multiplyScalar(T),a.hemi[f]=e,f++}}u>0&&(!0===e.has("OES_texture_float_linear")?(a.rectAreaLTC1=Ln.LTC_FLOAT_1,a.rectAreaLTC2=Ln.LTC_FLOAT_2):(a.rectAreaLTC1=Ln.LTC_HALF_1,a.rectAreaLTC2=Ln.LTC_HALF_2)),a.ambient[0]=i,a.ambient[1]=o,a.ambient[2]=s;const E=a.hash;E.directionalLength===l&&E.pointLength===c&&E.spotLength===d&&E.rectAreaLength===u&&E.hemiLength===f&&E.numDirectionalShadows===p&&E.numPointShadows===m&&E.numSpotShadows===h&&E.numSpotMaps===_&&E.numLightProbes===v||(a.directional.length=l,a.spot.length=d,a.rectArea.length=u,a.point.length=c,a.hemi.length=f,a.directionalShadow.length=p,a.directionalShadowMap.length=p,a.pointShadow.length=m,a.pointShadowMap.length=m,a.spotShadow.length=h,a.spotShadowMap.length=h,a.directionalShadowMatrix.length=p,a.pointShadowMatrix.length=m,a.spotLightMatrix.length=h+_-g,a.spotLightMap.length=_,a.numSpotLightShadowsWithMaps=g,a.numLightProbes=v,E.directionalLength=l,E.pointLength=c,E.spotLength=d,E.rectAreaLength=u,E.hemiLength=f,E.numDirectionalShadows=p,E.numPointShadows=m,E.numSpotShadows=h,E.numSpotMaps=_,E.numLightProbes=v,a.version=Xi++)}
```
</details>

### `setupView(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.direction.setFromMatrixPosition`
- `o.setFromMatrixPosition`
- `e.direction.sub`
- `e.direction.transformDirection`
- `e.position.setFromMatrixPosition`
- `e.position.applyMatrix4`
- `l.identity`
- `s.copy`
- `s.premultiply`
- `l.extractRotation`
- `e.halfWidth.set`
- `e.halfHeight.set`
- `e.halfWidth.applyMatrix4`
- `e.halfHeight.applyMatrix4`

<details><summary>Code</summary>

```typescript
function(e,t){let n=0,r=0,i=0,c=0,d=0;const u=t.matrixWorldInverse;for(let t=0,f=e.length;t<f;t++){const f=e[t];if(f.isDirectionalLight){const e=a.directional[n];e.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(o),e.direction.transformDirection(u),n++}else if(f.isSpotLight){const e=a.spot[i];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),e.direction.setFromMatrixPosition(f.matrixWorld),o.setFromMatrixPosition(f.target.matrixWorld),e.direction.sub(o),e.direction.transformDirection(u),i++}else if(f.isRectAreaLight){const e=a.rectArea[c];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),l.identity(),s.copy(f.matrixWorld),s.premultiply(u),l.extractRotation(s),e.halfWidth.set(.5*f.width,0,0),e.halfHeight.set(0,.5*f.height,0),e.halfWidth.applyMatrix4(l),e.halfHeight.applyMatrix4(l),c++}else if(f.isPointLight){const e=a.point[r];e.position.setFromMatrixPosition(f.matrixWorld),e.position.applyMatrix4(u),r++}else if(f.isHemisphereLight){const e=a.hemi[d];e.direction.setFromMatrixPosition(f.matrixWorld),e.direction.transformDirection(u),d++}}}
```
</details>

### `qi(e: any): { init: (e: any) => void; state: { lightsArray: any[]; shadowsArray: any[]; camera: any; lights: any; transmissionRenderTarget: {}; }; setupLights: () => void; setupLightsView: (e: any) => void; pushLight: (e: any) => void; pushShadow: (e: any) => void; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ init: (e: any) => void; state: { lightsArray: any[]; shadowsArray: any[]; camera: any; lights: any; transmissionRenderTarget: {}; }; setupLights: () => void; setupLightsView: (e: any) => void; pushLight: (e: any) => void; pushShadow: (e: any) => void; }`

**Calls:**

- `t.setup`
- `t.setupView`
- `n.push`
- `r.push`

<details><summary>Code</summary>

```typescript
function qi(e){const t=new Ki(e),n=[],r=[];const i={lightsArray:n,shadowsArray:r,camera:null,lights:t,transmissionRenderTarget:{}};return{init:function(e){i.camera=e,n.length=0,r.length=0},state:i,setupLights:function(){t.setup(n)},setupLightsView:function(e){t.setupView(n,e)},pushLight:function(e){n.push(e)},pushShadow:function(e){r.push(e)}}}
```
</details>

### `init(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){i.camera=e,n.length=0,r.length=0}
```
</details>

### `setupLights(): void`

**Returns:** `void`

**Calls:**

- `t.setup`

<details><summary>Code</summary>

```typescript
function(){t.setup(n)}
```
</details>

### `setupLightsView(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.setupView`

<details><summary>Code</summary>

```typescript
function(e){t.setupView(n,e)}
```
</details>

### `pushLight(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `n.push`

<details><summary>Code</summary>

```typescript
function(e){n.push(e)}
```
</details>

### `pushShadow(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `r.push`

<details><summary>Code</summary>

```typescript
function(e){r.push(e)}
```
</details>

### `init(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){i.camera=e,n.length=0,r.length=0}
```
</details>

### `setupLights(): void`

**Returns:** `void`

**Calls:**

- `t.setup`

<details><summary>Code</summary>

```typescript
function(){t.setup(n)}
```
</details>

### `setupLightsView(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.setupView`

<details><summary>Code</summary>

```typescript
function(e){t.setupView(n,e)}
```
</details>

### `pushLight(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `n.push`

<details><summary>Code</summary>

```typescript
function(e){n.push(e)}
```
</details>

### `pushShadow(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `r.push`

<details><summary>Code</summary>

```typescript
function(e){r.push(e)}
```
</details>

### `ji(e: any): { get: (n: any, r?: number) => any; dispose: () => void; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ get: (n: any, r?: number) => any; dispose: () => void; }`

**Calls:**

- `t.get`
- `t.set`
- `i.push`

<details><summary>Code</summary>

```typescript
function ji(e){let t=new WeakMap;return{get:function(n,r=0){const i=t.get(n);let a;return void 0===i?(a=new qi(e),t.set(n,[a])):r>=i.length?(a=new qi(e),i.push(a)):a=i[r],a},dispose:function(){t=new WeakMap}}}
```
</details>

### `get(n: any, r: number): any`

**Parameters:**

- **`n`** `any`
- **`r`** `number`

**Returns:** `any`

**Calls:**

- `t.get`
- `t.set`
- `i.push`

<details><summary>Code</summary>

```typescript
function(n,r=0){const i=t.get(n);let a;return void 0===i?(a=new qi(e),t.set(n,[a])):r>=i.length?(a=new qi(e),i.push(a)):a=i[r],a}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=new WeakMap}
```
</details>

### `get(n: any, r: number): any`

**Parameters:**

- **`n`** `any`
- **`r`** `number`

**Returns:** `any`

**Calls:**

- `t.get`
- `t.set`
- `i.push`

<details><summary>Code</summary>

```typescript
function(n,r=0){const i=t.get(n);let a;return void 0===i?(a=new qi(e),t.set(n,[a])):r>=i.length?(a=new qi(e),i.push(a)):a=i[r],a}
```
</details>

### `dispose(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=new WeakMap}
```
</details>

### `Zi(e: any, n: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `g.clone`
- `E.setAttribute`
- `n.update`
- `e.setRenderTarget`
- `e.clear`
- `e.renderBufferDirect`
- `Array.isArray`
- `a.clone`
- `n.addEventListener`
- `e.properties.get`
- `t.layers.test`
- `i.intersectsObject`
- `t.modelViewMatrix.multiplyMatrices`
- `R`
- `t.onBeforeShadow`
- `t.onAfterShadow`
- `A`
- `e.target.removeEventListener`
- `n[r].dispose`
- `e.getRenderTarget`
- `e.getActiveCubeFace`
- `e.getActiveMipmapLevel`
- `u.setBlending`
- `u.buffers.depth.getReversed`
- `u.buffers.color.setClear`
- `u.buffers.depth.setTest`
- `u.setScissorTest`
- `console.warn`
- `a.copy`
- `c.getFrameExtents`
- `a.multiply`
- `s.copy`
- `Math.floor`
- `c.map.dispose`
- `c.camera.updateProjectionMatrix`
- `c.getViewportCount`
- `c.getViewport`
- `d.set`
- `u.viewport`
- `c.updateMatrices`
- `c.getFrustum`
- `x`

<details><summary>Code</summary>

```typescript
function Zi(e,n,r){let i=new ge;const a=new t,s=new t,d=new k,u=new ve({depthPacking:Ee}),f=new Se,p={},m=r.maxTextureSize,h={[_]:c,[c]:_,[fe]:fe},g=new l({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new t},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),v=g.clone();v.defines.HORIZONTAL_PASS=1;const E=new N;E.setAttribute("position",new O(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const S=new o(E,g),T=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=$;let M=this.type;function x(t,r){const i=n.update(S);g.defines.VSM_SAMPLES!==t.blurSamples&&(g.defines.VSM_SAMPLES=t.blurSamples,v.defines.VSM_SAMPLES=t.blurSamples,g.needsUpdate=!0,v.needsUpdate=!0),null===t.mapPass&&(t.mapPass=new I(a.x,a.y)),g.uniforms.shadow_pass.value=t.map.texture,g.uniforms.resolution.value=t.mapSize,g.uniforms.radius.value=t.radius,e.setRenderTarget(t.mapPass),e.clear(),e.renderBufferDirect(r,null,i,g,S,null),v.uniforms.shadow_pass.value=t.mapPass.texture,v.uniforms.resolution.value=t.mapSize,v.uniforms.radius.value=t.radius,e.setRenderTarget(t.map),e.clear(),e.renderBufferDirect(r,null,i,v,S,null)}function R(t,n,r,i){let a=null;const o=!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(void 0!==o)a=o;else if(a=!0===r.isPointLight?f:u,e.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0||!0===n.alphaToCoverage){const e=a.uuid,t=n.uuid;let r=p[e];void 0===r&&(r={},p[e]=r);let i=r[t];void 0===i&&(i=a.clone(),r[t]=i,n.addEventListener("dispose",b)),a=i}if(a.visible=n.visible,a.wireframe=n.wireframe,a.side=i===J?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:h[n.side],a.alphaMap=n.alphaMap,a.alphaTest=!0===n.alphaToCoverage?.5:n.alphaTest,a.map=n.map,a.clipShadows=n.clipShadows,a.clippingPlanes=n.clippingPlanes,a.clipIntersection=n.clipIntersection,a.displacementMap=n.displacementMap,a.displacementScale=n.displacementScale,a.displacementBias=n.displacementBias,a.wireframeLinewidth=n.wireframeLinewidth,a.linewidth=n.linewidth,!0===r.isPointLight&&!0===a.isMeshDistanceMaterial){e.properties.get(a).light=r}return a}function A(t,r,a,o,s){if(!1===t.visible)return;if(t.layers.test(r.layers)&&(t.isMesh||t.isLine||t.isPoints)&&(t.castShadow||t.receiveShadow&&s===J)&&(!t.frustumCulled||i.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,t.matrixWorld);const i=n.update(t),l=t.material;if(Array.isArray(l)){const n=i.groups;for(let c=0,d=n.length;c<d;c++){const d=n[c],u=l[d.materialIndex];if(u&&u.visible){const n=R(t,u,o,s);t.onBeforeShadow(e,t,r,a,i,n,d),e.renderBufferDirect(a,null,i,n,t,d),t.onAfterShadow(e,t,r,a,i,n,d)}}}else if(l.visible){const n=R(t,l,o,s);t.onBeforeShadow(e,t,r,a,i,n,null),e.renderBufferDirect(a,null,i,n,t,null),t.onAfterShadow(e,t,r,a,i,n,null)}}const l=t.children;for(let e=0,t=l.length;e<t;e++)A(l[e],r,a,o,s)}function b(e){e.target.removeEventListener("dispose",b);for(const t in p){const n=p[t],r=e.target.uuid;if(r in n){n[r].dispose(),delete n[r]}}}this.render=function(t,n,r){if(!1===T.enabled)return;if(!1===T.autoUpdate&&!1===T.needsUpdate)return;if(0===t.length)return;const o=e.getRenderTarget(),l=e.getActiveCubeFace(),c=e.getActiveMipmapLevel(),u=e.state;u.setBlending(y),!0===u.buffers.depth.getReversed()?u.buffers.color.setClear(0,0,0,0):u.buffers.color.setClear(1,1,1,1),u.buffers.depth.setTest(!0),u.setScissorTest(!1);const f=M!==J&&this.type===J,p=M===J&&this.type!==J;for(let o=0,l=t.length;o<l;o++){const l=t[o],c=l.shadow;if(void 0===c){console.warn("THREE.WebGLShadowMap:",l,"has no shadow.");continue}if(!1===c.autoUpdate&&!1===c.needsUpdate)continue;a.copy(c.mapSize);const h=c.getFrameExtents();if(a.multiply(h),s.copy(c.mapSize),(a.x>m||a.y>m)&&(a.x>m&&(s.x=Math.floor(m/h.x),a.x=s.x*h.x,c.mapSize.x=s.x),a.y>m&&(s.y=Math.floor(m/h.y),a.y=s.y*h.y,c.mapSize.y=s.y)),null===c.map||!0===f||!0===p){const e=this.type!==J?{minFilter:Te,magFilter:Te}:{};null!==c.map&&c.map.dispose(),c.map=new I(a.x,a.y,e),c.map.texture.name=l.name+".shadowMap",c.camera.updateProjectionMatrix()}e.setRenderTarget(c.map),e.clear();const _=c.getViewportCount();for(let e=0;e<_;e++){const t=c.getViewport(e);d.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w),u.viewport(d),c.updateMatrices(l,e),i=c.getFrustum(),A(n,r,c.camera,l,this.type)}!0!==c.isPointLightShadow&&this.type===J&&x(c,r),c.needsUpdate=!1}M=this.type,T.needsUpdate=!1,e.setRenderTarget(o,l,c)}}
```
</details>

### `x(t: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `n.update`
- `e.setRenderTarget`
- `e.clear`
- `e.renderBufferDirect`

<details><summary>Code</summary>

```typescript
function x(t,r){const i=n.update(S);g.defines.VSM_SAMPLES!==t.blurSamples&&(g.defines.VSM_SAMPLES=t.blurSamples,v.defines.VSM_SAMPLES=t.blurSamples,g.needsUpdate=!0,v.needsUpdate=!0),null===t.mapPass&&(t.mapPass=new I(a.x,a.y)),g.uniforms.shadow_pass.value=t.map.texture,g.uniforms.resolution.value=t.mapSize,g.uniforms.radius.value=t.radius,e.setRenderTarget(t.mapPass),e.clear(),e.renderBufferDirect(r,null,i,g,S,null),v.uniforms.shadow_pass.value=t.mapPass.texture,v.uniforms.resolution.value=t.mapSize,v.uniforms.radius.value=t.radius,e.setRenderTarget(t.map),e.clear(),e.renderBufferDirect(r,null,i,v,S,null)}
```
</details>

### `R(t: any, n: any, r: any, i: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `any`

**Calls:**

- `Array.isArray`
- `a.clone`
- `n.addEventListener`
- `e.properties.get`

<details><summary>Code</summary>

```typescript
function R(t,n,r,i){let a=null;const o=!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(void 0!==o)a=o;else if(a=!0===r.isPointLight?f:u,e.localClippingEnabled&&!0===n.clipShadows&&Array.isArray(n.clippingPlanes)&&0!==n.clippingPlanes.length||n.displacementMap&&0!==n.displacementScale||n.alphaMap&&n.alphaTest>0||n.map&&n.alphaTest>0||!0===n.alphaToCoverage){const e=a.uuid,t=n.uuid;let r=p[e];void 0===r&&(r={},p[e]=r);let i=r[t];void 0===i&&(i=a.clone(),r[t]=i,n.addEventListener("dispose",b)),a=i}if(a.visible=n.visible,a.wireframe=n.wireframe,a.side=i===J?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:h[n.side],a.alphaMap=n.alphaMap,a.alphaTest=!0===n.alphaToCoverage?.5:n.alphaTest,a.map=n.map,a.clipShadows=n.clipShadows,a.clippingPlanes=n.clippingPlanes,a.clipIntersection=n.clipIntersection,a.displacementMap=n.displacementMap,a.displacementScale=n.displacementScale,a.displacementBias=n.displacementBias,a.wireframeLinewidth=n.wireframeLinewidth,a.linewidth=n.linewidth,!0===r.isPointLight&&!0===a.isMeshDistanceMaterial){e.properties.get(a).light=r}return a}
```
</details>

### `A(t: any, r: any, a: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `t.layers.test`
- `i.intersectsObject`
- `t.modelViewMatrix.multiplyMatrices`
- `n.update`
- `Array.isArray`
- `R`
- `t.onBeforeShadow`
- `e.renderBufferDirect`
- `t.onAfterShadow`
- `A`

<details><summary>Code</summary>

```typescript
function A(t,r,a,o,s){if(!1===t.visible)return;if(t.layers.test(r.layers)&&(t.isMesh||t.isLine||t.isPoints)&&(t.castShadow||t.receiveShadow&&s===J)&&(!t.frustumCulled||i.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,t.matrixWorld);const i=n.update(t),l=t.material;if(Array.isArray(l)){const n=i.groups;for(let c=0,d=n.length;c<d;c++){const d=n[c],u=l[d.materialIndex];if(u&&u.visible){const n=R(t,u,o,s);t.onBeforeShadow(e,t,r,a,i,n,d),e.renderBufferDirect(a,null,i,n,t,d),t.onAfterShadow(e,t,r,a,i,n,d)}}}else if(l.visible){const n=R(t,l,o,s);t.onBeforeShadow(e,t,r,a,i,n,null),e.renderBufferDirect(a,null,i,n,t,null),t.onAfterShadow(e,t,r,a,i,n,null)}}const l=t.children;for(let e=0,t=l.length;e<t;e++)A(l[e],r,a,o,s)}
```
</details>

### `b(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `e.target.removeEventListener`
- `n[r].dispose`

<details><summary>Code</summary>

```typescript
function b(e){e.target.removeEventListener("dispose",b);for(const t in p){const n=p[t],r=e.target.uuid;if(r in n){n[r].dispose(),delete n[r]}}}
```
</details>

### `Qi(e: any, t: any): { buffers: { color: any; depth: any; stencil: any; }; enable: (t: any) => void; disable: (t: any) => void; bindFramebuffer: (t: any, n: any) => boolean; drawBuffers: (t: any, n: any) => void; useProgram: (t: any) => boolean; ... 24 more ...; reset: () => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `{ buffers: { color: any; depth: any; stencil: any; }; enable: (t: any) => void; disable: (t: any) => void; bindFramebuffer: (t: any, n: any) => boolean; drawBuffers: (t: any, n: any) => void; useProgram: (t: any) => boolean; ... 24 more ...; reset: () => void; }`

**Calls:**

- `e.colorMask`
- `n.set`
- `i.equals`
- `e.clearColor`
- `i.copy`
- `i.set`
- `t.get`
- `n.clipControlEXT`
- `this.setClear`
- `W`
- `X`
- `e.depthMask`
- `e.depthFunc`
- `e.clearDepth`
- `e.stencilMask`
- `e.stencilFunc`
- `e.stencilOp`
- `e.clearStencil`
- `e.getParameter`
- `I.indexOf`
- `parseFloat`
- `/^WebGL (\d)/.exec`
- `/^OpenGL ES (\d)/.exec`
- `(new k).fromArray`
- `e.createTexture`
- `e.bindTexture`
- `e.texParameteri`
- `e.texImage3D`
- `e.texImage2D`
- `e.enable`
- `e.disable`
- `V`
- `r.setClear`
- `i.setClear`
- `a.setClear`
- `i.setFunc`
- `j`
- `Z`
- `q`
- `e.blendEquationSeparate`
- `e.blendFuncSeparate`
- `l.equals`
- `e.blendColor`
- `M.copy`
- `e.blendEquation`
- `e.blendFunc`
- `console.error`
- `M.set`
- `e.frontFace`
- `e.cullFace`
- `e.polygonOffset`
- `e.bindFramebuffer`
- `u.get`
- `u.set`
- `e.drawBuffers`
- `e.useProgram`
- `i.setTest`
- `i.setMask`
- `r.setMask`
- `a.setTest`
- `a.setMask`
- `a.setFunc`
- `a.setOp`
- `$`
- `e.lineWidth`
- `e.activeTexture`
- `e.compressedTexImage2D`
- `e.compressedTexImage3D`
- `s.get`
- `s.set`
- `r.get`
- `e.getUniformBlockIndex`
- `r.set`
- `s.get(n).get`
- `o.get`
- `e.uniformBlockBinding`
- `o.set`
- `e.texStorage2D`
- `e.texStorage3D`
- `e.texSubImage2D`
- `e.texSubImage3D`
- `e.compressedTexSubImage2D`
- `e.compressedTexSubImage3D`
- `H.equals`
- `e.scissor`
- `H.copy`
- `G.equals`
- `e.viewport`
- `G.copy`
- `i.setReversed`
- `H.set`
- `G.set`
- `r.reset`
- `i.reset`
- `a.reset`

<details><summary>Code</summary>

```typescript
function Qi(e,t){const r=new function(){let t=!1;const n=new k;let r=null;const i=new k(0,0,0,0);return{setMask:function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)},setLocked:function(e){t=e},setClear:function(t,r,a,o,s){!0===s&&(t*=o,r*=o,a*=o),n.set(t,r,a,o),!1===i.equals(n)&&(e.clearColor(t,r,a,o),i.copy(n))},reset:function(){t=!1,r=null,i.set(-1,0,0,0)}}},i=new function(){let n=!1,r=!1,i=null,a=null,o=null;return{setReversed:function(e){if(r!==e){const n=t.get("EXT_clip_control");e?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),r=e;const i=o;o=null,this.setClear(i)}},getReversed:function(){return r},setTest:function(t){t?W(e.DEPTH_TEST):X(e.DEPTH_TEST)},setMask:function(t){i===t||n||(e.depthMask(t),i=t)},setFunc:function(t){if(r&&(t=$i[t]),a!==t){switch(t){case Ke:e.depthFunc(e.NEVER);break;case Ye:e.depthFunc(e.ALWAYS);break;case Xe:e.depthFunc(e.LESS);break;case Me:e.depthFunc(e.LEQUAL);break;case We:e.depthFunc(e.EQUAL);break;case ke:e.depthFunc(e.GEQUAL);break;case ze:e.depthFunc(e.GREATER);break;case Ve:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}a=t}},setLocked:function(e){n=e},setClear:function(t){o!==t&&(r&&(t=1-t),e.clearDepth(t),o=t)},reset:function(){n=!1,i=null,a=null,o=null,r=!1}}},a=new function(){let t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=null;return{setTest:function(n){t||(n?W(e.STENCIL_TEST):X(e.STENCIL_TEST))},setMask:function(r){n===r||t||(e.stencilMask(r),n=r)},setFunc:function(t,n,o){r===t&&i===n&&a===o||(e.stencilFunc(t,n,o),r=t,i=n,a=o)},setOp:function(t,n,r){o===t&&s===n&&l===r||(e.stencilOp(t,n,r),o=t,s=n,l=r)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=null}}},o=new WeakMap,s=new WeakMap;let l={},d={},u=new WeakMap,f=[],p=null,m=!1,h=null,_=null,g=null,v=null,E=null,S=null,T=null,M=new n(0,0,0),x=0,R=!1,A=null,b=null,C=null,L=null,P=null;const U=e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let D=!1,w=0;const I=e.getParameter(e.VERSION);-1!==I.indexOf("WebGL")?(w=parseFloat(/^WebGL (\d)/.exec(I)[1]),D=w>=1):-1!==I.indexOf("OpenGL ES")&&(w=parseFloat(/^OpenGL ES (\d)/.exec(I)[1]),D=w>=2);let N=null,O={};const F=e.getParameter(e.SCISSOR_BOX),B=e.getParameter(e.VIEWPORT),H=(new k).fromArray(F),G=(new k).fromArray(B);function V(t,n,r,i){const a=new Uint8Array(4),o=e.createTexture();e.bindTexture(t,o),e.texParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST);for(let o=0;o<r;o++)t===e.TEXTURE_3D||t===e.TEXTURE_2D_ARRAY?e.texImage3D(n,0,e.RGBA,1,1,i,0,e.RGBA,e.UNSIGNED_BYTE,a):e.texImage2D(n+o,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,a);return o}const z={};function W(t){!0!==l[t]&&(e.enable(t),l[t]=!0)}function X(t){!1!==l[t]&&(e.disable(t),l[t]=!1)}z[e.TEXTURE_2D]=V(e.TEXTURE_2D,e.TEXTURE_2D,1),z[e.TEXTURE_CUBE_MAP]=V(e.TEXTURE_CUBE_MAP,e.TEXTURE_CUBE_MAP_POSITIVE_X,6),z[e.TEXTURE_2D_ARRAY]=V(e.TEXTURE_2D_ARRAY,e.TEXTURE_2D_ARRAY,1,1),z[e.TEXTURE_3D]=V(e.TEXTURE_3D,e.TEXTURE_3D,1,1),r.setClear(0,0,0,1),i.setClear(1),a.setClear(0),W(e.DEPTH_TEST),i.setFunc(Me),j(!1),Z(je),W(e.CULL_FACE),q(y);const Y={[Ae]:e.FUNC_ADD,[Re]:e.FUNC_SUBTRACT,[xe]:e.FUNC_REVERSE_SUBTRACT};Y[tt]=e.MIN,Y[nt]=e.MAX;const K={[Ge]:e.ZERO,[He]:e.ONE,[Be]:e.SRC_COLOR,[Fe]:e.SRC_ALPHA,[Oe]:e.SRC_ALPHA_SATURATE,[Ne]:e.DST_COLOR,[Ie]:e.DST_ALPHA,[ye]:e.ONE_MINUS_SRC_COLOR,[we]:e.ONE_MINUS_SRC_ALPHA,[De]:e.ONE_MINUS_DST_COLOR,[Ue]:e.ONE_MINUS_DST_ALPHA,[Pe]:e.CONSTANT_COLOR,[Le]:e.ONE_MINUS_CONSTANT_COLOR,[Ce]:e.CONSTANT_ALPHA,[be]:e.ONE_MINUS_CONSTANT_ALPHA};function q(t,n,r,i,a,o,s,l,c,d){if(t!==y){if(!1===m&&(W(e.BLEND),m=!0),t===$e)a=a||n,o=o||r,s=s||i,n===_&&a===E||(e.blendEquationSeparate(Y[n],Y[a]),_=n,E=a),r===g&&i===v&&o===S&&s===T||(e.blendFuncSeparate(K[r],K[i],K[o],K[s]),g=r,v=i,S=o,T=s),!1!==l.equals(M)&&c===x||(e.blendColor(l.r,l.g,l.b,c),M.copy(l),x=c),h=t,R=!1;else if(t!==h||d!==R){if(_===Ae&&E===Ae||(e.blendEquation(e.FUNC_ADD),_=Ae,E=Ae),d)switch(t){case pe:e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case et:e.blendFunc(e.ONE,e.ONE);break;case Je:e.blendFuncSeparate(e.ZERO,e.ONE_MINUS_SRC_COLOR,e.ZERO,e.ONE);break;case Qe:e.blendFuncSeparate(e.DST_COLOR,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case pe:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case et:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE,e.ONE,e.ONE);break;case Je:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case Qe:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}g=null,v=null,S=null,T=null,M.set(0,0,0),x=0,h=t,R=d}}else!0===m&&(X(e.BLEND),m=!1)}function j(t){A!==t&&(t?e.frontFace(e.CW):e.frontFace(e.CCW),A=t)}function Z(t){t!==qe?(W(e.CULL_FACE),t!==b&&(t===je?e.cullFace(e.BACK):t===Ze?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):X(e.CULL_FACE),b=t}function $(t,n,r){t?(W(e.POLYGON_OFFSET_FILL),L===n&&P===r||(e.polygonOffset(n,r),L=n,P=r)):X(e.POLYGON_OFFSET_FILL)}return{buffers:{color:r,depth:i,stencil:a},enable:W,disable:X,bindFramebuffer:function(t,n){return d[t]!==n&&(e.bindFramebuffer(t,n),d[t]=n,t===e.DRAW_FRAMEBUFFER&&(d[e.FRAMEBUFFER]=n),t===e.FRAMEBUFFER&&(d[e.DRAW_FRAMEBUFFER]=n),!0)},drawBuffers:function(t,n){let r=f,i=!1;if(t){r=u.get(n),void 0===r&&(r=[],u.set(n,r));const a=t.textures;if(r.length!==a.length||r[0]!==e.COLOR_ATTACHMENT0){for(let t=0,n=a.length;t<n;t++)r[t]=e.COLOR_ATTACHMENT0+t;r.length=a.length,i=!0}}else r[0]!==e.BACK&&(r[0]=e.BACK,i=!0);i&&e.drawBuffers(r)},useProgram:function(t){return p!==t&&(e.useProgram(t),p=t,!0)},setBlending:q,setMaterial:function(t,n){t.side===fe?X(e.CULL_FACE):W(e.CULL_FACE);let o=t.side===c;n&&(o=!o),j(o),t.blending===pe&&!1===t.transparent?q(y):q(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.blendColor,t.blendAlpha,t.premultipliedAlpha),i.setFunc(t.depthFunc),i.setTest(t.depthTest),i.setMask(t.depthWrite),r.setMask(t.colorWrite);const s=t.stencilWrite;a.setTest(s),s&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),$(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?W(e.SAMPLE_ALPHA_TO_COVERAGE):X(e.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided:j,setCullFace:Z,setLineWidth:function(t){t!==C&&(D&&e.lineWidth(t),C=t)},setPolygonOffset:$,setScissorTest:function(t){t?W(e.SCISSOR_TEST):X(e.SCISSOR_TEST)},activeTexture:function(t){void 0===t&&(t=e.TEXTURE0+U-1),N!==t&&(e.activeTexture(t),N=t)},bindTexture:function(t,n,r){void 0===r&&(r=null===N?e.TEXTURE0+U-1:N);let i=O[r];void 0===i&&(i={type:void 0,texture:void 0},O[r]=i),i.type===t&&i.texture===n||(N!==r&&(e.activeTexture(r),N=r),e.bindTexture(t,n||z[t]),i.type=t,i.texture=n)},unbindTexture:function(){const t=O[N];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexImage3D:function(){try{e.compressedTexImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},updateUBOMapping:function(t,n){let r=s.get(n);void 0===r&&(r=new WeakMap,s.set(n,r));let i=r.get(t);void 0===i&&(i=e.getUniformBlockIndex(n,t.name),r.set(t,i))},uniformBlockBinding:function(t,n){const r=s.get(n).get(t);o.get(n)!==r&&(e.uniformBlockBinding(n,r,t.__bindingPointIndex),o.set(n,r))},texStorage2D:function(){try{e.texStorage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{e.texStorage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{e.texSubImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{e.texSubImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{e.compressedTexSubImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage3D:function(){try{e.compressedTexSubImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(t){!1===H.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),H.copy(t))},viewport:function(t){!1===G.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),G.copy(t))},reset:function(){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.blendColor(0,0,0,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),i.setReversed(!1),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.bindFramebuffer(e.READ_FRAMEBUFFER,null),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),l={},N=null,O={},d={},u=new WeakMap,f=[],p=null,m=!1,h=null,_=null,g=null,v=null,E=null,S=null,T=null,M=new n(0,0,0),x=0,R=!1,A=null,b=null,C=null,L=null,P=null,H.set(0,0,e.canvas.width,e.canvas.height),G.set(0,0,e.canvas.width,e.canvas.height),r.reset(),i.reset(),a.reset()}}}
```
</details>

### `setMask(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.colorMask`

<details><summary>Code</summary>

```typescript
function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any, r: any, a: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `n.set`
- `i.equals`
- `e.clearColor`
- `i.copy`

<details><summary>Code</summary>

```typescript
function(t,r,a,o,s){!0===s&&(t*=o,r*=o,a*=o),n.set(t,r,a,o),!1===i.equals(n)&&(e.clearColor(t,r,a,o),i.copy(n))}
```
</details>

### `reset(): void`

**Returns:** `void`

**Calls:**

- `i.set`

<details><summary>Code</summary>

```typescript
function(){t=!1,r=null,i.set(-1,0,0,0)}
```
</details>

### `setMask(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.colorMask`

<details><summary>Code</summary>

```typescript
function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any, r: any, a: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `n.set`
- `i.equals`
- `e.clearColor`
- `i.copy`

<details><summary>Code</summary>

```typescript
function(t,r,a,o,s){!0===s&&(t*=o,r*=o,a*=o),n.set(t,r,a,o),!1===i.equals(n)&&(e.clearColor(t,r,a,o),i.copy(n))}
```
</details>

### `reset(): void`

**Returns:** `void`

**Calls:**

- `i.set`

<details><summary>Code</summary>

```typescript
function(){t=!1,r=null,i.set(-1,0,0,0)}
```
</details>

### `setReversed(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.get`
- `n.clipControlEXT`
- `this.setClear`

<details><summary>Code</summary>

```typescript
function(e){if(r!==e){const n=t.get("EXT_clip_control");e?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),r=e;const i=o;o=null,this.setClear(i)}}
```
</details>

### `getReversed(): boolean`

**Returns:** `boolean`

<details><summary>Code</summary>

```typescript
function(){return r}
```
</details>

### `setTest(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(t){t?W(e.DEPTH_TEST):X(e.DEPTH_TEST)}
```
</details>

### `setMask(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthMask`

<details><summary>Code</summary>

```typescript
function(t){i===t||n||(e.depthMask(t),i=t)}
```
</details>

### `setFunc(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthFunc`

<details><summary>Code</summary>

```typescript
function(t){if(r&&(t=$i[t]),a!==t){switch(t){case Ke:e.depthFunc(e.NEVER);break;case Ye:e.depthFunc(e.ALWAYS);break;case Xe:e.depthFunc(e.LESS);break;case Me:e.depthFunc(e.LEQUAL);break;case We:e.depthFunc(e.EQUAL);break;case ke:e.depthFunc(e.GEQUAL);break;case ze:e.depthFunc(e.GREATER);break;case Ve:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}a=t}}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){n=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearDepth`

<details><summary>Code</summary>

```typescript
function(t){o!==t&&(r&&(t=1-t),e.clearDepth(t),o=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){n=!1,i=null,a=null,o=null,r=!1}
```
</details>

### `setReversed(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.get`
- `n.clipControlEXT`
- `this.setClear`

<details><summary>Code</summary>

```typescript
function(e){if(r!==e){const n=t.get("EXT_clip_control");e?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),r=e;const i=o;o=null,this.setClear(i)}}
```
</details>

### `getReversed(): boolean`

**Returns:** `boolean`

<details><summary>Code</summary>

```typescript
function(){return r}
```
</details>

### `setTest(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(t){t?W(e.DEPTH_TEST):X(e.DEPTH_TEST)}
```
</details>

### `setMask(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthMask`

<details><summary>Code</summary>

```typescript
function(t){i===t||n||(e.depthMask(t),i=t)}
```
</details>

### `setFunc(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthFunc`

<details><summary>Code</summary>

```typescript
function(t){if(r&&(t=$i[t]),a!==t){switch(t){case Ke:e.depthFunc(e.NEVER);break;case Ye:e.depthFunc(e.ALWAYS);break;case Xe:e.depthFunc(e.LESS);break;case Me:e.depthFunc(e.LEQUAL);break;case We:e.depthFunc(e.EQUAL);break;case ke:e.depthFunc(e.GEQUAL);break;case ze:e.depthFunc(e.GREATER);break;case Ve:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}a=t}}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){n=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearDepth`

<details><summary>Code</summary>

```typescript
function(t){o!==t&&(r&&(t=1-t),e.clearDepth(t),o=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){n=!1,i=null,a=null,o=null,r=!1}
```
</details>

### `setTest(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(n){t||(n?W(e.STENCIL_TEST):X(e.STENCIL_TEST))}
```
</details>

### `setMask(r: any): void`

**Parameters:**

- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilMask`

<details><summary>Code</summary>

```typescript
function(r){n===r||t||(e.stencilMask(r),n=r)}
```
</details>

### `setFunc(t: any, n: any, o: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`o`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilFunc`

<details><summary>Code</summary>

```typescript
function(t,n,o){r===t&&i===n&&a===o||(e.stencilFunc(t,n,o),r=t,i=n,a=o)}
```
</details>

### `setOp(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilOp`

<details><summary>Code</summary>

```typescript
function(t,n,r){o===t&&s===n&&l===r||(e.stencilOp(t,n,r),o=t,s=n,l=r)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearStencil`

<details><summary>Code</summary>

```typescript
function(t){c!==t&&(e.clearStencil(t),c=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=null}
```
</details>

### `setTest(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(n){t||(n?W(e.STENCIL_TEST):X(e.STENCIL_TEST))}
```
</details>

### `setMask(r: any): void`

**Parameters:**

- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilMask`

<details><summary>Code</summary>

```typescript
function(r){n===r||t||(e.stencilMask(r),n=r)}
```
</details>

### `setFunc(t: any, n: any, o: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`o`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilFunc`

<details><summary>Code</summary>

```typescript
function(t,n,o){r===t&&i===n&&a===o||(e.stencilFunc(t,n,o),r=t,i=n,a=o)}
```
</details>

### `setOp(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilOp`

<details><summary>Code</summary>

```typescript
function(t,n,r){o===t&&s===n&&l===r||(e.stencilOp(t,n,r),o=t,s=n,l=r)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearStencil`

<details><summary>Code</summary>

```typescript
function(t){c!==t&&(e.clearStencil(t),c=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=null}
```
</details>

### `setMask(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.colorMask`

<details><summary>Code</summary>

```typescript
function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any, r: any, a: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `n.set`
- `i.equals`
- `e.clearColor`
- `i.copy`

<details><summary>Code</summary>

```typescript
function(t,r,a,o,s){!0===s&&(t*=o,r*=o,a*=o),n.set(t,r,a,o),!1===i.equals(n)&&(e.clearColor(t,r,a,o),i.copy(n))}
```
</details>

### `reset(): void`

**Returns:** `void`

**Calls:**

- `i.set`

<details><summary>Code</summary>

```typescript
function(){t=!1,r=null,i.set(-1,0,0,0)}
```
</details>

### `setMask(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `e.colorMask`

<details><summary>Code</summary>

```typescript
function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any, r: any, a: any, o: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `n.set`
- `i.equals`
- `e.clearColor`
- `i.copy`

<details><summary>Code</summary>

```typescript
function(t,r,a,o,s){!0===s&&(t*=o,r*=o,a*=o),n.set(t,r,a,o),!1===i.equals(n)&&(e.clearColor(t,r,a,o),i.copy(n))}
```
</details>

### `reset(): void`

**Returns:** `void`

**Calls:**

- `i.set`

<details><summary>Code</summary>

```typescript
function(){t=!1,r=null,i.set(-1,0,0,0)}
```
</details>

### `setReversed(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.get`
- `n.clipControlEXT`
- `this.setClear`

<details><summary>Code</summary>

```typescript
function(e){if(r!==e){const n=t.get("EXT_clip_control");e?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),r=e;const i=o;o=null,this.setClear(i)}}
```
</details>

### `getReversed(): boolean`

**Returns:** `boolean`

<details><summary>Code</summary>

```typescript
function(){return r}
```
</details>

### `setTest(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(t){t?W(e.DEPTH_TEST):X(e.DEPTH_TEST)}
```
</details>

### `setMask(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthMask`

<details><summary>Code</summary>

```typescript
function(t){i===t||n||(e.depthMask(t),i=t)}
```
</details>

### `setFunc(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthFunc`

<details><summary>Code</summary>

```typescript
function(t){if(r&&(t=$i[t]),a!==t){switch(t){case Ke:e.depthFunc(e.NEVER);break;case Ye:e.depthFunc(e.ALWAYS);break;case Xe:e.depthFunc(e.LESS);break;case Me:e.depthFunc(e.LEQUAL);break;case We:e.depthFunc(e.EQUAL);break;case ke:e.depthFunc(e.GEQUAL);break;case ze:e.depthFunc(e.GREATER);break;case Ve:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}a=t}}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){n=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearDepth`

<details><summary>Code</summary>

```typescript
function(t){o!==t&&(r&&(t=1-t),e.clearDepth(t),o=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){n=!1,i=null,a=null,o=null,r=!1}
```
</details>

### `setReversed(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.get`
- `n.clipControlEXT`
- `this.setClear`

<details><summary>Code</summary>

```typescript
function(e){if(r!==e){const n=t.get("EXT_clip_control");e?n.clipControlEXT(n.LOWER_LEFT_EXT,n.ZERO_TO_ONE_EXT):n.clipControlEXT(n.LOWER_LEFT_EXT,n.NEGATIVE_ONE_TO_ONE_EXT),r=e;const i=o;o=null,this.setClear(i)}}
```
</details>

### `getReversed(): boolean`

**Returns:** `boolean`

<details><summary>Code</summary>

```typescript
function(){return r}
```
</details>

### `setTest(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(t){t?W(e.DEPTH_TEST):X(e.DEPTH_TEST)}
```
</details>

### `setMask(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthMask`

<details><summary>Code</summary>

```typescript
function(t){i===t||n||(e.depthMask(t),i=t)}
```
</details>

### `setFunc(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.depthFunc`

<details><summary>Code</summary>

```typescript
function(t){if(r&&(t=$i[t]),a!==t){switch(t){case Ke:e.depthFunc(e.NEVER);break;case Ye:e.depthFunc(e.ALWAYS);break;case Xe:e.depthFunc(e.LESS);break;case Me:e.depthFunc(e.LEQUAL);break;case We:e.depthFunc(e.EQUAL);break;case ke:e.depthFunc(e.GEQUAL);break;case ze:e.depthFunc(e.GREATER);break;case Ve:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}a=t}}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){n=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearDepth`

<details><summary>Code</summary>

```typescript
function(t){o!==t&&(r&&(t=1-t),e.clearDepth(t),o=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){n=!1,i=null,a=null,o=null,r=!1}
```
</details>

### `setTest(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(n){t||(n?W(e.STENCIL_TEST):X(e.STENCIL_TEST))}
```
</details>

### `setMask(r: any): void`

**Parameters:**

- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilMask`

<details><summary>Code</summary>

```typescript
function(r){n===r||t||(e.stencilMask(r),n=r)}
```
</details>

### `setFunc(t: any, n: any, o: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`o`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilFunc`

<details><summary>Code</summary>

```typescript
function(t,n,o){r===t&&i===n&&a===o||(e.stencilFunc(t,n,o),r=t,i=n,a=o)}
```
</details>

### `setOp(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilOp`

<details><summary>Code</summary>

```typescript
function(t,n,r){o===t&&s===n&&l===r||(e.stencilOp(t,n,r),o=t,s=n,l=r)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearStencil`

<details><summary>Code</summary>

```typescript
function(t){c!==t&&(e.clearStencil(t),c=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=null}
```
</details>

### `setTest(n: any): void`

**Parameters:**

- **`n`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(n){t||(n?W(e.STENCIL_TEST):X(e.STENCIL_TEST))}
```
</details>

### `setMask(r: any): void`

**Parameters:**

- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilMask`

<details><summary>Code</summary>

```typescript
function(r){n===r||t||(e.stencilMask(r),n=r)}
```
</details>

### `setFunc(t: any, n: any, o: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`o`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilFunc`

<details><summary>Code</summary>

```typescript
function(t,n,o){r===t&&i===n&&a===o||(e.stencilFunc(t,n,o),r=t,i=n,a=o)}
```
</details>

### `setOp(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.stencilOp`

<details><summary>Code</summary>

```typescript
function(t,n,r){o===t&&s===n&&l===r||(e.stencilOp(t,n,r),o=t,s=n,l=r)}
```
</details>

### `setLocked(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(e){t=e}
```
</details>

### `setClear(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.clearStencil`

<details><summary>Code</summary>

```typescript
function(t){c!==t&&(e.clearStencil(t),c=t)}
```
</details>

### `reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
function(){t=!1,n=null,r=null,i=null,a=null,o=null,s=null,l=null,c=null}
```
</details>

### `V(t: any, n: any, r: any, i: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`

**Returns:** `any`

**Calls:**

- `e.createTexture`
- `e.bindTexture`
- `e.texParameteri`
- `e.texImage3D`
- `e.texImage2D`

<details><summary>Code</summary>

```typescript
function V(t,n,r,i){const a=new Uint8Array(4),o=e.createTexture();e.bindTexture(t,o),e.texParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST);for(let o=0;o<r;o++)t===e.TEXTURE_3D||t===e.TEXTURE_2D_ARRAY?e.texImage3D(n,0,e.RGBA,1,1,i,0,e.RGBA,e.UNSIGNED_BYTE,a):e.texImage2D(n+o,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,a);return o}
```
</details>

### `W(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.enable`

<details><summary>Code</summary>

```typescript
function W(t){!0!==l[t]&&(e.enable(t),l[t]=!0)}
```
</details>

### `X(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.disable`

<details><summary>Code</summary>

```typescript
function X(t){!1!==l[t]&&(e.disable(t),l[t]=!1)}
```
</details>

### `q(t: any, n: any, r: any, i: any, a: any, o: any, s: any, l: any, c: any, d: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`
- **`l`** `any`
- **`c`** `any`
- **`d`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `e.blendEquationSeparate`
- `e.blendFuncSeparate`
- `l.equals`
- `e.blendColor`
- `M.copy`
- `e.blendEquation`
- `e.blendFunc`
- `console.error`
- `M.set`
- `X`

<details><summary>Code</summary>

```typescript
function q(t,n,r,i,a,o,s,l,c,d){if(t!==y){if(!1===m&&(W(e.BLEND),m=!0),t===$e)a=a||n,o=o||r,s=s||i,n===_&&a===E||(e.blendEquationSeparate(Y[n],Y[a]),_=n,E=a),r===g&&i===v&&o===S&&s===T||(e.blendFuncSeparate(K[r],K[i],K[o],K[s]),g=r,v=i,S=o,T=s),!1!==l.equals(M)&&c===x||(e.blendColor(l.r,l.g,l.b,c),M.copy(l),x=c),h=t,R=!1;else if(t!==h||d!==R){if(_===Ae&&E===Ae||(e.blendEquation(e.FUNC_ADD),_=Ae,E=Ae),d)switch(t){case pe:e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case et:e.blendFunc(e.ONE,e.ONE);break;case Je:e.blendFuncSeparate(e.ZERO,e.ONE_MINUS_SRC_COLOR,e.ZERO,e.ONE);break;case Qe:e.blendFuncSeparate(e.DST_COLOR,e.ONE_MINUS_SRC_ALPHA,e.ZERO,e.ONE);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case pe:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case et:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE,e.ONE,e.ONE);break;case Je:console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case Qe:console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}g=null,v=null,S=null,T=null,M.set(0,0,0),x=0,h=t,R=d}}else!0===m&&(X(e.BLEND),m=!1)}
```
</details>

### `j(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.frontFace`

<details><summary>Code</summary>

```typescript
function j(t){A!==t&&(t?e.frontFace(e.CW):e.frontFace(e.CCW),A=t)}
```
</details>

### `Z(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `e.cullFace`
- `X`

<details><summary>Code</summary>

```typescript
function Z(t){t!==qe?(W(e.CULL_FACE),t!==b&&(t===je?e.cullFace(e.BACK):t===Ze?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):X(e.CULL_FACE),b=t}
```
</details>

### `$(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `e.polygonOffset`
- `X`

<details><summary>Code</summary>

```typescript
function $(t,n,r){t?(W(e.POLYGON_OFFSET_FILL),L===n&&P===r||(e.polygonOffset(n,r),L=n,P=r)):X(e.POLYGON_OFFSET_FILL)}
```
</details>

### `bindFramebuffer(t: any, n: any): boolean`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `boolean`

**Calls:**

- `e.bindFramebuffer`

<details><summary>Code</summary>

```typescript
function(t,n){return d[t]!==n&&(e.bindFramebuffer(t,n),d[t]=n,t===e.DRAW_FRAMEBUFFER&&(d[e.FRAMEBUFFER]=n),t===e.FRAMEBUFFER&&(d[e.DRAW_FRAMEBUFFER]=n),!0)}
```
</details>

### `drawBuffers(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `u.get`
- `u.set`
- `e.drawBuffers`

<details><summary>Code</summary>

```typescript
function(t,n){let r=f,i=!1;if(t){r=u.get(n),void 0===r&&(r=[],u.set(n,r));const a=t.textures;if(r.length!==a.length||r[0]!==e.COLOR_ATTACHMENT0){for(let t=0,n=a.length;t<n;t++)r[t]=e.COLOR_ATTACHMENT0+t;r.length=a.length,i=!0}}else r[0]!==e.BACK&&(r[0]=e.BACK,i=!0);i&&e.drawBuffers(r)}
```
</details>

### `useProgram(t: any): boolean`

**Parameters:**

- **`t`** `any`

**Returns:** `boolean`

**Calls:**

- `e.useProgram`

<details><summary>Code</summary>

```typescript
function(t){return p!==t&&(e.useProgram(t),p=t,!0)}
```
</details>

### `setMaterial(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `X`
- `W`
- `j`
- `q`
- `i.setFunc`
- `i.setTest`
- `i.setMask`
- `r.setMask`
- `a.setTest`
- `a.setMask`
- `a.setFunc`
- `a.setOp`
- `$`

<details><summary>Code</summary>

```typescript
function(t,n){t.side===fe?X(e.CULL_FACE):W(e.CULL_FACE);let o=t.side===c;n&&(o=!o),j(o),t.blending===pe&&!1===t.transparent?q(y):q(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.blendColor,t.blendAlpha,t.premultipliedAlpha),i.setFunc(t.depthFunc),i.setTest(t.depthTest),i.setMask(t.depthWrite),r.setMask(t.colorWrite);const s=t.stencilWrite;a.setTest(s),s&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),$(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?W(e.SAMPLE_ALPHA_TO_COVERAGE):X(e.SAMPLE_ALPHA_TO_COVERAGE)}
```
</details>

### `setLineWidth(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.lineWidth`

<details><summary>Code</summary>

```typescript
function(t){t!==C&&(D&&e.lineWidth(t),C=t)}
```
</details>

### `setScissorTest(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(t){t?W(e.SCISSOR_TEST):X(e.SCISSOR_TEST)}
```
</details>

### `activeTexture(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.activeTexture`

<details><summary>Code</summary>

```typescript
function(t){void 0===t&&(t=e.TEXTURE0+U-1),N!==t&&(e.activeTexture(t),N=t)}
```
</details>

### `bindTexture(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.activeTexture`
- `e.bindTexture`

<details><summary>Code</summary>

```typescript
function(t,n,r){void 0===r&&(r=null===N?e.TEXTURE0+U-1:N);let i=O[r];void 0===i&&(i={type:void 0,texture:void 0},O[r]=i),i.type===t&&i.texture===n||(N!==r&&(e.activeTexture(r),N=r),e.bindTexture(t,n||z[t]),i.type=t,i.texture=n)}
```
</details>

### `unbindTexture(): void`

**Returns:** `void`

**Calls:**

- `e.bindTexture`

<details><summary>Code</summary>

```typescript
function(){const t=O[N];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)}
```
</details>

### `compressedTexImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `compressedTexImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.texImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.texImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `updateUBOMapping(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `s.get`
- `s.set`
- `r.get`
- `e.getUniformBlockIndex`
- `r.set`

<details><summary>Code</summary>

```typescript
function(t,n){let r=s.get(n);void 0===r&&(r=new WeakMap,s.set(n,r));let i=r.get(t);void 0===i&&(i=e.getUniformBlockIndex(n,t.name),r.set(t,i))}
```
</details>

### `uniformBlockBinding(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `s.get(n).get`
- `o.get`
- `e.uniformBlockBinding`
- `o.set`

<details><summary>Code</summary>

```typescript
function(t,n){const r=s.get(n).get(t);o.get(n)!==r&&(e.uniformBlockBinding(n,r,t.__bindingPointIndex),o.set(n,r))}
```
</details>

### `texStorage2D(): void`

**Returns:** `void`

**Calls:**

- `e.texStorage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texStorage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texStorage3D(): void`

**Returns:** `void`

**Calls:**

- `e.texStorage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texStorage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texSubImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.texSubImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texSubImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texSubImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.texSubImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texSubImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `compressedTexSubImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexSubImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexSubImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `compressedTexSubImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexSubImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexSubImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `scissor(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `H.equals`
- `e.scissor`
- `H.copy`

<details><summary>Code</summary>

```typescript
function(t){!1===H.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),H.copy(t))}
```
</details>

### `viewport(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `G.equals`
- `e.viewport`
- `G.copy`

<details><summary>Code</summary>

```typescript
function(t){!1===G.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),G.copy(t))}
```
</details>

### `reset(): void`

**Returns:** `void`

**Calls:**

- `e.disable`
- `e.blendEquation`
- `e.blendFunc`
- `e.blendFuncSeparate`
- `e.blendColor`
- `e.colorMask`
- `e.clearColor`
- `e.depthMask`
- `e.depthFunc`
- `i.setReversed`
- `e.clearDepth`
- `e.stencilMask`
- `e.stencilFunc`
- `e.stencilOp`
- `e.clearStencil`
- `e.cullFace`
- `e.frontFace`
- `e.polygonOffset`
- `e.activeTexture`
- `e.bindFramebuffer`
- `e.useProgram`
- `e.lineWidth`
- `e.scissor`
- `e.viewport`
- `H.set`
- `G.set`
- `r.reset`
- `i.reset`
- `a.reset`

<details><summary>Code</summary>

```typescript
function(){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.blendColor(0,0,0,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),i.setReversed(!1),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.bindFramebuffer(e.READ_FRAMEBUFFER,null),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),l={},N=null,O={},d={},u=new WeakMap,f=[],p=null,m=!1,h=null,_=null,g=null,v=null,E=null,S=null,T=null,M=new n(0,0,0),x=0,R=!1,A=null,b=null,C=null,L=null,P=null,H.set(0,0,e.canvas.width,e.canvas.height),G.set(0,0,e.canvas.width,e.canvas.height),r.reset(),i.reset(),a.reset()}
```
</details>

### `bindFramebuffer(t: any, n: any): boolean`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `boolean`

**Calls:**

- `e.bindFramebuffer`

<details><summary>Code</summary>

```typescript
function(t,n){return d[t]!==n&&(e.bindFramebuffer(t,n),d[t]=n,t===e.DRAW_FRAMEBUFFER&&(d[e.FRAMEBUFFER]=n),t===e.FRAMEBUFFER&&(d[e.DRAW_FRAMEBUFFER]=n),!0)}
```
</details>

### `drawBuffers(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `u.get`
- `u.set`
- `e.drawBuffers`

<details><summary>Code</summary>

```typescript
function(t,n){let r=f,i=!1;if(t){r=u.get(n),void 0===r&&(r=[],u.set(n,r));const a=t.textures;if(r.length!==a.length||r[0]!==e.COLOR_ATTACHMENT0){for(let t=0,n=a.length;t<n;t++)r[t]=e.COLOR_ATTACHMENT0+t;r.length=a.length,i=!0}}else r[0]!==e.BACK&&(r[0]=e.BACK,i=!0);i&&e.drawBuffers(r)}
```
</details>

### `useProgram(t: any): boolean`

**Parameters:**

- **`t`** `any`

**Returns:** `boolean`

**Calls:**

- `e.useProgram`

<details><summary>Code</summary>

```typescript
function(t){return p!==t&&(e.useProgram(t),p=t,!0)}
```
</details>

### `setMaterial(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `X`
- `W`
- `j`
- `q`
- `i.setFunc`
- `i.setTest`
- `i.setMask`
- `r.setMask`
- `a.setTest`
- `a.setMask`
- `a.setFunc`
- `a.setOp`
- `$`

<details><summary>Code</summary>

```typescript
function(t,n){t.side===fe?X(e.CULL_FACE):W(e.CULL_FACE);let o=t.side===c;n&&(o=!o),j(o),t.blending===pe&&!1===t.transparent?q(y):q(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.blendColor,t.blendAlpha,t.premultipliedAlpha),i.setFunc(t.depthFunc),i.setTest(t.depthTest),i.setMask(t.depthWrite),r.setMask(t.colorWrite);const s=t.stencilWrite;a.setTest(s),s&&(a.setMask(t.stencilWriteMask),a.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),a.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),$(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?W(e.SAMPLE_ALPHA_TO_COVERAGE):X(e.SAMPLE_ALPHA_TO_COVERAGE)}
```
</details>

### `setLineWidth(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.lineWidth`

<details><summary>Code</summary>

```typescript
function(t){t!==C&&(D&&e.lineWidth(t),C=t)}
```
</details>

### `setScissorTest(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `W`
- `X`

<details><summary>Code</summary>

```typescript
function(t){t?W(e.SCISSOR_TEST):X(e.SCISSOR_TEST)}
```
</details>

### `activeTexture(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.activeTexture`

<details><summary>Code</summary>

```typescript
function(t){void 0===t&&(t=e.TEXTURE0+U-1),N!==t&&(e.activeTexture(t),N=t)}
```
</details>

### `bindTexture(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.activeTexture`
- `e.bindTexture`

<details><summary>Code</summary>

```typescript
function(t,n,r){void 0===r&&(r=null===N?e.TEXTURE0+U-1:N);let i=O[r];void 0===i&&(i={type:void 0,texture:void 0},O[r]=i),i.type===t&&i.texture===n||(N!==r&&(e.activeTexture(r),N=r),e.bindTexture(t,n||z[t]),i.type=t,i.texture=n)}
```
</details>

### `unbindTexture(): void`

**Returns:** `void`

**Calls:**

- `e.bindTexture`

<details><summary>Code</summary>

```typescript
function(){const t=O[N];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)}
```
</details>

### `compressedTexImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `compressedTexImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.texImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.texImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `updateUBOMapping(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `s.get`
- `s.set`
- `r.get`
- `e.getUniformBlockIndex`
- `r.set`

<details><summary>Code</summary>

```typescript
function(t,n){let r=s.get(n);void 0===r&&(r=new WeakMap,s.set(n,r));let i=r.get(t);void 0===i&&(i=e.getUniformBlockIndex(n,t.name),r.set(t,i))}
```
</details>

### `uniformBlockBinding(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `s.get(n).get`
- `o.get`
- `e.uniformBlockBinding`
- `o.set`

<details><summary>Code</summary>

```typescript
function(t,n){const r=s.get(n).get(t);o.get(n)!==r&&(e.uniformBlockBinding(n,r,t.__bindingPointIndex),o.set(n,r))}
```
</details>

### `texStorage2D(): void`

**Returns:** `void`

**Calls:**

- `e.texStorage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texStorage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texStorage3D(): void`

**Returns:** `void`

**Calls:**

- `e.texStorage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texStorage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texSubImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.texSubImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texSubImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `texSubImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.texSubImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.texSubImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `compressedTexSubImage2D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexSubImage2D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexSubImage2D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `compressedTexSubImage3D(): void`

**Returns:** `void`

**Calls:**

- `e.compressedTexSubImage3D`
- `console.error`

<details><summary>Code</summary>

```typescript
function(){try{e.compressedTexSubImage3D(...arguments)}catch(e){console.error("THREE.WebGLState:",e)}}
```
</details>

### `scissor(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `H.equals`
- `e.scissor`
- `H.copy`

<details><summary>Code</summary>

```typescript
function(t){!1===H.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),H.copy(t))}
```
</details>

### `viewport(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `G.equals`
- `e.viewport`
- `G.copy`

<details><summary>Code</summary>

```typescript
function(t){!1===G.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),G.copy(t))}
```
</details>

### `reset(): void`

**Returns:** `void`

**Calls:**

- `e.disable`
- `e.blendEquation`
- `e.blendFunc`
- `e.blendFuncSeparate`
- `e.blendColor`
- `e.colorMask`
- `e.clearColor`
- `e.depthMask`
- `e.depthFunc`
- `i.setReversed`
- `e.clearDepth`
- `e.stencilMask`
- `e.stencilFunc`
- `e.stencilOp`
- `e.clearStencil`
- `e.cullFace`
- `e.frontFace`
- `e.polygonOffset`
- `e.activeTexture`
- `e.bindFramebuffer`
- `e.useProgram`
- `e.lineWidth`
- `e.scissor`
- `e.viewport`
- `H.set`
- `G.set`
- `r.reset`
- `i.reset`
- `a.reset`

<details><summary>Code</summary>

```typescript
function(){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.blendColor(0,0,0,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),i.setReversed(!1),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.bindFramebuffer(e.READ_FRAMEBUFFER,null),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),l={},N=null,O={},d={},u=new WeakMap,f=[],p=null,m=!1,h=null,_=null,g=null,v=null,E=null,S=null,T=null,M=new n(0,0,0),x=0,R=!1,A=null,b=null,C=null,L=null,P=null,H.set(0,0,e.canvas.width,e.canvas.height),G.set(0,0,e.canvas.width,e.canvas.height),r.reset(),i.reset(),a.reset()}
```
</details>

### `Ji(e: any, n: any, r: any, i: any, a: any, o: any, s: any): void`

**Parameters:**

- **`e`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `n.has`
- `n.get`
- `/OculusBrowser/g.test`
- `new OffscreenCanvas(1,1).getContext`
- `Rt (from ./three.core.min.js)`
- `Q`
- `Math.max`
- `Math.floor`
- `g`
- `o.getContext("2d").drawImage`
- `console.warn`
- `e.generateMipmap`
- `p.getTransfer`
- `E`
- `Math.log2`
- `Array.isArray`
- `t.removeEventListener`
- `complex_call_256066`
- `i.get`
- `h.get`
- `U`
- `Object.keys`
- `h.delete`
- `i.remove`
- `u.delete`
- `n.removeEventListener`
- `complex_call_256373`
- `t.depthTexture.dispose`
- `e.deleteFramebuffer`
- `e.deleteRenderbuffer`
- `e.deleteTexture`
- `complex_call_257724`
- `u.get`
- `u.set`
- `e.update`
- `V`
- `r.bindTexture`
- `e.texParameteri`
- `e.texParameterf`
- `Math.min`
- `a.getMaxAnisotropy`
- `n.addEventListener`
- `h.set`
- `complex_call_260006`
- `t.push`
- `t.join`
- `e.createTexture`
- `H`
- `r.activeTexture`
- `p.getPrimaries`
- `e.pixelStorei`
- `v`
- `$`
- `o.convert`
- `A`
- `O`
- `C`
- `b`
- `r.texStorage2D`
- `r.texImage2D`
- `r.texSubImage2D`
- `complex_call_262122`
- `o.sort`
- `G`
- `e.getParameter`
- `Math.ceil`
- `t.clearUpdateRanges`
- `r.texStorage3D`
- `Et (from ./three.core.min.js)`
- `g.data.subarray`
- `r.compressedTexSubImage3D`
- `n.clearLayerUpdates`
- `r.compressedTexImage3D`
- `r.texSubImage3D`
- `r.texImage3D`
- `r.compressedTexSubImage2D`
- `r.compressedTexImage2D`
- `m.data.subarray`
- `x`
- `n.onUpdate`
- `r.bindFramebuffer`
- `Z`
- `l.framebufferTexture2DMultisampleEXT`
- `j`
- `e.framebufferTexture2D`
- `e.bindRenderbuffer`
- `l.renderbufferStorageMultisampleEXT`
- `e.renderbufferStorageMultisample`
- `e.renderbufferStorage`
- `e.framebufferRenderbuffer`
- `w`
- `n.__depthDisposeCallback`
- `e.removeEventListener`
- `e.addEventListener`
- `W`
- `e.createRenderbuffer`
- `k`
- `console.error`
- `complex_call_271868`
- `z`
- `X`
- `t.addEventListener`
- `e.createFramebuffer`
- `r.unbindTexture`
- `R`
- `e.blitFramebuffer`
- `Y.push`
- `q.push`
- `e.invalidateFramebuffer`

<details><summary>Code</summary>

```typescript
function Ji(e,n,r,i,a,o,s){const l=n.has("WEBGL_multisampled_render_to_texture")?n.get("WEBGL_multisampled_render_to_texture"):null,c="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),d=new t,u=new WeakMap;let f;const h=new WeakMap;let _=!1;try{_="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function g(e,t){return _?new OffscreenCanvas(e,t):Rt("canvas")}function v(e,t,n){let r=1;const i=Q(e);if((i.width>n||i.height>n)&&(r=n/Math.max(i.width,i.height)),r<1){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&e instanceof VideoFrame){const n=Math.floor(r*i.width),a=Math.floor(r*i.height);void 0===f&&(f=g(n,a));const o=t?g(n,a):f;o.width=n,o.height=a;return o.getContext("2d").drawImage(e,0,0,n,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+i.width+"x"+i.height+") to ("+n+"x"+a+")."),o}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+i.width+"x"+i.height+")."),e}return e}function E(e){return e.generateMipmaps}function x(t){e.generateMipmap(t)}function R(t){return t.isWebGLCubeRenderTarget?e.TEXTURE_CUBE_MAP:t.isWebGL3DRenderTarget?e.TEXTURE_3D:t.isWebGLArrayRenderTarget||t.isCompressedArrayTexture?e.TEXTURE_2D_ARRAY:e.TEXTURE_2D}function A(t,r,i,a,o=!1){if(null!==t){if(void 0!==e[t])return e[t];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+t+"'")}let s=r;if(r===e.RED&&(i===e.FLOAT&&(s=e.R32F),i===e.HALF_FLOAT&&(s=e.R16F),i===e.UNSIGNED_BYTE&&(s=e.R8)),r===e.RED_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.R8UI),i===e.UNSIGNED_SHORT&&(s=e.R16UI),i===e.UNSIGNED_INT&&(s=e.R32UI),i===e.BYTE&&(s=e.R8I),i===e.SHORT&&(s=e.R16I),i===e.INT&&(s=e.R32I)),r===e.RG&&(i===e.FLOAT&&(s=e.RG32F),i===e.HALF_FLOAT&&(s=e.RG16F),i===e.UNSIGNED_BYTE&&(s=e.RG8)),r===e.RG_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.RG8UI),i===e.UNSIGNED_SHORT&&(s=e.RG16UI),i===e.UNSIGNED_INT&&(s=e.RG32UI),i===e.BYTE&&(s=e.RG8I),i===e.SHORT&&(s=e.RG16I),i===e.INT&&(s=e.RG32I)),r===e.RGB_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.RGB8UI),i===e.UNSIGNED_SHORT&&(s=e.RGB16UI),i===e.UNSIGNED_INT&&(s=e.RGB32UI),i===e.BYTE&&(s=e.RGB8I),i===e.SHORT&&(s=e.RGB16I),i===e.INT&&(s=e.RGB32I)),r===e.RGBA_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.RGBA8UI),i===e.UNSIGNED_SHORT&&(s=e.RGBA16UI),i===e.UNSIGNED_INT&&(s=e.RGBA32UI),i===e.BYTE&&(s=e.RGBA8I),i===e.SHORT&&(s=e.RGBA16I),i===e.INT&&(s=e.RGBA32I)),r===e.RGB&&i===e.UNSIGNED_INT_5_9_9_9_REV&&(s=e.RGB9_E5),r===e.RGBA){const t=o?se:p.getTransfer(a);i===e.FLOAT&&(s=e.RGBA32F),i===e.HALF_FLOAT&&(s=e.RGBA16F),i===e.UNSIGNED_BYTE&&(s=t===m?e.SRGB8_ALPHA8:e.RGBA8),i===e.UNSIGNED_SHORT_4_4_4_4&&(s=e.RGBA4),i===e.UNSIGNED_SHORT_5_5_5_1&&(s=e.RGB5_A1)}return s!==e.R16F&&s!==e.R32F&&s!==e.RG16F&&s!==e.RG32F&&s!==e.RGBA16F&&s!==e.RGBA32F||n.get("EXT_color_buffer_float"),s}function b(t,n){let r;return t?null===n||n===Tt||n===Mt?r=e.DEPTH24_STENCIL8:n===T?r=e.DEPTH32F_STENCIL8:n===xt&&(r=e.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===n||n===Tt||n===Mt?r=e.DEPTH_COMPONENT24:n===T?r=e.DEPTH_COMPONENT32F:n===xt&&(r=e.DEPTH_COMPONENT16),r}function C(e,t){return!0===E(e)||e.isFramebufferTexture&&e.minFilter!==Te&&e.minFilter!==B?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function L(e){const t=e.target;t.removeEventListener("dispose",L),function(e){const t=i.get(e);if(void 0===t.__webglInit)return;const n=e.source,r=h.get(n);if(r){const i=r[t.__cacheKey];i.usedTimes--,0===i.usedTimes&&U(e),0===Object.keys(r).length&&h.delete(n)}i.remove(e)}(t),t.isVideoTexture&&u.delete(t)}function P(t){const n=t.target;n.removeEventListener("dispose",P),function(t){const n=i.get(t);t.depthTexture&&(t.depthTexture.dispose(),i.remove(t.depthTexture));if(t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++){if(Array.isArray(n.__webglFramebuffer[t]))for(let r=0;r<n.__webglFramebuffer[t].length;r++)e.deleteFramebuffer(n.__webglFramebuffer[t][r]);else e.deleteFramebuffer(n.__webglFramebuffer[t]);n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[t])}else{if(Array.isArray(n.__webglFramebuffer))for(let t=0;t<n.__webglFramebuffer.length;t++)e.deleteFramebuffer(n.__webglFramebuffer[t]);else e.deleteFramebuffer(n.__webglFramebuffer);if(n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer)for(let t=0;t<n.__webglColorRenderbuffer.length;t++)n.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer)}const r=t.textures;for(let t=0,n=r.length;t<n;t++){const n=i.get(r[t]);n.__webglTexture&&(e.deleteTexture(n.__webglTexture),s.memory.textures--),i.remove(r[t])}i.remove(t)}(n)}function U(t){const n=i.get(t);e.deleteTexture(n.__webglTexture);const r=t.source;delete h.get(r)[n.__cacheKey],s.memory.textures--}let D=0;function w(t,n){const a=i.get(t);if(t.isVideoTexture&&function(e){const t=s.render.frame;u.get(e)!==t&&(u.set(e,t),e.update())}(t),!1===t.isRenderTargetTexture&&!0!==t.isExternalTexture&&t.version>0&&a.__version!==t.version){const e=t.image;if(null===e)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==e.complete)return void V(a,t,n);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}else t.isExternalTexture&&(a.__webglTexture=t.sourceTexture?t.sourceTexture:null);r.bindTexture(e.TEXTURE_2D,a.__webglTexture,e.TEXTURE0+n)}const y={[at]:e.REPEAT,[it]:e.CLAMP_TO_EDGE,[rt]:e.MIRRORED_REPEAT},I={[Te]:e.NEAREST,[ct]:e.NEAREST_MIPMAP_NEAREST,[lt]:e.NEAREST_MIPMAP_LINEAR,[B]:e.LINEAR,[st]:e.LINEAR_MIPMAP_NEAREST,[ot]:e.LINEAR_MIPMAP_LINEAR},N={[_t]:e.NEVER,[ht]:e.ALWAYS,[mt]:e.LESS,[K]:e.LEQUAL,[pt]:e.EQUAL,[ft]:e.GEQUAL,[ut]:e.GREATER,[dt]:e.NOTEQUAL};function O(t,r){if(r.type!==T||!1!==n.has("OES_texture_float_linear")||r.magFilter!==B&&r.magFilter!==st&&r.magFilter!==lt&&r.magFilter!==ot&&r.minFilter!==B&&r.minFilter!==st&&r.minFilter!==lt&&r.minFilter!==ot||console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),e.texParameteri(t,e.TEXTURE_WRAP_S,y[r.wrapS]),e.texParameteri(t,e.TEXTURE_WRAP_T,y[r.wrapT]),t!==e.TEXTURE_3D&&t!==e.TEXTURE_2D_ARRAY||e.texParameteri(t,e.TEXTURE_WRAP_R,y[r.wrapR]),e.texParameteri(t,e.TEXTURE_MAG_FILTER,I[r.magFilter]),e.texParameteri(t,e.TEXTURE_MIN_FILTER,I[r.minFilter]),r.compareFunction&&(e.texParameteri(t,e.TEXTURE_COMPARE_MODE,e.COMPARE_REF_TO_TEXTURE),e.texParameteri(t,e.TEXTURE_COMPARE_FUNC,N[r.compareFunction])),!0===n.has("EXT_texture_filter_anisotropic")){if(r.magFilter===Te)return;if(r.minFilter!==lt&&r.minFilter!==ot)return;if(r.type===T&&!1===n.has("OES_texture_float_linear"))return;if(r.anisotropy>1||i.get(r).__currentAnisotropy){const o=n.get("EXT_texture_filter_anisotropic");e.texParameterf(t,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r.anisotropy,a.getMaxAnisotropy())),i.get(r).__currentAnisotropy=r.anisotropy}}}function H(t,n){let r=!1;void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",L));const i=n.source;let a=h.get(i);void 0===a&&(a={},h.set(i,a));const o=function(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.wrapR||0),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.colorSpace),t.join()}(n);if(o!==t.__cacheKey){void 0===a[o]&&(a[o]={texture:e.createTexture(),usedTimes:0},s.memory.textures++,r=!0),a[o].usedTimes++;const i=a[t.__cacheKey];void 0!==i&&(a[t.__cacheKey].usedTimes--,0===i.usedTimes&&U(n)),t.__cacheKey=o,t.__webglTexture=a[o].texture}return r}function G(e,t,n){return Math.floor(Math.floor(e/n)/t)}function V(t,n,s){let l=e.TEXTURE_2D;(n.isDataArrayTexture||n.isCompressedArrayTexture)&&(l=e.TEXTURE_2D_ARRAY),n.isData3DTexture&&(l=e.TEXTURE_3D);const c=H(t,n),d=n.source;r.bindTexture(l,t.__webglTexture,e.TEXTURE0+s);const u=i.get(d);if(d.version!==u.__version||!0===c){r.activeTexture(e.TEXTURE0+s);const t=p.getPrimaries(p.workingColorSpace),i=n.colorSpace===gt?null:p.getPrimaries(n.colorSpace),f=n.colorSpace===gt||t===i?e.NONE:e.BROWSER_DEFAULT_WEBGL;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,n.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,n.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,f);let m=v(n.image,!1,a.maxTextureSize);m=$(n,m);const h=o.convert(n.format,n.colorSpace),_=o.convert(n.type);let g,S=A(n.internalFormat,h,_,n.colorSpace,n.isVideoTexture);O(l,n);const T=n.mipmaps,R=!0!==n.isVideoTexture,L=void 0===u.__version||!0===c,P=d.dataReady,U=C(n,m);if(n.isDepthTexture)S=b(n.format===vt,n.type),L&&(R?r.texStorage2D(e.TEXTURE_2D,1,S,m.width,m.height):r.texImage2D(e.TEXTURE_2D,0,S,m.width,m.height,0,h,_,null));else if(n.isDataTexture)if(T.length>0){R&&L&&r.texStorage2D(e.TEXTURE_2D,U,S,T[0].width,T[0].height);for(let t=0,n=T.length;t<n;t++)g=T[t],R?P&&r.texSubImage2D(e.TEXTURE_2D,t,0,0,g.width,g.height,h,_,g.data):r.texImage2D(e.TEXTURE_2D,t,S,g.width,g.height,0,h,_,g.data);n.generateMipmaps=!1}else R?(L&&r.texStorage2D(e.TEXTURE_2D,U,S,m.width,m.height),P&&function(t,n,i,a){const o=t.updateRanges;if(0===o.length)r.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,i,a,n.data);else{o.sort((e,t)=>e.start-t.start);let s=0;for(let e=1;e<o.length;e++){const t=o[s],r=o[e],i=t.start+t.count,a=G(r.start,n.width,4),l=G(t.start,n.width,4);r.start<=i+1&&a===l&&G(r.start+r.count-1,n.width,4)===a?t.count=Math.max(t.count,r.start+r.count-t.start):(++s,o[s]=r)}o.length=s+1;const l=e.getParameter(e.UNPACK_ROW_LENGTH),c=e.getParameter(e.UNPACK_SKIP_PIXELS),d=e.getParameter(e.UNPACK_SKIP_ROWS);e.pixelStorei(e.UNPACK_ROW_LENGTH,n.width);for(let t=0,s=o.length;t<s;t++){const s=o[t],l=Math.floor(s.start/4),c=Math.ceil(s.count/4),d=l%n.width,u=Math.floor(l/n.width),f=c,p=1;e.pixelStorei(e.UNPACK_SKIP_PIXELS,d),e.pixelStorei(e.UNPACK_SKIP_ROWS,u),r.texSubImage2D(e.TEXTURE_2D,0,d,u,f,p,i,a,n.data)}t.clearUpdateRanges(),e.pixelStorei(e.UNPACK_ROW_LENGTH,l),e.pixelStorei(e.UNPACK_SKIP_PIXELS,c),e.pixelStorei(e.UNPACK_SKIP_ROWS,d)}}(n,m,h,_)):r.texImage2D(e.TEXTURE_2D,0,S,m.width,m.height,0,h,_,m.data);else if(n.isCompressedTexture)if(n.isCompressedArrayTexture){R&&L&&r.texStorage3D(e.TEXTURE_2D_ARRAY,U,S,T[0].width,T[0].height,m.depth);for(let t=0,i=T.length;t<i;t++)if(g=T[t],n.format!==M)if(null!==h)if(R){if(P)if(n.layerUpdates.size>0){const i=Et(g.width,g.height,n.format,n.type);for(const a of n.layerUpdates){const n=g.data.subarray(a*i/g.data.BYTES_PER_ELEMENT,(a+1)*i/g.data.BYTES_PER_ELEMENT);r.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,a,g.width,g.height,1,h,n)}n.clearLayerUpdates()}else r.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,0,g.width,g.height,m.depth,h,g.data)}else r.compressedTexImage3D(e.TEXTURE_2D_ARRAY,t,S,g.width,g.height,m.depth,0,g.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else R?P&&r.texSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,0,g.width,g.height,m.depth,h,_,g.data):r.texImage3D(e.TEXTURE_2D_ARRAY,t,S,g.width,g.height,m.depth,0,h,_,g.data)}else{R&&L&&r.texStorage2D(e.TEXTURE_2D,U,S,T[0].width,T[0].height);for(let t=0,i=T.length;t<i;t++)g=T[t],n.format!==M?null!==h?R?P&&r.compressedTexSubImage2D(e.TEXTURE_2D,t,0,0,g.width,g.height,h,g.data):r.compressedTexImage2D(e.TEXTURE_2D,t,S,g.width,g.height,0,g.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):R?P&&r.texSubImage2D(e.TEXTURE_2D,t,0,0,g.width,g.height,h,_,g.data):r.texImage2D(e.TEXTURE_2D,t,S,g.width,g.height,0,h,_,g.data)}else if(n.isDataArrayTexture)if(R){if(L&&r.texStorage3D(e.TEXTURE_2D_ARRAY,U,S,m.width,m.height,m.depth),P)if(n.layerUpdates.size>0){const t=Et(m.width,m.height,n.format,n.type);for(const i of n.layerUpdates){const n=m.data.subarray(i*t/m.data.BYTES_PER_ELEMENT,(i+1)*t/m.data.BYTES_PER_ELEMENT);r.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,i,m.width,m.height,1,h,_,n)}n.clearLayerUpdates()}else r.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,0,m.width,m.height,m.depth,h,_,m.data)}else r.texImage3D(e.TEXTURE_2D_ARRAY,0,S,m.width,m.height,m.depth,0,h,_,m.data);else if(n.isData3DTexture)R?(L&&r.texStorage3D(e.TEXTURE_3D,U,S,m.width,m.height,m.depth),P&&r.texSubImage3D(e.TEXTURE_3D,0,0,0,0,m.width,m.height,m.depth,h,_,m.data)):r.texImage3D(e.TEXTURE_3D,0,S,m.width,m.height,m.depth,0,h,_,m.data);else if(n.isFramebufferTexture){if(L)if(R)r.texStorage2D(e.TEXTURE_2D,U,S,m.width,m.height);else{let t=m.width,n=m.height;for(let i=0;i<U;i++)r.texImage2D(e.TEXTURE_2D,i,S,t,n,0,h,_,null),t>>=1,n>>=1}}else if(T.length>0){if(R&&L){const t=Q(T[0]);r.texStorage2D(e.TEXTURE_2D,U,S,t.width,t.height)}for(let t=0,n=T.length;t<n;t++)g=T[t],R?P&&r.texSubImage2D(e.TEXTURE_2D,t,0,0,h,_,g):r.texImage2D(e.TEXTURE_2D,t,S,h,_,g);n.generateMipmaps=!1}else if(R){if(L){const t=Q(m);r.texStorage2D(e.TEXTURE_2D,U,S,t.width,t.height)}P&&r.texSubImage2D(e.TEXTURE_2D,0,0,0,h,_,m)}else r.texImage2D(e.TEXTURE_2D,0,S,h,_,m);E(n)&&x(l),u.__version=d.version,n.onUpdate&&n.onUpdate(n)}t.__version=n.version}function z(t,n,a,s,c,d){const u=o.convert(a.format,a.colorSpace),f=o.convert(a.type),p=A(a.internalFormat,u,f,a.colorSpace),m=i.get(n),h=i.get(a);if(h.__renderTarget=n,!m.__hasExternalTextures){const t=Math.max(1,n.width>>d),i=Math.max(1,n.height>>d);c===e.TEXTURE_3D||c===e.TEXTURE_2D_ARRAY?r.texImage3D(c,d,p,t,i,n.depth,0,u,f,null):r.texImage2D(c,d,p,t,i,0,u,f,null)}r.bindFramebuffer(e.FRAMEBUFFER,t),Z(n)?l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,s,c,h.__webglTexture,0,j(n)):(c===e.TEXTURE_2D||c>=e.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=e.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&e.framebufferTexture2D(e.FRAMEBUFFER,s,c,h.__webglTexture,d),r.bindFramebuffer(e.FRAMEBUFFER,null)}function k(t,n,r){if(e.bindRenderbuffer(e.RENDERBUFFER,t),n.depthBuffer){const i=n.depthTexture,a=i&&i.isDepthTexture?i.type:null,o=b(n.stencilBuffer,a),s=n.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,c=j(n);Z(n)?l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,c,o,n.width,n.height):r?e.renderbufferStorageMultisample(e.RENDERBUFFER,c,o,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,o,n.width,n.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,s,e.RENDERBUFFER,t)}else{const t=n.textures;for(let i=0;i<t.length;i++){const a=t[i],s=o.convert(a.format,a.colorSpace),c=o.convert(a.type),d=A(a.internalFormat,s,c,a.colorSpace),u=j(n);r&&!1===Z(n)?e.renderbufferStorageMultisample(e.RENDERBUFFER,u,d,n.width,n.height):Z(n)?l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,u,d,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,d,n.width,n.height)}}e.bindRenderbuffer(e.RENDERBUFFER,null)}function W(t,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(r.bindFramebuffer(e.FRAMEBUFFER,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const a=i.get(n.depthTexture);a.__renderTarget=n,a.__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),w(n.depthTexture,0);const o=a.__webglTexture,s=j(n);if(n.depthTexture.format===St)Z(n)?l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,o,0,s):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,o,0);else{if(n.depthTexture.format!==vt)throw new Error("Unknown depthTexture format");Z(n)?l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,o,0,s):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,o,0)}}function X(t){const n=i.get(t),a=!0===t.isWebGLCubeRenderTarget;if(n.__boundDepthTexture!==t.depthTexture){const e=t.depthTexture;if(n.__depthDisposeCallback&&n.__depthDisposeCallback(),e){const t=()=>{delete n.__boundDepthTexture,delete n.__depthDisposeCallback,e.removeEventListener("dispose",t)};e.addEventListener("dispose",t),n.__depthDisposeCallback=t}n.__boundDepthTexture=e}if(t.depthTexture&&!n.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");const e=t.texture.mipmaps;e&&e.length>0?W(n.__webglFramebuffer[0],t):W(n.__webglFramebuffer,t)}else if(a){n.__webglDepthbuffer=[];for(let i=0;i<6;i++)if(r.bindFramebuffer(e.FRAMEBUFFER,n.__webglFramebuffer[i]),void 0===n.__webglDepthbuffer[i])n.__webglDepthbuffer[i]=e.createRenderbuffer(),k(n.__webglDepthbuffer[i],t,!1);else{const r=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,a=n.__webglDepthbuffer[i];e.bindRenderbuffer(e.RENDERBUFFER,a),e.framebufferRenderbuffer(e.FRAMEBUFFER,r,e.RENDERBUFFER,a)}}else{const i=t.texture.mipmaps;if(i&&i.length>0?r.bindFramebuffer(e.FRAMEBUFFER,n.__webglFramebuffer[0]):r.bindFramebuffer(e.FRAMEBUFFER,n.__webglFramebuffer),void 0===n.__webglDepthbuffer)n.__webglDepthbuffer=e.createRenderbuffer(),k(n.__webglDepthbuffer,t,!1);else{const r=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,i=n.__webglDepthbuffer;e.bindRenderbuffer(e.RENDERBUFFER,i),e.framebufferRenderbuffer(e.FRAMEBUFFER,r,e.RENDERBUFFER,i)}}r.bindFramebuffer(e.FRAMEBUFFER,null)}const Y=[],q=[];function j(e){return Math.min(a.maxSamples,e.samples)}function Z(e){const t=i.get(e);return e.samples>0&&!0===n.has("WEBGL_multisampled_render_to_texture")&&!1!==t.__useRenderToTexture}function $(e,t){const n=e.colorSpace,r=e.format,i=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||n!==F&&n!==gt&&(p.getTransfer(n)===m?r===M&&i===S||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",n)),t}function Q(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement?(d.width=e.naturalWidth||e.width,d.height=e.naturalHeight||e.height):"undefined"!=typeof VideoFrame&&e instanceof VideoFrame?(d.width=e.displayWidth,d.height=e.displayHeight):(d.width=e.width,d.height=e.height),d}this.allocateTextureUnit=function(){const e=D;return e>=a.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+a.maxTextures),D+=1,e},this.resetTextureUnits=function(){D=0},this.setTexture2D=w,this.setTexture2DArray=function(t,n){const a=i.get(t);!1===t.isRenderTargetTexture&&t.version>0&&a.__version!==t.version?V(a,t,n):r.bindTexture(e.TEXTURE_2D_ARRAY,a.__webglTexture,e.TEXTURE0+n)},this.setTexture3D=function(t,n){const a=i.get(t);!1===t.isRenderTargetTexture&&t.version>0&&a.__version!==t.version?V(a,t,n):r.bindTexture(e.TEXTURE_3D,a.__webglTexture,e.TEXTURE0+n)},this.setTextureCube=function(t,n){const s=i.get(t);t.version>0&&s.__version!==t.version?function(t,n,s){if(6!==n.image.length)return;const l=H(t,n),c=n.source;r.bindTexture(e.TEXTURE_CUBE_MAP,t.__webglTexture,e.TEXTURE0+s);const d=i.get(c);if(c.version!==d.__version||!0===l){r.activeTexture(e.TEXTURE0+s);const t=p.getPrimaries(p.workingColorSpace),i=n.colorSpace===gt?null:p.getPrimaries(n.colorSpace),u=n.colorSpace===gt||t===i?e.NONE:e.BROWSER_DEFAULT_WEBGL;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,n.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,n.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,u);const f=n.isCompressedTexture||n.image[0].isCompressedTexture,m=n.image[0]&&n.image[0].isDataTexture,h=[];for(let e=0;e<6;e++)h[e]=f||m?m?n.image[e].image:n.image[e]:v(n.image[e],!0,a.maxCubemapSize),h[e]=$(n,h[e]);const _=h[0],g=o.convert(n.format,n.colorSpace),S=o.convert(n.type),T=A(n.internalFormat,g,S,n.colorSpace),R=!0!==n.isVideoTexture,b=void 0===d.__version||!0===l,L=c.dataReady;let P,U=C(n,_);if(O(e.TEXTURE_CUBE_MAP,n),f){R&&b&&r.texStorage2D(e.TEXTURE_CUBE_MAP,U,T,_.width,_.height);for(let t=0;t<6;t++){P=h[t].mipmaps;for(let i=0;i<P.length;i++){const a=P[i];n.format!==M?null!==g?R?L&&r.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,0,0,a.width,a.height,g,a.data):r.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,T,a.width,a.height,0,a.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):R?L&&r.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,0,0,a.width,a.height,g,S,a.data):r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,i,T,a.width,a.height,0,g,S,a.data)}}}else{if(P=n.mipmaps,R&&b){P.length>0&&U++;const t=Q(h[0]);r.texStorage2D(e.TEXTURE_CUBE_MAP,U,T,t.width,t.height)}for(let t=0;t<6;t++)if(m){R?L&&r.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,h[t].width,h[t].height,g,S,h[t].data):r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,T,h[t].width,h[t].height,0,g,S,h[t].data);for(let n=0;n<P.length;n++){const i=P[n].image[t].image;R?L&&r.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,n+1,0,0,i.width,i.height,g,S,i.data):r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,n+1,T,i.width,i.height,0,g,S,i.data)}}else{R?L&&r.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,0,0,g,S,h[t]):r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,T,g,S,h[t]);for(let n=0;n<P.length;n++){const i=P[n];R?L&&r.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,n+1,0,0,g,S,i.image[t]):r.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,n+1,T,g,S,i.image[t])}}}E(n)&&x(e.TEXTURE_CUBE_MAP),d.__version=c.version,n.onUpdate&&n.onUpdate(n)}t.__version=n.version}(s,t,n):r.bindTexture(e.TEXTURE_CUBE_MAP,s.__webglTexture,e.TEXTURE0+n)},this.rebindTextures=function(t,n,r){const a=i.get(t);void 0!==n&&z(a.__webglFramebuffer,t,t.texture,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,0),void 0!==r&&X(t)},this.setupRenderTarget=function(t){const n=t.texture,a=i.get(t),l=i.get(n);t.addEventListener("dispose",P);const c=t.textures,d=!0===t.isWebGLCubeRenderTarget,u=c.length>1;if(u||(void 0===l.__webglTexture&&(l.__webglTexture=e.createTexture()),l.__version=n.version,s.memory.textures++),d){a.__webglFramebuffer=[];for(let t=0;t<6;t++)if(n.mipmaps&&n.mipmaps.length>0){a.__webglFramebuffer[t]=[];for(let r=0;r<n.mipmaps.length;r++)a.__webglFramebuffer[t][r]=e.createFramebuffer()}else a.__webglFramebuffer[t]=e.createFramebuffer()}else{if(n.mipmaps&&n.mipmaps.length>0){a.__webglFramebuffer=[];for(let t=0;t<n.mipmaps.length;t++)a.__webglFramebuffer[t]=e.createFramebuffer()}else a.__webglFramebuffer=e.createFramebuffer();if(u)for(let t=0,n=c.length;t<n;t++){const n=i.get(c[t]);void 0===n.__webglTexture&&(n.__webglTexture=e.createTexture(),s.memory.textures++)}if(t.samples>0&&!1===Z(t)){a.__webglMultisampledFramebuffer=e.createFramebuffer(),a.__webglColorRenderbuffer=[],r.bindFramebuffer(e.FRAMEBUFFER,a.__webglMultisampledFramebuffer);for(let n=0;n<c.length;n++){const r=c[n];a.__webglColorRenderbuffer[n]=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,a.__webglColorRenderbuffer[n]);const i=o.convert(r.format,r.colorSpace),s=o.convert(r.type),l=A(r.internalFormat,i,s,r.colorSpace,!0===t.isXRRenderTarget),d=j(t);e.renderbufferStorageMultisample(e.RENDERBUFFER,d,l,t.width,t.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+n,e.RENDERBUFFER,a.__webglColorRenderbuffer[n])}e.bindRenderbuffer(e.RENDERBUFFER,null),t.depthBuffer&&(a.__webglDepthRenderbuffer=e.createRenderbuffer(),k(a.__webglDepthRenderbuffer,t,!0)),r.bindFramebuffer(e.FRAMEBUFFER,null)}}if(d){r.bindTexture(e.TEXTURE_CUBE_MAP,l.__webglTexture),O(e.TEXTURE_CUBE_MAP,n);for(let r=0;r<6;r++)if(n.mipmaps&&n.mipmaps.length>0)for(let i=0;i<n.mipmaps.length;i++)z(a.__webglFramebuffer[r][i],t,n,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+r,i);else z(a.__webglFramebuffer[r],t,n,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+r,0);E(n)&&x(e.TEXTURE_CUBE_MAP),r.unbindTexture()}else if(u){for(let n=0,o=c.length;n<o;n++){const o=c[n],s=i.get(o);let l=e.TEXTURE_2D;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(l=t.isWebGL3DRenderTarget?e.TEXTURE_3D:e.TEXTURE_2D_ARRAY),r.bindTexture(l,s.__webglTexture),O(l,o),z(a.__webglFramebuffer,t,o,e.COLOR_ATTACHMENT0+n,l,0),E(o)&&x(l)}r.unbindTexture()}else{let i=e.TEXTURE_2D;if((t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(i=t.isWebGL3DRenderTarget?e.TEXTURE_3D:e.TEXTURE_2D_ARRAY),r.bindTexture(i,l.__webglTexture),O(i,n),n.mipmaps&&n.mipmaps.length>0)for(let r=0;r<n.mipmaps.length;r++)z(a.__webglFramebuffer[r],t,n,e.COLOR_ATTACHMENT0,i,r);else z(a.__webglFramebuffer,t,n,e.COLOR_ATTACHMENT0,i,0);E(n)&&x(i),r.unbindTexture()}t.depthBuffer&&X(t)},this.updateRenderTargetMipmap=function(e){const t=e.textures;for(let n=0,a=t.length;n<a;n++){const a=t[n];if(E(a)){const t=R(e),n=i.get(a).__webglTexture;r.bindTexture(t,n),x(t),r.unbindTexture()}}},this.updateMultisampleRenderTarget=function(t){if(t.samples>0)if(!1===Z(t)){const n=t.textures,a=t.width,o=t.height;let s=e.COLOR_BUFFER_BIT;const l=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,d=i.get(t),u=n.length>1;if(u)for(let t=0;t<n.length;t++)r.bindFramebuffer(e.FRAMEBUFFER,d.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.RENDERBUFFER,null),r.bindFramebuffer(e.FRAMEBUFFER,d.__webglFramebuffer),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,null,0);r.bindFramebuffer(e.READ_FRAMEBUFFER,d.__webglMultisampledFramebuffer);const f=t.texture.mipmaps;f&&f.length>0?r.bindFramebuffer(e.DRAW_FRAMEBUFFER,d.__webglFramebuffer[0]):r.bindFramebuffer(e.DRAW_FRAMEBUFFER,d.__webglFramebuffer);for(let r=0;r<n.length;r++){if(t.resolveDepthBuffer&&(t.depthBuffer&&(s|=e.DEPTH_BUFFER_BIT),t.stencilBuffer&&t.resolveStencilBuffer&&(s|=e.STENCIL_BUFFER_BIT)),u){e.framebufferRenderbuffer(e.READ_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,d.__webglColorRenderbuffer[r]);const t=i.get(n[r]).__webglTexture;e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)}e.blitFramebuffer(0,0,a,o,0,0,a,o,s,e.NEAREST),!0===c&&(Y.length=0,q.length=0,Y.push(e.COLOR_ATTACHMENT0+r),t.depthBuffer&&!1===t.resolveDepthBuffer&&(Y.push(l),q.push(l),e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER,q)),e.invalidateFramebuffer(e.READ_FRAMEBUFFER,Y))}if(r.bindFramebuffer(e.READ_FRAMEBUFFER,null),r.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),u)for(let t=0;t<n.length;t++){r.bindFramebuffer(e.FRAMEBUFFER,d.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.RENDERBUFFER,d.__webglColorRenderbuffer[t]);const a=i.get(n[t]).__webglTexture;r.bindFramebuffer(e.FRAMEBUFFER,d.__webglFramebuffer),e.framebufferTexture2D(e.DRAW_FRAMEBUFFER,e.COLOR_ATTACHMENT0+t,e.TEXTURE_2D,a,0)}r.bindFramebuffer(e.DRAW_FRAMEBUFFER,d.__webglMultisampledFramebuffer)}else if(t.depthBuffer&&!1===t.resolveDepthBuffer&&c){const n=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT;e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER,[n])}},this.setupDepthRenderbuffer=X,this.setupFrameBufferTexture=z,this.useMultisampledRTT=Z}
```
</details>

### `g(e: any, t: any): HTMLElement | OffscreenCanvas`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `HTMLElement | OffscreenCanvas`

**Calls:**

- `Rt (from ./three.core.min.js)`

<details><summary>Code</summary>

```typescript
function g(e,t){return _?new OffscreenCanvas(e,t):Rt("canvas")}
```
</details>

### `v(e: any, t: any, n: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `Q`
- `Math.max`
- `Math.floor`
- `g`
- `o.getContext("2d").drawImage`
- `console.warn`

<details><summary>Code</summary>

```typescript
function v(e,t,n){let r=1;const i=Q(e);if((i.width>n||i.height>n)&&(r=n/Math.max(i.width,i.height)),r<1){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap||"undefined"!=typeof VideoFrame&&e instanceof VideoFrame){const n=Math.floor(r*i.width),a=Math.floor(r*i.height);void 0===f&&(f=g(n,a));const o=t?g(n,a):f;o.width=n,o.height=a;return o.getContext("2d").drawImage(e,0,0,n,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+i.width+"x"+i.height+") to ("+n+"x"+a+")."),o}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+i.width+"x"+i.height+")."),e}return e}
```
</details>

### `E(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function E(e){return e.generateMipmaps}
```
</details>

### `x(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.generateMipmap`

<details><summary>Code</summary>

```typescript
function x(t){e.generateMipmap(t)}
```
</details>

### `R(t: any): any`

**Parameters:**

- **`t`** `any`

**Returns:** `any`

<details><summary>Code</summary>

```typescript
function R(t){return t.isWebGLCubeRenderTarget?e.TEXTURE_CUBE_MAP:t.isWebGL3DRenderTarget?e.TEXTURE_3D:t.isWebGLArrayRenderTarget||t.isCompressedArrayTexture?e.TEXTURE_2D_ARRAY:e.TEXTURE_2D}
```
</details>

### `A(t: any, r: any, i: any, a: any, o: boolean): any`

**Parameters:**

- **`t`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `boolean`

**Returns:** `any`

**Calls:**

- `console.warn`
- `p.getTransfer`
- `n.get`

<details><summary>Code</summary>

```typescript
function A(t,r,i,a,o=!1){if(null!==t){if(void 0!==e[t])return e[t];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+t+"'")}let s=r;if(r===e.RED&&(i===e.FLOAT&&(s=e.R32F),i===e.HALF_FLOAT&&(s=e.R16F),i===e.UNSIGNED_BYTE&&(s=e.R8)),r===e.RED_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.R8UI),i===e.UNSIGNED_SHORT&&(s=e.R16UI),i===e.UNSIGNED_INT&&(s=e.R32UI),i===e.BYTE&&(s=e.R8I),i===e.SHORT&&(s=e.R16I),i===e.INT&&(s=e.R32I)),r===e.RG&&(i===e.FLOAT&&(s=e.RG32F),i===e.HALF_FLOAT&&(s=e.RG16F),i===e.UNSIGNED_BYTE&&(s=e.RG8)),r===e.RG_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.RG8UI),i===e.UNSIGNED_SHORT&&(s=e.RG16UI),i===e.UNSIGNED_INT&&(s=e.RG32UI),i===e.BYTE&&(s=e.RG8I),i===e.SHORT&&(s=e.RG16I),i===e.INT&&(s=e.RG32I)),r===e.RGB_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.RGB8UI),i===e.UNSIGNED_SHORT&&(s=e.RGB16UI),i===e.UNSIGNED_INT&&(s=e.RGB32UI),i===e.BYTE&&(s=e.RGB8I),i===e.SHORT&&(s=e.RGB16I),i===e.INT&&(s=e.RGB32I)),r===e.RGBA_INTEGER&&(i===e.UNSIGNED_BYTE&&(s=e.RGBA8UI),i===e.UNSIGNED_SHORT&&(s=e.RGBA16UI),i===e.UNSIGNED_INT&&(s=e.RGBA32UI),i===e.BYTE&&(s=e.RGBA8I),i===e.SHORT&&(s=e.RGBA16I),i===e.INT&&(s=e.RGBA32I)),r===e.RGB&&i===e.UNSIGNED_INT_5_9_9_9_REV&&(s=e.RGB9_E5),r===e.RGBA){const t=o?se:p.getTransfer(a);i===e.FLOAT&&(s=e.RGBA32F),i===e.HALF_FLOAT&&(s=e.RGBA16F),i===e.UNSIGNED_BYTE&&(s=t===m?e.SRGB8_ALPHA8:e.RGBA8),i===e.UNSIGNED_SHORT_4_4_4_4&&(s=e.RGBA4),i===e.UNSIGNED_SHORT_5_5_5_1&&(s=e.RGB5_A1)}return s!==e.R16F&&s!==e.R32F&&s!==e.RG16F&&s!==e.RG32F&&s!==e.RGBA16F&&s!==e.RGBA32F||n.get("EXT_color_buffer_float"),s}
```
</details>

### `b(t: any, n: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `console.warn`

<details><summary>Code</summary>

```typescript
function b(t,n){let r;return t?null===n||n===Tt||n===Mt?r=e.DEPTH24_STENCIL8:n===T?r=e.DEPTH32F_STENCIL8:n===xt&&(r=e.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):null===n||n===Tt||n===Mt?r=e.DEPTH_COMPONENT24:n===T?r=e.DEPTH_COMPONENT32F:n===xt&&(r=e.DEPTH_COMPONENT16),r}
```
</details>

### `C(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `E`
- `Math.log2`
- `Math.max`
- `Array.isArray`

<details><summary>Code</summary>

```typescript
function C(e,t){return!0===E(e)||e.isFramebufferTexture&&e.minFilter!==Te&&e.minFilter!==B?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}
```
</details>

### `L(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.removeEventListener`
- `complex_call_256066`
- `i.get`
- `h.get`
- `U`
- `Object.keys`
- `h.delete`
- `i.remove`
- `u.delete`

<details><summary>Code</summary>

```typescript
function L(e){const t=e.target;t.removeEventListener("dispose",L),function(e){const t=i.get(e);if(void 0===t.__webglInit)return;const n=e.source,r=h.get(n);if(r){const i=r[t.__cacheKey];i.usedTimes--,0===i.usedTimes&&U(e),0===Object.keys(r).length&&h.delete(n)}i.remove(e)}(t),t.isVideoTexture&&u.delete(t)}
```
</details>

### `P(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `n.removeEventListener`
- `complex_call_256373`
- `i.get`
- `t.depthTexture.dispose`
- `i.remove`
- `Array.isArray`
- `e.deleteFramebuffer`
- `e.deleteRenderbuffer`
- `e.deleteTexture`

<details><summary>Code</summary>

```typescript
function P(t){const n=t.target;n.removeEventListener("dispose",P),function(t){const n=i.get(t);t.depthTexture&&(t.depthTexture.dispose(),i.remove(t.depthTexture));if(t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++){if(Array.isArray(n.__webglFramebuffer[t]))for(let r=0;r<n.__webglFramebuffer[t].length;r++)e.deleteFramebuffer(n.__webglFramebuffer[t][r]);else e.deleteFramebuffer(n.__webglFramebuffer[t]);n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[t])}else{if(Array.isArray(n.__webglFramebuffer))for(let t=0;t<n.__webglFramebuffer.length;t++)e.deleteFramebuffer(n.__webglFramebuffer[t]);else e.deleteFramebuffer(n.__webglFramebuffer);if(n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer)for(let t=0;t<n.__webglColorRenderbuffer.length;t++)n.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer)}const r=t.textures;for(let t=0,n=r.length;t<n;t++){const n=i.get(r[t]);n.__webglTexture&&(e.deleteTexture(n.__webglTexture),s.memory.textures--),i.remove(r[t])}i.remove(t)}(n)}
```
</details>

### `U(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `i.get`
- `e.deleteTexture`
- `h.get`

<details><summary>Code</summary>

```typescript
function U(t){const n=i.get(t);e.deleteTexture(n.__webglTexture);const r=t.source;delete h.get(r)[n.__cacheKey],s.memory.textures--}
```
</details>

### `w(t: any, n: any): any`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `i.get`
- `complex_call_257724`
- `u.get`
- `u.set`
- `e.update`
- `console.warn`
- `V`
- `r.bindTexture`

<details><summary>Code</summary>

```typescript
function w(t,n){const a=i.get(t);if(t.isVideoTexture&&function(e){const t=s.render.frame;u.get(e)!==t&&(u.set(e,t),e.update())}(t),!1===t.isRenderTargetTexture&&!0!==t.isExternalTexture&&t.version>0&&a.__version!==t.version){const e=t.image;if(null===e)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==e.complete)return void V(a,t,n);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}else t.isExternalTexture&&(a.__webglTexture=t.sourceTexture?t.sourceTexture:null);r.bindTexture(e.TEXTURE_2D,a.__webglTexture,e.TEXTURE0+n)}
```
</details>

### `O(t: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `n.has`
- `console.warn`
- `e.texParameteri`
- `i.get`
- `n.get`
- `e.texParameterf`
- `Math.min`
- `a.getMaxAnisotropy`

<details><summary>Code</summary>

```typescript
function O(t,r){if(r.type!==T||!1!==n.has("OES_texture_float_linear")||r.magFilter!==B&&r.magFilter!==st&&r.magFilter!==lt&&r.magFilter!==ot&&r.minFilter!==B&&r.minFilter!==st&&r.minFilter!==lt&&r.minFilter!==ot||console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),e.texParameteri(t,e.TEXTURE_WRAP_S,y[r.wrapS]),e.texParameteri(t,e.TEXTURE_WRAP_T,y[r.wrapT]),t!==e.TEXTURE_3D&&t!==e.TEXTURE_2D_ARRAY||e.texParameteri(t,e.TEXTURE_WRAP_R,y[r.wrapR]),e.texParameteri(t,e.TEXTURE_MAG_FILTER,I[r.magFilter]),e.texParameteri(t,e.TEXTURE_MIN_FILTER,I[r.minFilter]),r.compareFunction&&(e.texParameteri(t,e.TEXTURE_COMPARE_MODE,e.COMPARE_REF_TO_TEXTURE),e.texParameteri(t,e.TEXTURE_COMPARE_FUNC,N[r.compareFunction])),!0===n.has("EXT_texture_filter_anisotropic")){if(r.magFilter===Te)return;if(r.minFilter!==lt&&r.minFilter!==ot)return;if(r.type===T&&!1===n.has("OES_texture_float_linear"))return;if(r.anisotropy>1||i.get(r).__currentAnisotropy){const o=n.get("EXT_texture_filter_anisotropic");e.texParameterf(t,o.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(r.anisotropy,a.getMaxAnisotropy())),i.get(r).__currentAnisotropy=r.anisotropy}}}
```
</details>

### `H(t: any, n: any): boolean`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `boolean`

**Calls:**

- `n.addEventListener`
- `h.get`
- `h.set`
- `complex_call_260006`
- `t.push`
- `t.join`
- `e.createTexture`
- `U`

<details><summary>Code</summary>

```typescript
function H(t,n){let r=!1;void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",L));const i=n.source;let a=h.get(i);void 0===a&&(a={},h.set(i,a));const o=function(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.wrapR||0),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.colorSpace),t.join()}(n);if(o!==t.__cacheKey){void 0===a[o]&&(a[o]={texture:e.createTexture(),usedTimes:0},s.memory.textures++,r=!0),a[o].usedTimes++;const i=a[t.__cacheKey];void 0!==i&&(a[t.__cacheKey].usedTimes--,0===i.usedTimes&&U(n)),t.__cacheKey=o,t.__webglTexture=a[o].texture}return r}
```
</details>

### `G(e: any, t: any, n: any): number`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `number`

**Calls:**

- `Math.floor`

<details><summary>Code</summary>

```typescript
function G(e,t,n){return Math.floor(Math.floor(e/n)/t)}
```
</details>

### `V(t: any, n: any, s: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `H`
- `r.bindTexture`
- `i.get`
- `r.activeTexture`
- `p.getPrimaries`
- `e.pixelStorei`
- `v`
- `$`
- `o.convert`
- `A`
- `O`
- `C`
- `b`
- `r.texStorage2D`
- `r.texImage2D`
- `r.texSubImage2D`
- `complex_call_262122`
- `o.sort`
- `G`
- `Math.max`
- `e.getParameter`
- `Math.floor`
- `Math.ceil`
- `t.clearUpdateRanges`
- `r.texStorage3D`
- `Et (from ./three.core.min.js)`
- `g.data.subarray`
- `r.compressedTexSubImage3D`
- `n.clearLayerUpdates`
- `r.compressedTexImage3D`
- `console.warn`
- `r.texSubImage3D`
- `r.texImage3D`
- `r.compressedTexSubImage2D`
- `r.compressedTexImage2D`
- `m.data.subarray`
- `Q`
- `E`
- `x`
- `n.onUpdate`

<details><summary>Code</summary>

```typescript
function V(t,n,s){let l=e.TEXTURE_2D;(n.isDataArrayTexture||n.isCompressedArrayTexture)&&(l=e.TEXTURE_2D_ARRAY),n.isData3DTexture&&(l=e.TEXTURE_3D);const c=H(t,n),d=n.source;r.bindTexture(l,t.__webglTexture,e.TEXTURE0+s);const u=i.get(d);if(d.version!==u.__version||!0===c){r.activeTexture(e.TEXTURE0+s);const t=p.getPrimaries(p.workingColorSpace),i=n.colorSpace===gt?null:p.getPrimaries(n.colorSpace),f=n.colorSpace===gt||t===i?e.NONE:e.BROWSER_DEFAULT_WEBGL;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,n.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,n.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,f);let m=v(n.image,!1,a.maxTextureSize);m=$(n,m);const h=o.convert(n.format,n.colorSpace),_=o.convert(n.type);let g,S=A(n.internalFormat,h,_,n.colorSpace,n.isVideoTexture);O(l,n);const T=n.mipmaps,R=!0!==n.isVideoTexture,L=void 0===u.__version||!0===c,P=d.dataReady,U=C(n,m);if(n.isDepthTexture)S=b(n.format===vt,n.type),L&&(R?r.texStorage2D(e.TEXTURE_2D,1,S,m.width,m.height):r.texImage2D(e.TEXTURE_2D,0,S,m.width,m.height,0,h,_,null));else if(n.isDataTexture)if(T.length>0){R&&L&&r.texStorage2D(e.TEXTURE_2D,U,S,T[0].width,T[0].height);for(let t=0,n=T.length;t<n;t++)g=T[t],R?P&&r.texSubImage2D(e.TEXTURE_2D,t,0,0,g.width,g.height,h,_,g.data):r.texImage2D(e.TEXTURE_2D,t,S,g.width,g.height,0,h,_,g.data);n.generateMipmaps=!1}else R?(L&&r.texStorage2D(e.TEXTURE_2D,U,S,m.width,m.height),P&&function(t,n,i,a){const o=t.updateRanges;if(0===o.length)r.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,i,a,n.data);else{o.sort((e,t)=>e.start-t.start);let s=0;for(let e=1;e<o.length;e++){const t=o[s],r=o[e],i=t.start+t.count,a=G(r.start,n.width,4),l=G(t.start,n.width,4);r.start<=i+1&&a===l&&G(r.start+r.count-1,n.width,4)===a?t.count=Math.max(t.count,r.start+r.count-t.start):(++s,o[s]=r)}o.length=s+1;const l=e.getParameter(e.UNPACK_ROW_LENGTH),c=e.getParameter(e.UNPACK_SKIP_PIXELS),d=e.getParameter(e.UNPACK_SKIP_ROWS);e.pixelStorei(e.UNPACK_ROW_LENGTH,n.width);for(let t=0,s=o.length;t<s;t++){const s=o[t],l=Math.floor(s.start/4),c=Math.ceil(s.count/4),d=l%n.width,u=Math.floor(l/n.width),f=c,p=1;e.pixelStorei(e.UNPACK_SKIP_PIXELS,d),e.pixelStorei(e.UNPACK_SKIP_ROWS,u),r.texSubImage2D(e.TEXTURE_2D,0,d,u,f,p,i,a,n.data)}t.clearUpdateRanges(),e.pixelStorei(e.UNPACK_ROW_LENGTH,l),e.pixelStorei(e.UNPACK_SKIP_PIXELS,c),e.pixelStorei(e.UNPACK_SKIP_ROWS,d)}}(n,m,h,_)):r.texImage2D(e.TEXTURE_2D,0,S,m.width,m.height,0,h,_,m.data);else if(n.isCompressedTexture)if(n.isCompressedArrayTexture){R&&L&&r.texStorage3D(e.TEXTURE_2D_ARRAY,U,S,T[0].width,T[0].height,m.depth);for(let t=0,i=T.length;t<i;t++)if(g=T[t],n.format!==M)if(null!==h)if(R){if(P)if(n.layerUpdates.size>0){const i=Et(g.width,g.height,n.format,n.type);for(const a of n.layerUpdates){const n=g.data.subarray(a*i/g.data.BYTES_PER_ELEMENT,(a+1)*i/g.data.BYTES_PER_ELEMENT);r.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,a,g.width,g.height,1,h,n)}n.clearLayerUpdates()}else r.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,0,g.width,g.height,m.depth,h,g.data)}else r.compressedTexImage3D(e.TEXTURE_2D_ARRAY,t,S,g.width,g.height,m.depth,0,g.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else R?P&&r.texSubImage3D(e.TEXTURE_2D_ARRAY,t,0,0,0,g.width,g.height,m.depth,h,_,g.data):r.texImage3D(e.TEXTURE_2D_ARRAY,t,S,g.width,g.height,m.depth,0,h,_,g.data)}else{R&&L&&r.texStorage2D(e.TEXTURE_2D,U,S,T[0].width,T[0].height);for(let t=0,i=T.length;t<i;t++)g=T[t],n.format!==M?null!==h?R?P&&r.compressedTexSubImage2D(e.TEXTURE_2D,t,0,0,g.width,g.height,h,g.data):r.compressedTexImage2D(e.TEXTURE_2D,t,S,g.width,g.height,0,g.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):R?P&&r.texSubImage2D(e.TEXTURE_2D,t,0,0,g.width,g.height,h,_,g.data):r.texImage2D(e.TEXTURE_2D,t,S,g.width,g.height,0,h,_,g.data)}else if(n.isDataArrayTexture)if(R){if(L&&r.texStorage3D(e.TEXTURE_2D_ARRAY,U,S,m.width,m.height,m.depth),P)if(n.layerUpdates.size>0){const t=Et(m.width,m.height,n.format,n.type);for(const i of n.layerUpdates){const n=m.data.subarray(i*t/m.data.BYTES_PER_ELEMENT,(i+1)*t/m.data.BYTES_PER_ELEMENT);r.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,i,m.width,m.height,1,h,_,n)}n.clearLayerUpdates()}else r.texSubImage3D(e.TEXTURE_2D_ARRAY,0,0,0,0,m.width,m.height,m.depth,h,_,m.data)}else r.texImage3D(e.TEXTURE_2D_ARRAY,0,S,m.width,m.height,m.depth,0,h,_,m.data);else if(n.isData3DTexture)R?(L&&r.texStorage3D(e.TEXTURE_3D,U,S,m.width,m.height,m.depth),P&&r.texSubImage3D(e.TEXTURE_3D,0,0,0,0,m.width,m.height,m.depth,h,_,m.data)):r.texImage3D(e.TEXTURE_3D,0,S,m.width,m.height,m.depth,0,h,_,m.data);else if(n.isFramebufferTexture){if(L)if(R)r.texStorage2D(e.TEXTURE_2D,U,S,m.width,m.height);else{let t=m.width,n=m.height;for(let i=0;i<U;i++)r.texImage2D(e.TEXTURE_2D,i,S,t,n,0,h,_,null),t>>=1,n>>=1}}else if(T.length>0){if(R&&L){const t=Q(T[0]);r.texStorage2D(e.TEXTURE_2D,U,S,t.width,t.height)}for(let t=0,n=T.length;t<n;t++)g=T[t],R?P&&r.texSubImage2D(e.TEXTURE_2D,t,0,0,h,_,g):r.texImage2D(e.TEXTURE_2D,t,S,h,_,g);n.generateMipmaps=!1}else if(R){if(L){const t=Q(m);r.texStorage2D(e.TEXTURE_2D,U,S,t.width,t.height)}P&&r.texSubImage2D(e.TEXTURE_2D,0,0,0,h,_,m)}else r.texImage2D(e.TEXTURE_2D,0,S,h,_,m);E(n)&&x(l),u.__version=d.version,n.onUpdate&&n.onUpdate(n)}t.__version=n.version}
```
</details>

### `z(t: any, n: any, a: any, s: any, c: any, d: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`a`** `any`
- **`s`** `any`
- **`c`** `any`
- **`d`** `any`

**Returns:** `void`

**Calls:**

- `o.convert`
- `A`
- `i.get`
- `Math.max`
- `r.texImage3D`
- `r.texImage2D`
- `r.bindFramebuffer`
- `Z`
- `l.framebufferTexture2DMultisampleEXT`
- `j`
- `e.framebufferTexture2D`

<details><summary>Code</summary>

```typescript
function z(t,n,a,s,c,d){const u=o.convert(a.format,a.colorSpace),f=o.convert(a.type),p=A(a.internalFormat,u,f,a.colorSpace),m=i.get(n),h=i.get(a);if(h.__renderTarget=n,!m.__hasExternalTextures){const t=Math.max(1,n.width>>d),i=Math.max(1,n.height>>d);c===e.TEXTURE_3D||c===e.TEXTURE_2D_ARRAY?r.texImage3D(c,d,p,t,i,n.depth,0,u,f,null):r.texImage2D(c,d,p,t,i,0,u,f,null)}r.bindFramebuffer(e.FRAMEBUFFER,t),Z(n)?l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,s,c,h.__webglTexture,0,j(n)):(c===e.TEXTURE_2D||c>=e.TEXTURE_CUBE_MAP_POSITIVE_X&&c<=e.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&e.framebufferTexture2D(e.FRAMEBUFFER,s,c,h.__webglTexture,d),r.bindFramebuffer(e.FRAMEBUFFER,null)}
```
</details>

### `k(t: any, n: any, r: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.bindRenderbuffer`
- `b`
- `j`
- `Z`
- `l.renderbufferStorageMultisampleEXT`
- `e.renderbufferStorageMultisample`
- `e.renderbufferStorage`
- `e.framebufferRenderbuffer`
- `o.convert`
- `A`

<details><summary>Code</summary>

```typescript
function k(t,n,r){if(e.bindRenderbuffer(e.RENDERBUFFER,t),n.depthBuffer){const i=n.depthTexture,a=i&&i.isDepthTexture?i.type:null,o=b(n.stencilBuffer,a),s=n.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,c=j(n);Z(n)?l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,c,o,n.width,n.height):r?e.renderbufferStorageMultisample(e.RENDERBUFFER,c,o,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,o,n.width,n.height),e.framebufferRenderbuffer(e.FRAMEBUFFER,s,e.RENDERBUFFER,t)}else{const t=n.textures;for(let i=0;i<t.length;i++){const a=t[i],s=o.convert(a.format,a.colorSpace),c=o.convert(a.type),d=A(a.internalFormat,s,c,a.colorSpace),u=j(n);r&&!1===Z(n)?e.renderbufferStorageMultisample(e.RENDERBUFFER,u,d,n.width,n.height):Z(n)?l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER,u,d,n.width,n.height):e.renderbufferStorage(e.RENDERBUFFER,d,n.width,n.height)}}e.bindRenderbuffer(e.RENDERBUFFER,null)}
```
</details>

### `W(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `r.bindFramebuffer`
- `i.get`
- `w`
- `j`
- `Z`
- `l.framebufferTexture2DMultisampleEXT`
- `e.framebufferTexture2D`

<details><summary>Code</summary>

```typescript
function W(t,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(r.bindFramebuffer(e.FRAMEBUFFER,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const a=i.get(n.depthTexture);a.__renderTarget=n,a.__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),w(n.depthTexture,0);const o=a.__webglTexture,s=j(n);if(n.depthTexture.format===St)Z(n)?l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,o,0,s):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,o,0);else{if(n.depthTexture.format!==vt)throw new Error("Unknown depthTexture format");Z(n)?l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,o,0,s):e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,o,0)}}
```
</details>

### `X(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `i.get`
- `n.__depthDisposeCallback`
- `e.removeEventListener`
- `e.addEventListener`
- `W`
- `r.bindFramebuffer`
- `e.createRenderbuffer`
- `k`
- `e.bindRenderbuffer`
- `e.framebufferRenderbuffer`

<details><summary>Code</summary>

```typescript
function X(t){const n=i.get(t),a=!0===t.isWebGLCubeRenderTarget;if(n.__boundDepthTexture!==t.depthTexture){const e=t.depthTexture;if(n.__depthDisposeCallback&&n.__depthDisposeCallback(),e){const t=()=>{delete n.__boundDepthTexture,delete n.__depthDisposeCallback,e.removeEventListener("dispose",t)};e.addEventListener("dispose",t),n.__depthDisposeCallback=t}n.__boundDepthTexture=e}if(t.depthTexture&&!n.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");const e=t.texture.mipmaps;e&&e.length>0?W(n.__webglFramebuffer[0],t):W(n.__webglFramebuffer,t)}else if(a){n.__webglDepthbuffer=[];for(let i=0;i<6;i++)if(r.bindFramebuffer(e.FRAMEBUFFER,n.__webglFramebuffer[i]),void 0===n.__webglDepthbuffer[i])n.__webglDepthbuffer[i]=e.createRenderbuffer(),k(n.__webglDepthbuffer[i],t,!1);else{const r=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,a=n.__webglDepthbuffer[i];e.bindRenderbuffer(e.RENDERBUFFER,a),e.framebufferRenderbuffer(e.FRAMEBUFFER,r,e.RENDERBUFFER,a)}}else{const i=t.texture.mipmaps;if(i&&i.length>0?r.bindFramebuffer(e.FRAMEBUFFER,n.__webglFramebuffer[0]):r.bindFramebuffer(e.FRAMEBUFFER,n.__webglFramebuffer),void 0===n.__webglDepthbuffer)n.__webglDepthbuffer=e.createRenderbuffer(),k(n.__webglDepthbuffer,t,!1);else{const r=t.stencilBuffer?e.DEPTH_STENCIL_ATTACHMENT:e.DEPTH_ATTACHMENT,i=n.__webglDepthbuffer;e.bindRenderbuffer(e.RENDERBUFFER,i),e.framebufferRenderbuffer(e.FRAMEBUFFER,r,e.RENDERBUFFER,i)}}r.bindFramebuffer(e.FRAMEBUFFER,null)}
```
</details>

### `t(): void`

**Returns:** `void`

**Calls:**

- `e.removeEventListener`

<details><summary>Code</summary>

```typescript
()=>{delete n.__boundDepthTexture,delete n.__depthDisposeCallback,e.removeEventListener("dispose",t)}
```
</details>

### `j(e: any): number`

**Parameters:**

- **`e`** `any`

**Returns:** `number`

**Calls:**

- `Math.min`

<details><summary>Code</summary>

```typescript
function j(e){return Math.min(a.maxSamples,e.samples)}
```
</details>

### `Z(e: any): boolean`

**Parameters:**

- **`e`** `any`

**Returns:** `boolean`

**Calls:**

- `i.get`
- `n.has`

<details><summary>Code</summary>

```typescript
function Z(e){const t=i.get(e);return e.samples>0&&!0===n.has("WEBGL_multisampled_render_to_texture")&&!1!==t.__useRenderToTexture}
```
</details>

### `$(e: any, t: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `any`

**Calls:**

- `p.getTransfer`
- `console.warn`
- `console.error`

<details><summary>Code</summary>

```typescript
function $(e,t){const n=e.colorSpace,r=e.format,i=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||n!==F&&n!==gt&&(p.getTransfer(n)===m?r===M&&i===S||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",n)),t}
```
</details>

### `Q(e: any): Gi`

**Parameters:**

- **`e`** `any`

**Returns:** `Gi`

<details><summary>Code</summary>

```typescript
function Q(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement?(d.width=e.naturalWidth||e.width,d.height=e.naturalHeight||e.height):"undefined"!=typeof VideoFrame&&e instanceof VideoFrame?(d.width=e.displayWidth,d.height=e.displayHeight):(d.width=e.width,d.height=e.height),d}
```
</details>

### `ea(e: any, t: any): { convert: (n: any, r?: string) => any; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `{ convert: (n: any, r?: string) => any; }`

**Calls:**

- `p.getTransfer`
- `t.get`

<details><summary>Code</summary>

```typescript
function ea(e,t){return{convert:function(n,r=gt){let i;const a=p.getTransfer(r);if(n===S)return e.UNSIGNED_BYTE;if(n===At)return e.UNSIGNED_SHORT_4_4_4_4;if(n===bt)return e.UNSIGNED_SHORT_5_5_5_1;if(n===Ct)return e.UNSIGNED_INT_5_9_9_9_REV;if(n===Lt)return e.BYTE;if(n===Pt)return e.SHORT;if(n===xt)return e.UNSIGNED_SHORT;if(n===v)return e.INT;if(n===Tt)return e.UNSIGNED_INT;if(n===T)return e.FLOAT;if(n===E)return e.HALF_FLOAT;if(n===Ut)return e.ALPHA;if(n===Dt)return e.RGB;if(n===M)return e.RGBA;if(n===St)return e.DEPTH_COMPONENT;if(n===vt)return e.DEPTH_STENCIL;if(n===wt)return e.RED;if(n===yt)return e.RED_INTEGER;if(n===It)return e.RG;if(n===Nt)return e.RG_INTEGER;if(n===Ot)return e.RGBA_INTEGER;if(n===Ft||n===Bt||n===Ht||n===Gt)if(a===m){if(i=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(n===Ft)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Bt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Ht)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Gt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=t.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(n===Ft)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Bt)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Ht)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Gt)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===Vt||n===zt||n===kt||n===Wt){if(i=t.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(n===Vt)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===zt)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===kt)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===Wt)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===Xt||n===Yt||n===Kt){if(i=t.get("WEBGL_compressed_texture_etc"),null===i)return null;if(n===Xt||n===Yt)return a===m?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(n===Kt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(n===qt||n===jt||n===Zt||n===$t||n===Qt||n===Jt||n===en||n===tn||n===nn||n===rn||n===an||n===on||n===sn||n===ln){if(i=t.get("WEBGL_compressed_texture_astc"),null===i)return null;if(n===qt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===jt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Zt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===$t)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Qt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===Jt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===en)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===tn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===nn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===rn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===an)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===on)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===sn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ln)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===cn||n===dn||n===un){if(i=t.get("EXT_texture_compression_bptc"),null===i)return null;if(n===cn)return a===m?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===dn)return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===un)return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(n===fn||n===pn||n===mn||n===hn){if(i=t.get("EXT_texture_compression_rgtc"),null===i)return null;if(n===cn)return i.COMPRESSED_RED_RGTC1_EXT;if(n===pn)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===mn)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===hn)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===Mt?e.UNSIGNED_INT_24_8:void 0!==e[n]?e[n]:null}}}
```
</details>

### `convert(n: any, r: string): any`

**Parameters:**

- **`n`** `any`
- **`r`** `string`

**Returns:** `any`

**Calls:**

- `p.getTransfer`
- `t.get`

<details><summary>Code</summary>

```typescript
function(n,r=gt){let i;const a=p.getTransfer(r);if(n===S)return e.UNSIGNED_BYTE;if(n===At)return e.UNSIGNED_SHORT_4_4_4_4;if(n===bt)return e.UNSIGNED_SHORT_5_5_5_1;if(n===Ct)return e.UNSIGNED_INT_5_9_9_9_REV;if(n===Lt)return e.BYTE;if(n===Pt)return e.SHORT;if(n===xt)return e.UNSIGNED_SHORT;if(n===v)return e.INT;if(n===Tt)return e.UNSIGNED_INT;if(n===T)return e.FLOAT;if(n===E)return e.HALF_FLOAT;if(n===Ut)return e.ALPHA;if(n===Dt)return e.RGB;if(n===M)return e.RGBA;if(n===St)return e.DEPTH_COMPONENT;if(n===vt)return e.DEPTH_STENCIL;if(n===wt)return e.RED;if(n===yt)return e.RED_INTEGER;if(n===It)return e.RG;if(n===Nt)return e.RG_INTEGER;if(n===Ot)return e.RGBA_INTEGER;if(n===Ft||n===Bt||n===Ht||n===Gt)if(a===m){if(i=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(n===Ft)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Bt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Ht)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Gt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=t.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(n===Ft)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Bt)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Ht)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Gt)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===Vt||n===zt||n===kt||n===Wt){if(i=t.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(n===Vt)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===zt)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===kt)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===Wt)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===Xt||n===Yt||n===Kt){if(i=t.get("WEBGL_compressed_texture_etc"),null===i)return null;if(n===Xt||n===Yt)return a===m?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(n===Kt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(n===qt||n===jt||n===Zt||n===$t||n===Qt||n===Jt||n===en||n===tn||n===nn||n===rn||n===an||n===on||n===sn||n===ln){if(i=t.get("WEBGL_compressed_texture_astc"),null===i)return null;if(n===qt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===jt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Zt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===$t)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Qt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===Jt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===en)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===tn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===nn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===rn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===an)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===on)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===sn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ln)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===cn||n===dn||n===un){if(i=t.get("EXT_texture_compression_bptc"),null===i)return null;if(n===cn)return a===m?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===dn)return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===un)return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(n===fn||n===pn||n===mn||n===hn){if(i=t.get("EXT_texture_compression_rgtc"),null===i)return null;if(n===cn)return i.COMPRESSED_RED_RGTC1_EXT;if(n===pn)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===mn)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===hn)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===Mt?e.UNSIGNED_INT_24_8:void 0!==e[n]?e[n]:null}
```
</details>

### `convert(n: any, r: string): any`

**Parameters:**

- **`n`** `any`
- **`r`** `string`

**Returns:** `any`

**Calls:**

- `p.getTransfer`
- `t.get`

<details><summary>Code</summary>

```typescript
function(n,r=gt){let i;const a=p.getTransfer(r);if(n===S)return e.UNSIGNED_BYTE;if(n===At)return e.UNSIGNED_SHORT_4_4_4_4;if(n===bt)return e.UNSIGNED_SHORT_5_5_5_1;if(n===Ct)return e.UNSIGNED_INT_5_9_9_9_REV;if(n===Lt)return e.BYTE;if(n===Pt)return e.SHORT;if(n===xt)return e.UNSIGNED_SHORT;if(n===v)return e.INT;if(n===Tt)return e.UNSIGNED_INT;if(n===T)return e.FLOAT;if(n===E)return e.HALF_FLOAT;if(n===Ut)return e.ALPHA;if(n===Dt)return e.RGB;if(n===M)return e.RGBA;if(n===St)return e.DEPTH_COMPONENT;if(n===vt)return e.DEPTH_STENCIL;if(n===wt)return e.RED;if(n===yt)return e.RED_INTEGER;if(n===It)return e.RG;if(n===Nt)return e.RG_INTEGER;if(n===Ot)return e.RGBA_INTEGER;if(n===Ft||n===Bt||n===Ht||n===Gt)if(a===m){if(i=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===i)return null;if(n===Ft)return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===Bt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===Ht)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===Gt)return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(i=t.get("WEBGL_compressed_texture_s3tc"),null===i)return null;if(n===Ft)return i.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Bt)return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Ht)return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Gt)return i.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===Vt||n===zt||n===kt||n===Wt){if(i=t.get("WEBGL_compressed_texture_pvrtc"),null===i)return null;if(n===Vt)return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===zt)return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===kt)return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===Wt)return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===Xt||n===Yt||n===Kt){if(i=t.get("WEBGL_compressed_texture_etc"),null===i)return null;if(n===Xt||n===Yt)return a===m?i.COMPRESSED_SRGB8_ETC2:i.COMPRESSED_RGB8_ETC2;if(n===Kt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:i.COMPRESSED_RGBA8_ETC2_EAC}if(n===qt||n===jt||n===Zt||n===$t||n===Qt||n===Jt||n===en||n===tn||n===nn||n===rn||n===an||n===on||n===sn||n===ln){if(i=t.get("WEBGL_compressed_texture_astc"),null===i)return null;if(n===qt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:i.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===jt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:i.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===Zt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:i.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===$t)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:i.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===Qt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:i.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===Jt)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:i.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===en)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:i.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===tn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:i.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===nn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:i.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===rn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:i.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===an)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:i.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===on)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:i.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===sn)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:i.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===ln)return a===m?i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:i.COMPRESSED_RGBA_ASTC_12x12_KHR}if(n===cn||n===dn||n===un){if(i=t.get("EXT_texture_compression_bptc"),null===i)return null;if(n===cn)return a===m?i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:i.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===dn)return i.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===un)return i.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}if(n===fn||n===pn||n===mn||n===hn){if(i=t.get("EXT_texture_compression_rgtc"),null===i)return null;if(n===cn)return i.COMPRESSED_RED_RGTC1_EXT;if(n===pn)return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===mn)return i.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===hn)return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return n===Mt?e.UNSIGNED_INT_24_8:void 0!==e[n]?e[n]:null}
```
</details>

### `na.init(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
init(e,t){if(null===this.texture){const n=new ta(e.texture);e.depthNear===t.depthNear&&e.depthFar===t.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}
```
</details>

### `na.getMesh(e: any): jn`

**Parameters:**

- **`e`** `any`

**Returns:** `jn`

<details><summary>Code</summary>

```typescript
getMesh(e){if(null!==this.texture&&null===this.mesh){const t=e.cameras[0].viewport,n=new l({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new o(new h(20,20),n)}return this.mesh}
```
</details>

### `na.reset(): void`

**Returns:** `void`

<details><summary>Code</summary>

```typescript
reset(){this.texture=null,this.mesh=null}
```
</details>

### `na.getDepthTexture(): ta`

**Returns:** `ta`

<details><summary>Code</summary>

```typescript
getDepthTexture(){return this.texture}
```
</details>

### `N(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `R.indexOf`
- `n.update`
- `n.dispatchEvent`

<details><summary>Code</summary>

```typescript
function N(e){const t=R.indexOf(e.inputSource);if(-1===t)return;const n=x[t];void 0!==n&&(n.update(e.inputSource,e.frame,d||s),n.dispatchEvent({type:e.type,data:e.inputSource}))}
```
</details>

### `O(): void`

**Returns:** `void`

**Calls:**

- `a.removeEventListener`
- `x[e].disconnect`
- `_.reset`
- `e.setRenderTarget`
- `z.stop`
- `e.setPixelRatio`
- `e.setSize`
- `r.dispatchEvent`

<details><summary>Code</summary>

```typescript
function O(){a.removeEventListener("select",N),a.removeEventListener("selectstart",N),a.removeEventListener("selectend",N),a.removeEventListener("squeeze",N),a.removeEventListener("squeezestart",N),a.removeEventListener("squeezeend",N),a.removeEventListener("end",O),a.removeEventListener("inputsourceschange",F);for(let e=0;e<x.length;e++){const t=R[e];null!==t&&(R[e]=null,x[e].disconnect(t))}w=null,y=null,_.reset();for(const e in g)delete g[e];e.setRenderTarget(E),m=null,p=null,f=null,a=null,T=null,z.stop(),r.isPresenting=!1,e.setPixelRatio(b),e.setSize(A.width,A.height,!1),r.dispatchEvent({type:"sessionend"})}
```
</details>

### `F(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `R.indexOf`
- `x[r].disconnect`
- `R.push`
- `i.connect`

<details><summary>Code</summary>

```typescript
function F(e){for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=R.indexOf(n);r>=0&&(R[r]=null,x[r].disconnect(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t];let r=R.indexOf(n);if(-1===r){for(let e=0;e<x.length;e++){if(e>=R.length){R.push(n),r=e;break}if(null===R[e]){R[e]=n,r=e;break}}if(-1===r)break}const i=x[r];i&&i.connect(n)}}
```
</details>

### `G(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.matrixWorld.copy`
- `e.matrixWorld.multiplyMatrices`
- `e.matrixWorldInverse.copy(e.matrixWorld).invert`

<details><summary>Code</summary>

```typescript
function G(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}
```
</details>

### `oa(e: any, t: any): { refreshFogUniforms: (t: any, n: any) => void; refreshMaterialUniforms: (e: any, i: any, a: any, o: any, s: any) => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `{ refreshFogUniforms: (t: any, n: any) => void; refreshMaterialUniforms: (e: any, i: any, a: any, o: any, s: any) => void; }`

**Calls:**

- `e.updateMatrix`
- `t.value.copy`
- `e.diffuse.value.copy`
- `e.emissive.value.copy(r.emissive).multiplyScalar`
- `n`
- `e.normalScale.value.copy`
- `e.normalScale.value.negate`
- `t.get`
- `ia.copy`
- `e.envMapRotation.value.setFromMatrix4`
- `aa.makeRotationFromEuler`
- `n.color.getRGB`
- `g (from ./three.core.min.js)`
- `r`
- `complex_call_295416`
- `complex_call_295518`
- `e.specular.value.copy`
- `Math.max`
- `complex_call_295651`
- `complex_call_296003`
- `e.sheenColor.value.copy(t.sheenColor).multiplyScalar`
- `e.clearcoatNormalScale.value.copy`
- `e.clearcoatNormalScale.value.negate`
- `e.transmissionSamplerSize.value.set`
- `e.attenuationColor.value.copy`
- `e.anisotropyVector.value.set`
- `Math.cos`
- `Math.sin`
- `e.specularColor.value.copy`
- `complex_call_298581`
- `complex_call_298700`
- `e.referencePosition.value.setFromMatrixPosition`
- `complex_call_298942`
- `complex_call_299093`
- `complex_call_299222`
- `complex_call_299539`
- `e.color.value.copy`

<details><summary>Code</summary>

```typescript
function oa(e,t){function n(e,t){!0===e.matrixAutoUpdate&&e.updateMatrix(),t.value.copy(e.matrix)}function r(e,r){e.opacity.value=r.opacity,r.color&&e.diffuse.value.copy(r.color),r.emissive&&e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(e.map.value=r.map,n(r.map,e.mapTransform)),r.alphaMap&&(e.alphaMap.value=r.alphaMap,n(r.alphaMap,e.alphaMapTransform)),r.bumpMap&&(e.bumpMap.value=r.bumpMap,n(r.bumpMap,e.bumpMapTransform),e.bumpScale.value=r.bumpScale,r.side===c&&(e.bumpScale.value*=-1)),r.normalMap&&(e.normalMap.value=r.normalMap,n(r.normalMap,e.normalMapTransform),e.normalScale.value.copy(r.normalScale),r.side===c&&e.normalScale.value.negate()),r.displacementMap&&(e.displacementMap.value=r.displacementMap,n(r.displacementMap,e.displacementMapTransform),e.displacementScale.value=r.displacementScale,e.displacementBias.value=r.displacementBias),r.emissiveMap&&(e.emissiveMap.value=r.emissiveMap,n(r.emissiveMap,e.emissiveMapTransform)),r.specularMap&&(e.specularMap.value=r.specularMap,n(r.specularMap,e.specularMapTransform)),r.alphaTest>0&&(e.alphaTest.value=r.alphaTest);const i=t.get(r),a=i.envMap,o=i.envMapRotation;a&&(e.envMap.value=a,ia.copy(o),ia.x*=-1,ia.y*=-1,ia.z*=-1,a.isCubeTexture&&!1===a.isRenderTargetTexture&&(ia.y*=-1,ia.z*=-1),e.envMapRotation.value.setFromMatrix4(aa.makeRotationFromEuler(ia)),e.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,e.reflectivity.value=r.reflectivity,e.ior.value=r.ior,e.refractionRatio.value=r.refractionRatio),r.lightMap&&(e.lightMap.value=r.lightMap,e.lightMapIntensity.value=r.lightMapIntensity,n(r.lightMap,e.lightMapTransform)),r.aoMap&&(e.aoMap.value=r.aoMap,e.aoMapIntensity.value=r.aoMapIntensity,n(r.aoMap,e.aoMapTransform))}return{refreshFogUniforms:function(t,n){n.color.getRGB(t.fogColor.value,g(e)),n.isFog?(t.fogNear.value=n.near,t.fogFar.value=n.far):n.isFogExp2&&(t.fogDensity.value=n.density)},refreshMaterialUniforms:function(e,i,a,o,s){i.isMeshBasicMaterial||i.isMeshLambertMaterial?r(e,i):i.isMeshToonMaterial?(r(e,i),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,i)):i.isMeshPhongMaterial?(r(e,i),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,i)):i.isMeshStandardMaterial?(r(e,i),function(e,t){e.metalness.value=t.metalness,t.metalnessMap&&(e.metalnessMap.value=t.metalnessMap,n(t.metalnessMap,e.metalnessMapTransform));e.roughness.value=t.roughness,t.roughnessMap&&(e.roughnessMap.value=t.roughnessMap,n(t.roughnessMap,e.roughnessMapTransform));t.envMap&&(e.envMapIntensity.value=t.envMapIntensity)}(e,i),i.isMeshPhysicalMaterial&&function(e,t,r){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap,n(t.sheenColorMap,e.sheenColorMapTransform)),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap,n(t.sheenRoughnessMap,e.sheenRoughnessMapTransform)));t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap,n(t.clearcoatMap,e.clearcoatMapTransform)),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap,n(t.clearcoatRoughnessMap,e.clearcoatRoughnessMapTransform)),t.clearcoatNormalMap&&(e.clearcoatNormalMap.value=t.clearcoatNormalMap,n(t.clearcoatNormalMap,e.clearcoatNormalMapTransform),e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),t.side===c&&e.clearcoatNormalScale.value.negate()));t.dispersion>0&&(e.dispersion.value=t.dispersion);t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap,n(t.iridescenceMap,e.iridescenceMapTransform)),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap,n(t.iridescenceThicknessMap,e.iridescenceThicknessMapTransform)));t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=r.texture,e.transmissionSamplerSize.value.set(r.width,r.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap,n(t.transmissionMap,e.transmissionMapTransform)),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap,n(t.thicknessMap,e.thicknessMapTransform)),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor));t.anisotropy>0&&(e.anisotropyVector.value.set(t.anisotropy*Math.cos(t.anisotropyRotation),t.anisotropy*Math.sin(t.anisotropyRotation)),t.anisotropyMap&&(e.anisotropyMap.value=t.anisotropyMap,n(t.anisotropyMap,e.anisotropyMapTransform)));e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap,n(t.specularColorMap,e.specularColorMapTransform));t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap,n(t.specularIntensityMap,e.specularIntensityMapTransform))}(e,i,s)):i.isMeshMatcapMaterial?(r(e,i),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,i)):i.isMeshDepthMaterial?r(e,i):i.isMeshDistanceMaterial?(r(e,i),function(e,n){const r=t.get(n).light;e.referencePosition.value.setFromMatrixPosition(r.matrixWorld),e.nearDistance.value=r.shadow.camera.near,e.farDistance.value=r.shadow.camera.far}(e,i)):i.isMeshNormalMaterial?r(e,i):i.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform))}(e,i),i.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,i)):i.isPointsMaterial?function(e,t,r,i){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*r,e.scale.value=.5*i,t.map&&(e.map.value=t.map,n(t.map,e.uvTransform));t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform));t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i,a,o):i.isSpriteMaterial?function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform));t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform));t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i):i.isShadowMaterial?(e.color.value.copy(i.color),e.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}
```
</details>

### `n(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `e.updateMatrix`
- `t.value.copy`

<details><summary>Code</summary>

```typescript
function n(e,t){!0===e.matrixAutoUpdate&&e.updateMatrix(),t.value.copy(e.matrix)}
```
</details>

### `r(e: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.diffuse.value.copy`
- `e.emissive.value.copy(r.emissive).multiplyScalar`
- `n`
- `e.normalScale.value.copy`
- `e.normalScale.value.negate`
- `t.get`
- `ia.copy`
- `e.envMapRotation.value.setFromMatrix4`
- `aa.makeRotationFromEuler`

<details><summary>Code</summary>

```typescript
function r(e,r){e.opacity.value=r.opacity,r.color&&e.diffuse.value.copy(r.color),r.emissive&&e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(e.map.value=r.map,n(r.map,e.mapTransform)),r.alphaMap&&(e.alphaMap.value=r.alphaMap,n(r.alphaMap,e.alphaMapTransform)),r.bumpMap&&(e.bumpMap.value=r.bumpMap,n(r.bumpMap,e.bumpMapTransform),e.bumpScale.value=r.bumpScale,r.side===c&&(e.bumpScale.value*=-1)),r.normalMap&&(e.normalMap.value=r.normalMap,n(r.normalMap,e.normalMapTransform),e.normalScale.value.copy(r.normalScale),r.side===c&&e.normalScale.value.negate()),r.displacementMap&&(e.displacementMap.value=r.displacementMap,n(r.displacementMap,e.displacementMapTransform),e.displacementScale.value=r.displacementScale,e.displacementBias.value=r.displacementBias),r.emissiveMap&&(e.emissiveMap.value=r.emissiveMap,n(r.emissiveMap,e.emissiveMapTransform)),r.specularMap&&(e.specularMap.value=r.specularMap,n(r.specularMap,e.specularMapTransform)),r.alphaTest>0&&(e.alphaTest.value=r.alphaTest);const i=t.get(r),a=i.envMap,o=i.envMapRotation;a&&(e.envMap.value=a,ia.copy(o),ia.x*=-1,ia.y*=-1,ia.z*=-1,a.isCubeTexture&&!1===a.isRenderTargetTexture&&(ia.y*=-1,ia.z*=-1),e.envMapRotation.value.setFromMatrix4(aa.makeRotationFromEuler(ia)),e.flipEnvMap.value=a.isCubeTexture&&!1===a.isRenderTargetTexture?-1:1,e.reflectivity.value=r.reflectivity,e.ior.value=r.ior,e.refractionRatio.value=r.refractionRatio),r.lightMap&&(e.lightMap.value=r.lightMap,e.lightMapIntensity.value=r.lightMapIntensity,n(r.lightMap,e.lightMapTransform)),r.aoMap&&(e.aoMap.value=r.aoMap,e.aoMapIntensity.value=r.aoMapIntensity,n(r.aoMap,e.aoMapTransform))}
```
</details>

### `refreshFogUniforms(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `n.color.getRGB`
- `g (from ./three.core.min.js)`

<details><summary>Code</summary>

```typescript
function(t,n){n.color.getRGB(t.fogColor.value,g(e)),n.isFog?(t.fogNear.value=n.near,t.fogFar.value=n.far):n.isFogExp2&&(t.fogDensity.value=n.density)}
```
</details>

### `refreshMaterialUniforms(e: any, i: any, a: any, o: any, s: any): void`

**Parameters:**

- **`e`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `r`
- `complex_call_295416`
- `complex_call_295518`
- `e.specular.value.copy`
- `Math.max`
- `complex_call_295651`
- `n`
- `complex_call_296003`
- `e.sheenColor.value.copy(t.sheenColor).multiplyScalar`
- `e.clearcoatNormalScale.value.copy`
- `e.clearcoatNormalScale.value.negate`
- `e.transmissionSamplerSize.value.set`
- `e.attenuationColor.value.copy`
- `e.anisotropyVector.value.set`
- `Math.cos`
- `Math.sin`
- `e.specularColor.value.copy`
- `complex_call_298581`
- `complex_call_298700`
- `t.get`
- `e.referencePosition.value.setFromMatrixPosition`
- `complex_call_298942`
- `e.diffuse.value.copy`
- `complex_call_299093`
- `complex_call_299222`
- `complex_call_299539`
- `e.color.value.copy`

<details><summary>Code</summary>

```typescript
function(e,i,a,o,s){i.isMeshBasicMaterial||i.isMeshLambertMaterial?r(e,i):i.isMeshToonMaterial?(r(e,i),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,i)):i.isMeshPhongMaterial?(r(e,i),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,i)):i.isMeshStandardMaterial?(r(e,i),function(e,t){e.metalness.value=t.metalness,t.metalnessMap&&(e.metalnessMap.value=t.metalnessMap,n(t.metalnessMap,e.metalnessMapTransform));e.roughness.value=t.roughness,t.roughnessMap&&(e.roughnessMap.value=t.roughnessMap,n(t.roughnessMap,e.roughnessMapTransform));t.envMap&&(e.envMapIntensity.value=t.envMapIntensity)}(e,i),i.isMeshPhysicalMaterial&&function(e,t,r){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap,n(t.sheenColorMap,e.sheenColorMapTransform)),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap,n(t.sheenRoughnessMap,e.sheenRoughnessMapTransform)));t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap,n(t.clearcoatMap,e.clearcoatMapTransform)),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap,n(t.clearcoatRoughnessMap,e.clearcoatRoughnessMapTransform)),t.clearcoatNormalMap&&(e.clearcoatNormalMap.value=t.clearcoatNormalMap,n(t.clearcoatNormalMap,e.clearcoatNormalMapTransform),e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),t.side===c&&e.clearcoatNormalScale.value.negate()));t.dispersion>0&&(e.dispersion.value=t.dispersion);t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap,n(t.iridescenceMap,e.iridescenceMapTransform)),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap,n(t.iridescenceThicknessMap,e.iridescenceThicknessMapTransform)));t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=r.texture,e.transmissionSamplerSize.value.set(r.width,r.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap,n(t.transmissionMap,e.transmissionMapTransform)),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap,n(t.thicknessMap,e.thicknessMapTransform)),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor));t.anisotropy>0&&(e.anisotropyVector.value.set(t.anisotropy*Math.cos(t.anisotropyRotation),t.anisotropy*Math.sin(t.anisotropyRotation)),t.anisotropyMap&&(e.anisotropyMap.value=t.anisotropyMap,n(t.anisotropyMap,e.anisotropyMapTransform)));e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap,n(t.specularColorMap,e.specularColorMapTransform));t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap,n(t.specularIntensityMap,e.specularIntensityMapTransform))}(e,i,s)):i.isMeshMatcapMaterial?(r(e,i),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,i)):i.isMeshDepthMaterial?r(e,i):i.isMeshDistanceMaterial?(r(e,i),function(e,n){const r=t.get(n).light;e.referencePosition.value.setFromMatrixPosition(r.matrixWorld),e.nearDistance.value=r.shadow.camera.near,e.farDistance.value=r.shadow.camera.far}(e,i)):i.isMeshNormalMaterial?r(e,i):i.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform))}(e,i),i.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,i)):i.isPointsMaterial?function(e,t,r,i){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*r,e.scale.value=.5*i,t.map&&(e.map.value=t.map,n(t.map,e.uvTransform));t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform));t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i,a,o):i.isSpriteMaterial?function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform));t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform));t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i):i.isShadowMaterial?(e.color.value.copy(i.color),e.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}
```
</details>

### `refreshFogUniforms(t: any, n: any): void`

**Parameters:**

- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `n.color.getRGB`
- `g (from ./three.core.min.js)`

<details><summary>Code</summary>

```typescript
function(t,n){n.color.getRGB(t.fogColor.value,g(e)),n.isFog?(t.fogNear.value=n.near,t.fogFar.value=n.far):n.isFogExp2&&(t.fogDensity.value=n.density)}
```
</details>

### `refreshMaterialUniforms(e: any, i: any, a: any, o: any, s: any): void`

**Parameters:**

- **`e`** `any`
- **`i`** `any`
- **`a`** `any`
- **`o`** `any`
- **`s`** `any`

**Returns:** `void`

**Calls:**

- `r`
- `complex_call_295416`
- `complex_call_295518`
- `e.specular.value.copy`
- `Math.max`
- `complex_call_295651`
- `n`
- `complex_call_296003`
- `e.sheenColor.value.copy(t.sheenColor).multiplyScalar`
- `e.clearcoatNormalScale.value.copy`
- `e.clearcoatNormalScale.value.negate`
- `e.transmissionSamplerSize.value.set`
- `e.attenuationColor.value.copy`
- `e.anisotropyVector.value.set`
- `Math.cos`
- `Math.sin`
- `e.specularColor.value.copy`
- `complex_call_298581`
- `complex_call_298700`
- `t.get`
- `e.referencePosition.value.setFromMatrixPosition`
- `complex_call_298942`
- `e.diffuse.value.copy`
- `complex_call_299093`
- `complex_call_299222`
- `complex_call_299539`
- `e.color.value.copy`

<details><summary>Code</summary>

```typescript
function(e,i,a,o,s){i.isMeshBasicMaterial||i.isMeshLambertMaterial?r(e,i):i.isMeshToonMaterial?(r(e,i),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,i)):i.isMeshPhongMaterial?(r(e,i),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,i)):i.isMeshStandardMaterial?(r(e,i),function(e,t){e.metalness.value=t.metalness,t.metalnessMap&&(e.metalnessMap.value=t.metalnessMap,n(t.metalnessMap,e.metalnessMapTransform));e.roughness.value=t.roughness,t.roughnessMap&&(e.roughnessMap.value=t.roughnessMap,n(t.roughnessMap,e.roughnessMapTransform));t.envMap&&(e.envMapIntensity.value=t.envMapIntensity)}(e,i),i.isMeshPhysicalMaterial&&function(e,t,r){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap,n(t.sheenColorMap,e.sheenColorMapTransform)),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap,n(t.sheenRoughnessMap,e.sheenRoughnessMapTransform)));t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap,n(t.clearcoatMap,e.clearcoatMapTransform)),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap,n(t.clearcoatRoughnessMap,e.clearcoatRoughnessMapTransform)),t.clearcoatNormalMap&&(e.clearcoatNormalMap.value=t.clearcoatNormalMap,n(t.clearcoatNormalMap,e.clearcoatNormalMapTransform),e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),t.side===c&&e.clearcoatNormalScale.value.negate()));t.dispersion>0&&(e.dispersion.value=t.dispersion);t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap,n(t.iridescenceMap,e.iridescenceMapTransform)),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap,n(t.iridescenceThicknessMap,e.iridescenceThicknessMapTransform)));t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=r.texture,e.transmissionSamplerSize.value.set(r.width,r.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap,n(t.transmissionMap,e.transmissionMapTransform)),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap,n(t.thicknessMap,e.thicknessMapTransform)),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor));t.anisotropy>0&&(e.anisotropyVector.value.set(t.anisotropy*Math.cos(t.anisotropyRotation),t.anisotropy*Math.sin(t.anisotropyRotation)),t.anisotropyMap&&(e.anisotropyMap.value=t.anisotropyMap,n(t.anisotropyMap,e.anisotropyMapTransform)));e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap,n(t.specularColorMap,e.specularColorMapTransform));t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap,n(t.specularIntensityMap,e.specularIntensityMapTransform))}(e,i,s)):i.isMeshMatcapMaterial?(r(e,i),function(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,i)):i.isMeshDepthMaterial?r(e,i):i.isMeshDistanceMaterial?(r(e,i),function(e,n){const r=t.get(n).light;e.referencePosition.value.setFromMatrixPosition(r.matrixWorld),e.nearDistance.value=r.shadow.camera.near,e.farDistance.value=r.shadow.camera.far}(e,i)):i.isMeshNormalMaterial?r(e,i):i.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform))}(e,i),i.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,i)):i.isPointsMaterial?function(e,t,r,i){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*r,e.scale.value=.5*i,t.map&&(e.map.value=t.map,n(t.map,e.uvTransform));t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform));t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i,a,o):i.isSpriteMaterial?function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map,n(t.map,e.mapTransform));t.alphaMap&&(e.alphaMap.value=t.alphaMap,n(t.alphaMap,e.alphaMapTransform));t.alphaTest>0&&(e.alphaTest.value=t.alphaTest)}(e,i):i.isShadowMaterial?(e.color.value.copy(i.color),e.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}
```
</details>

### `sa(e: any, t: any, n: any, r: any): { bind: (e: any, t: any) => void; update: (n: any, u: any) => void; dispose: () => void; }`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `{ bind: (e: any, t: any) => void; update: (n: any, u: any) => void; dispose: () => void; }`

**Calls:**

- `e.getParameter`
- `i.clone`
- `e.equals`
- `e.copy`
- `console.warn`
- `n.removeEventListener`
- `o.indexOf`
- `o.splice`
- `e.deleteBuffer`
- `r.uniformBlockBinding`
- `complex_call_301107`
- `Array.isArray`
- `c`
- `complex_call_301580`
- `complex_call_301600`
- `o.push`
- `console.error`
- `e.createBuffer`
- `e.bindBuffer`
- `e.bufferData`
- `e.bindBufferBase`
- `n.addEventListener`
- `r.updateUBOMapping`
- `complex_call_302135`
- `l`
- `e.bufferSubData`
- `o.toArray`

<details><summary>Code</summary>

```typescript
function sa(e,t,n,r){let i={},a={},o=[];const s=e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);function l(e,t,n,r){const i=e.value,a=t+"_"+n;if(void 0===r[a])return r[a]="number"==typeof i||"boolean"==typeof i?i:i.clone(),!0;{const e=r[a];if("number"==typeof i||"boolean"==typeof i){if(e!==i)return r[a]=i,!0}else if(!1===e.equals(i))return e.copy(i),!0}return!1}function c(e){const t={boundary:0,storage:0};return"number"==typeof e||"boolean"==typeof e?(t.boundary=4,t.storage=4):e.isVector2?(t.boundary=8,t.storage=8):e.isVector3||e.isColor?(t.boundary=16,t.storage=12):e.isVector4?(t.boundary=16,t.storage=16):e.isMatrix3?(t.boundary=48,t.storage=48):e.isMatrix4?(t.boundary=64,t.storage=64):e.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",e),t}function d(t){const n=t.target;n.removeEventListener("dispose",d);const r=o.indexOf(n.__bindingPointIndex);o.splice(r,1),e.deleteBuffer(i[n.id]),delete i[n.id],delete a[n.id]}return{bind:function(e,t){const n=t.program;r.uniformBlockBinding(e,n)},update:function(n,u){let f=i[n.id];void 0===f&&(!function(e){const t=e.uniforms;let n=0;const r=16;for(let e=0,i=t.length;e<i;e++){const i=Array.isArray(t[e])?t[e]:[t[e]];for(let e=0,t=i.length;e<t;e++){const t=i[e],a=Array.isArray(t.value)?t.value:[t.value];for(let e=0,i=a.length;e<i;e++){const i=c(a[e]),o=n%r,s=o%i.boundary,l=o+s;n+=s,0!==l&&r-l<i.storage&&(n+=r-l),t.__data=new Float32Array(i.storage/Float32Array.BYTES_PER_ELEMENT),t.__offset=n,n+=i.storage}}}const i=n%r;i>0&&(n+=r-i);e.__size=n,e.__cache={}}(n),f=function(t){const n=function(){for(let e=0;e<s;e++)if(-1===o.indexOf(e))return o.push(e),e;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();t.__bindingPointIndex=n;const r=e.createBuffer(),i=t.__size,a=t.usage;return e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,i,a),e.bindBuffer(e.UNIFORM_BUFFER,null),e.bindBufferBase(e.UNIFORM_BUFFER,n,r),r}(n),i[n.id]=f,n.addEventListener("dispose",d));const p=u.program;r.updateUBOMapping(n,p);const m=t.render.frame;a[n.id]!==m&&(!function(t){const n=i[t.id],r=t.uniforms,a=t.__cache;e.bindBuffer(e.UNIFORM_BUFFER,n);for(let t=0,n=r.length;t<n;t++){const n=Array.isArray(r[t])?r[t]:[r[t]];for(let r=0,i=n.length;r<i;r++){const i=n[r];if(!0===l(i,t,r,a)){const t=i.__offset,n=Array.isArray(i.value)?i.value:[i.value];let r=0;for(let a=0;a<n.length;a++){const o=n[a],s=c(o);"number"==typeof o||"boolean"==typeof o?(i.__data[0]=o,e.bufferSubData(e.UNIFORM_BUFFER,t+r,i.__data)):o.isMatrix3?(i.__data[0]=o.elements[0],i.__data[1]=o.elements[1],i.__data[2]=o.elements[2],i.__data[3]=0,i.__data[4]=o.elements[3],i.__data[5]=o.elements[4],i.__data[6]=o.elements[5],i.__data[7]=0,i.__data[8]=o.elements[6],i.__data[9]=o.elements[7],i.__data[10]=o.elements[8],i.__data[11]=0):(o.toArray(i.__data,r),r+=s.storage/Float32Array.BYTES_PER_ELEMENT)}e.bufferSubData(e.UNIFORM_BUFFER,t,i.__data)}}}e.bindBuffer(e.UNIFORM_BUFFER,null)}(n),a[n.id]=m)},dispose:function(){for(const t in i)e.deleteBuffer(i[t]);o=[],i={},a={}}}}
```
</details>

### `l(e: any, t: any, n: any, r: any): boolean`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `boolean`

**Calls:**

- `i.clone`
- `e.equals`
- `e.copy`

<details><summary>Code</summary>

```typescript
function l(e,t,n,r){const i=e.value,a=t+"_"+n;if(void 0===r[a])return r[a]="number"==typeof i||"boolean"==typeof i?i:i.clone(),!0;{const e=r[a];if("number"==typeof i||"boolean"==typeof i){if(e!==i)return r[a]=i,!0}else if(!1===e.equals(i))return e.copy(i),!0}return!1}
```
</details>

### `c(e: any): { boundary: number; storage: number; }`

**Parameters:**

- **`e`** `any`

**Returns:** `{ boundary: number; storage: number; }`

**Calls:**

- `console.warn`

<details><summary>Code</summary>

```typescript
function c(e){const t={boundary:0,storage:0};return"number"==typeof e||"boolean"==typeof e?(t.boundary=4,t.storage=4):e.isVector2?(t.boundary=8,t.storage=8):e.isVector3||e.isColor?(t.boundary=16,t.storage=12):e.isVector4?(t.boundary=16,t.storage=16):e.isMatrix3?(t.boundary=48,t.storage=48):e.isMatrix4?(t.boundary=64,t.storage=64):e.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",e),t}
```
</details>

### `d(t: any): void`

**Parameters:**

- **`t`** `any`

**Returns:** `void`

**Calls:**

- `n.removeEventListener`
- `o.indexOf`
- `o.splice`
- `e.deleteBuffer`

<details><summary>Code</summary>

```typescript
function d(t){const n=t.target;n.removeEventListener("dispose",d);const r=o.indexOf(n.__bindingPointIndex);o.splice(r,1),e.deleteBuffer(i[n.id]),delete i[n.id],delete a[n.id]}
```
</details>

### `bind(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `r.uniformBlockBinding`

<details><summary>Code</summary>

```typescript
function(e,t){const n=t.program;r.uniformBlockBinding(e,n)}
```
</details>

### `update(n: any, u: any): void`

**Parameters:**

- **`n`** `any`
- **`u`** `any`

**Returns:** `void`

**Calls:**

- `complex_call_301107`
- `Array.isArray`
- `c`
- `complex_call_301580`
- `complex_call_301600`
- `o.indexOf`
- `o.push`
- `console.error`
- `e.createBuffer`
- `e.bindBuffer`
- `e.bufferData`
- `e.bindBufferBase`
- `n.addEventListener`
- `r.updateUBOMapping`
- `complex_call_302135`
- `l`
- `e.bufferSubData`
- `o.toArray`

<details><summary>Code</summary>

```typescript
function(n,u){let f=i[n.id];void 0===f&&(!function(e){const t=e.uniforms;let n=0;const r=16;for(let e=0,i=t.length;e<i;e++){const i=Array.isArray(t[e])?t[e]:[t[e]];for(let e=0,t=i.length;e<t;e++){const t=i[e],a=Array.isArray(t.value)?t.value:[t.value];for(let e=0,i=a.length;e<i;e++){const i=c(a[e]),o=n%r,s=o%i.boundary,l=o+s;n+=s,0!==l&&r-l<i.storage&&(n+=r-l),t.__data=new Float32Array(i.storage/Float32Array.BYTES_PER_ELEMENT),t.__offset=n,n+=i.storage}}}const i=n%r;i>0&&(n+=r-i);e.__size=n,e.__cache={}}(n),f=function(t){const n=function(){for(let e=0;e<s;e++)if(-1===o.indexOf(e))return o.push(e),e;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();t.__bindingPointIndex=n;const r=e.createBuffer(),i=t.__size,a=t.usage;return e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,i,a),e.bindBuffer(e.UNIFORM_BUFFER,null),e.bindBufferBase(e.UNIFORM_BUFFER,n,r),r}(n),i[n.id]=f,n.addEventListener("dispose",d));const p=u.program;r.updateUBOMapping(n,p);const m=t.render.frame;a[n.id]!==m&&(!function(t){const n=i[t.id],r=t.uniforms,a=t.__cache;e.bindBuffer(e.UNIFORM_BUFFER,n);for(let t=0,n=r.length;t<n;t++){const n=Array.isArray(r[t])?r[t]:[r[t]];for(let r=0,i=n.length;r<i;r++){const i=n[r];if(!0===l(i,t,r,a)){const t=i.__offset,n=Array.isArray(i.value)?i.value:[i.value];let r=0;for(let a=0;a<n.length;a++){const o=n[a],s=c(o);"number"==typeof o||"boolean"==typeof o?(i.__data[0]=o,e.bufferSubData(e.UNIFORM_BUFFER,t+r,i.__data)):o.isMatrix3?(i.__data[0]=o.elements[0],i.__data[1]=o.elements[1],i.__data[2]=o.elements[2],i.__data[3]=0,i.__data[4]=o.elements[3],i.__data[5]=o.elements[4],i.__data[6]=o.elements[5],i.__data[7]=0,i.__data[8]=o.elements[6],i.__data[9]=o.elements[7],i.__data[10]=o.elements[8],i.__data[11]=0):(o.toArray(i.__data,r),r+=s.storage/Float32Array.BYTES_PER_ELEMENT)}e.bufferSubData(e.UNIFORM_BUFFER,t,i.__data)}}}e.bindBuffer(e.UNIFORM_BUFFER,null)}(n),a[n.id]=m)}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `e.deleteBuffer`

<details><summary>Code</summary>

```typescript
function(){for(const t in i)e.deleteBuffer(i[t]);o=[],i={},a={}}
```
</details>

### `bind(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `r.uniformBlockBinding`

<details><summary>Code</summary>

```typescript
function(e,t){const n=t.program;r.uniformBlockBinding(e,n)}
```
</details>

### `update(n: any, u: any): void`

**Parameters:**

- **`n`** `any`
- **`u`** `any`

**Returns:** `void`

**Calls:**

- `complex_call_301107`
- `Array.isArray`
- `c`
- `complex_call_301580`
- `complex_call_301600`
- `o.indexOf`
- `o.push`
- `console.error`
- `e.createBuffer`
- `e.bindBuffer`
- `e.bufferData`
- `e.bindBufferBase`
- `n.addEventListener`
- `r.updateUBOMapping`
- `complex_call_302135`
- `l`
- `e.bufferSubData`
- `o.toArray`

<details><summary>Code</summary>

```typescript
function(n,u){let f=i[n.id];void 0===f&&(!function(e){const t=e.uniforms;let n=0;const r=16;for(let e=0,i=t.length;e<i;e++){const i=Array.isArray(t[e])?t[e]:[t[e]];for(let e=0,t=i.length;e<t;e++){const t=i[e],a=Array.isArray(t.value)?t.value:[t.value];for(let e=0,i=a.length;e<i;e++){const i=c(a[e]),o=n%r,s=o%i.boundary,l=o+s;n+=s,0!==l&&r-l<i.storage&&(n+=r-l),t.__data=new Float32Array(i.storage/Float32Array.BYTES_PER_ELEMENT),t.__offset=n,n+=i.storage}}}const i=n%r;i>0&&(n+=r-i);e.__size=n,e.__cache={}}(n),f=function(t){const n=function(){for(let e=0;e<s;e++)if(-1===o.indexOf(e))return o.push(e),e;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();t.__bindingPointIndex=n;const r=e.createBuffer(),i=t.__size,a=t.usage;return e.bindBuffer(e.UNIFORM_BUFFER,r),e.bufferData(e.UNIFORM_BUFFER,i,a),e.bindBuffer(e.UNIFORM_BUFFER,null),e.bindBufferBase(e.UNIFORM_BUFFER,n,r),r}(n),i[n.id]=f,n.addEventListener("dispose",d));const p=u.program;r.updateUBOMapping(n,p);const m=t.render.frame;a[n.id]!==m&&(!function(t){const n=i[t.id],r=t.uniforms,a=t.__cache;e.bindBuffer(e.UNIFORM_BUFFER,n);for(let t=0,n=r.length;t<n;t++){const n=Array.isArray(r[t])?r[t]:[r[t]];for(let r=0,i=n.length;r<i;r++){const i=n[r];if(!0===l(i,t,r,a)){const t=i.__offset,n=Array.isArray(i.value)?i.value:[i.value];let r=0;for(let a=0;a<n.length;a++){const o=n[a],s=c(o);"number"==typeof o||"boolean"==typeof o?(i.__data[0]=o,e.bufferSubData(e.UNIFORM_BUFFER,t+r,i.__data)):o.isMatrix3?(i.__data[0]=o.elements[0],i.__data[1]=o.elements[1],i.__data[2]=o.elements[2],i.__data[3]=0,i.__data[4]=o.elements[3],i.__data[5]=o.elements[4],i.__data[6]=o.elements[5],i.__data[7]=0,i.__data[8]=o.elements[6],i.__data[9]=o.elements[7],i.__data[10]=o.elements[8],i.__data[11]=0):(o.toArray(i.__data,r),r+=s.storage/Float32Array.BYTES_PER_ELEMENT)}e.bufferSubData(e.UNIFORM_BUFFER,t,i.__data)}}}e.bindBuffer(e.UNIFORM_BUFFER,null)}(n),a[n.id]=m)}
```
</details>

### `dispose(): void`

**Returns:** `void`

**Calls:**

- `e.deleteBuffer`

<details><summary>Code</summary>

```typescript
function(){for(const t in i)e.deleteBuffer(i[t]);o=[],i={},a={}}
```
</details>

### `oe(): number`

**Returns:** `number`

<details><summary>Code</summary>

```typescript
function oe(){return null===w?Y:1}
```
</details>

### `Ie(e: any, n: any): any`

**Parameters:**

- **`e`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `t.getContext`

<details><summary>Code</summary>

```typescript
function Ie(e,n){return t.getContext(e,n)}
```
</details>

### `Ne(): void`

**Returns:** `void`

**Calls:**

- `se.init`
- `ce.buffers.depth.setReversed`

<details><summary>Code</summary>

```typescript
function Ne(){se=new ir(ye),se.init(),Ue=new ea(ye,se),le=new On(ye,se,e,Ue),ce=new Qi(ye,se),le.reversedDepthBuffer&&g&&ce.buffers.depth.setReversed(!0),de=new sr(ye),ue=new Hi,pe=new Ji(ye,se,ce,ue,le,Ue,de),me=new Bn(C),he=new rr(C),_e=new bn(ye),De=new In(ye,_e),ve=new ar(ye,_e,de,De),Ee=new cr(ye,ve,_e,de),Ce=new lr(ye,le,pe),Re=new Fn(ue),Se=new Bi(C,me,he,se,le,De,Re),Te=new oa(C,ue),Me=new ki,xe=new ji(se),be=new yn(C,me,he,ce,Ee,v,d),Ae=new Zi(C,Ee,le),we=new sa(ye,de,le,ce),Le=new Nn(ye,se,de),Pe=new or(ye,se,de),de.programs=Se.programs,C.capabilities=le,C.extensions=se,C.properties=ue,C.renderLists=Me,C.shadowMap=Ae,C.state=ce,C.info=de}
```
</details>

### `Fe(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `e.preventDefault`
- `console.log`

<details><summary>Code</summary>

```typescript
function Fe(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),L=!0}
```
</details>

### `Be(): void`

**Returns:** `void`

**Calls:**

- `console.log`
- `Ne`

<details><summary>Code</summary>

```typescript
function Be(){console.log("THREE.WebGLRenderer: Context Restored."),L=!1;const e=de.autoReset,t=Ae.enabled,n=Ae.autoUpdate,r=Ae.needsUpdate,i=Ae.type;Ne(),de.autoReset=e,Ae.enabled=t,Ae.autoUpdate=n,Ae.needsUpdate=r,Ae.type=i}
```
</details>

### `He(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `console.error`

<details><summary>Code</summary>

```typescript
function He(e){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}
```
</details>

### `Ge(e: any): void`

**Parameters:**

- **`e`** `any`

**Returns:** `void`

**Calls:**

- `t.removeEventListener`
- `complex_call_306332`
- `complex_call_306344`
- `ue.get`
- `t.forEach`
- `Se.releaseProgram`
- `Se.releaseShaderCache`
- `ue.remove`

<details><summary>Code</summary>

```typescript
function Ge(e){const t=e.target;t.removeEventListener("dispose",Ge),function(e){(function(e){const t=ue.get(e).programs;void 0!==t&&(t.forEach(function(e){Se.releaseProgram(e)}),e.isShaderMaterial&&Se.releaseShaderCache(e))})(e),ue.remove(e)}(t)}
```
</details>

### `Ve(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `$e`

<details><summary>Code</summary>

```typescript
function Ve(e,t,n){!0===e.transparent&&e.side===fe&&!1===e.forceSinglePass?(e.side=c,e.needsUpdate=!0,$e(e,t,n),e.side=_,e.needsUpdate=!0,$e(e,t,n),e.side=fe):$e(e,t,n)}
```
</details>

### `n(): void`

**Returns:** `void`

**Calls:**

- `r.forEach`
- `ue.get(e).currentProgram.isReady`
- `r.delete`
- `setTimeout`
- `t`

<details><summary>Code</summary>

```typescript
function n(){r.forEach(function(e){ue.get(e).currentProgram.isReady()&&r.delete(e)}),0!==r.size?setTimeout(n,10):t(e)}
```
</details>

### `ke(): void`

**Returns:** `void`

**Calls:**

- `Xe.stop`

<details><summary>Code</summary>

```typescript
function ke(){Xe.stop()}
```
</details>

### `We(): void`

**Returns:** `void`

**Calls:**

- `Xe.start`

<details><summary>Code</summary>

```typescript
function We(){Xe.start()}
```
</details>

### `Ye(e: any, t: any, n: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `e.layers.test`
- `e.update`
- `R.pushLight`
- `R.pushShadow`
- `Q.intersectsSprite`
- `re.setFromMatrixPosition(e.matrixWorld).applyMatrix4`
- `Ee.update`
- `x.push`
- `Q.intersectsObject`
- `e.computeBoundingSphere`
- `re.copy`
- `t.computeBoundingSphere`
- `re.applyMatrix4(e.matrixWorld).applyMatrix4`
- `Array.isArray`
- `Ye`

<details><summary>Code</summary>

```typescript
function Ye(e,t,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)R.pushLight(e),e.castShadow&&R.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||Q.intersectsSprite(e)){r&&re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(te);const t=Ee.update(e),i=e.material;i.visible&&x.push(e,t,i,n,re.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||Q.intersectsObject(e))){const t=Ee.update(e),i=e.material;if(r&&(void 0!==e.boundingSphere?(null===e.boundingSphere&&e.computeBoundingSphere(),re.copy(e.boundingSphere.center)):(null===t.boundingSphere&&t.computeBoundingSphere(),re.copy(t.boundingSphere.center)),re.applyMatrix4(e.matrixWorld).applyMatrix4(te)),Array.isArray(i)){const r=t.groups;for(let a=0,o=r.length;a<o;a++){const o=r[a],s=i[o.materialIndex];s&&s.visible&&x.push(e,t,s,n,re.z,o)}}else i.visible&&x.push(e,t,i,n,re.z,null)}const i=e.children;for(let e=0,a=i.length;e<a;e++)Ye(i[e],t,n,r)}
```
</details>

### `Ke(e: any, t: any, n: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `R.setupLightsView`
- `Re.setGlobalState`
- `ce.viewport`
- `O.copy`
- `je`
- `ce.buffers.depth.setTest`
- `ce.buffers.depth.setMask`
- `ce.buffers.color.setMask`
- `ce.setPolygonOffset`

<details><summary>Code</summary>

```typescript
function Ke(e,t,n,r){const i=e.opaque,a=e.transmissive,o=e.transparent;R.setupLightsView(n),!0===J&&Re.setGlobalState(C.clippingPlanes,n),r&&ce.viewport(O.copy(r)),i.length>0&&je(i,t,n),a.length>0&&je(a,t,n),o.length>0&&je(o,t,n),ce.buffers.depth.setTest(!0),ce.buffers.depth.setMask(!0),ce.buffers.color.setMask(!0),ce.setPolygonOffset(!1)}
```
</details>

### `qe(e: any, t: any, n: any, r: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`

**Returns:** `void`

**Calls:**

- `se.has`
- `i.setSize`
- `C.getRenderTarget`
- `C.getActiveCubeFace`
- `C.getActiveMipmapLevel`
- `C.setRenderTarget`
- `C.getClearColor`
- `C.getClearAlpha`
- `C.setClearColor`
- `C.clear`
- `be.render`
- `R.setupLightsView`
- `Re.setGlobalState`
- `je`
- `pe.updateMultisampleRenderTarget`
- `pe.updateRenderTargetMipmap`
- `o.layers.test`
- `Ze`

<details><summary>Code</summary>

```typescript
function qe(e,t,n,r){if(null!==(!0===n.isScene?n.overrideMaterial:null))return;void 0===R.state.transmissionRenderTarget[r.id]&&(R.state.transmissionRenderTarget[r.id]=new I(1,1,{generateMipmaps:!0,type:se.has("EXT_color_buffer_half_float")||se.has("EXT_color_buffer_float")?E:S,minFilter:ot,samples:4,stencilBuffer:o,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:p.workingColorSpace}));const i=R.state.transmissionRenderTarget[r.id],a=r.viewport||O;i.setSize(a.z*C.transmissionResolutionScale,a.w*C.transmissionResolutionScale);const s=C.getRenderTarget(),l=C.getActiveCubeFace(),d=C.getActiveMipmapLevel();C.setRenderTarget(i),C.getClearColor(V),z=C.getClearAlpha(),z<1&&C.setClearColor(16777215,.5),C.clear(),ae&&be.render(n);const u=C.toneMapping;C.toneMapping=D;const f=r.viewport;if(void 0!==r.viewport&&(r.viewport=void 0),R.setupLightsView(r),!0===J&&Re.setGlobalState(C.clippingPlanes,r),je(e,n,r),pe.updateMultisampleRenderTarget(i),pe.updateRenderTargetMipmap(i),!1===se.has("WEBGL_multisampled_render_to_texture")){let e=!1;for(let i=0,a=t.length;i<a;i++){const a=t[i],o=a.object,s=a.geometry,l=a.material,d=a.group;if(l.side===fe&&o.layers.test(r.layers)){const t=l.side;l.side=c,l.needsUpdate=!0,Ze(o,n,r,s,l,d),l.side=t,l.needsUpdate=!0,e=!0}}!0===e&&(pe.updateMultisampleRenderTarget(i),pe.updateRenderTargetMipmap(i))}C.setRenderTarget(s,l,d),C.setClearColor(V,z),void 0!==f&&(r.viewport=f),C.toneMapping=u}
```
</details>

### `je(e: any, t: any, n: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `void`

**Calls:**

- `o.layers.test`
- `Ze`

<details><summary>Code</summary>

```typescript
function je(e,t,n){const r=!0===t.isScene?t.overrideMaterial:null;for(let i=0,a=e.length;i<a;i++){const a=e[i],o=a.object,s=a.geometry,l=a.group;let c=a.material;!0===c.allowOverride&&null!==r&&(c=r),o.layers.test(n.layers)&&Ze(o,t,n,s,c,l)}}
```
</details>

### `Ze(e: any, t: any, n: any, r: any, i: any, a: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`
- **`r`** `any`
- **`i`** `any`
- **`a`** `any`

**Returns:** `void`

**Calls:**

- `e.onBeforeRender`
- `e.modelViewMatrix.multiplyMatrices`
- `e.normalMatrix.getNormalMatrix`
- `i.onBeforeRender`
- `C.renderBufferDirect`
- `e.onAfterRender`

<details><summary>Code</summary>

```typescript
function Ze(e,t,n,r,i,a){e.onBeforeRender(C,t,n,r,i,a),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),i.onBeforeRender(C,t,n,r,e,a),!0===i.transparent&&i.side===fe&&!1===i.forceSinglePass?(i.side=c,i.needsUpdate=!0,C.renderBufferDirect(n,t,r,i,e,a),i.side=_,i.needsUpdate=!0,C.renderBufferDirect(n,t,r,i,e,a),i.side=fe):C.renderBufferDirect(n,t,r,i,e,a),e.onAfterRender(C,t,n,r,i,a)}
```
</details>

### `$e(e: any, t: any, n: any): any`

**Parameters:**

- **`e`** `any`
- **`t`** `any`
- **`n`** `any`

**Returns:** `any`

**Calls:**

- `ue.get`
- `Se.getParameters`
- `Se.getProgramCacheKey`
- `(e.isMeshStandardMaterial?he:me).get`
- `e.addEventListener`
- `c.get`
- `Je`
- `Se.getUniforms`
- `e.onBeforeCompile`
- `Se.acquireProgram`
- `c.set`
- `complex_call_321323`

<details><summary>Code</summary>

```typescript
function $e(e,t,n){!0!==t.isScene&&(t=ie);const r=ue.get(e),i=R.state.lights,a=R.state.shadowsArray,o=i.state.version,s=Se.getParameters(e,i.state,a,t,n),l=Se.getProgramCacheKey(s);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=(e.isMeshStandardMaterial?he:me).get(e.envMap||r.environment),r.envMapRotation=null!==r.environment&&null===e.envMap?t.environmentRotation:e.envMapRotation,void 0===c&&(e.addEventListener("dispose",Ge),c=new Map,r.programs=c);let d=c.get(l);if(void 0!==d){if(r.currentProgram===d&&r.lightsStateVersion===o)return Je(e,s),d}else s.uniforms=Se.getUniforms(e),e.onBeforeCompile(s,C),d=Se.acquireProgram(s,l),c.set(l,d),r.uniforms=s.uniforms;const u=r.uniforms;return(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(u.clippingPlanes=Re.uniform),Je(e,s),r.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),r.lightsStateVersion=o,r.needsLights&&(u.ambientLightColor.value=i.state.ambient,u.lightProbe.value=i.state.probe,u.directionalLights.value=i.state.directional,u.directionalLightShadows.value=i.state.directionalShadow,u.spotLights.value=i.state.spot,u.spotLightShadows.value=i.state.spotShadow,u.rectAreaLights.value=i.state.rectArea,u.ltc_1.value=i.state.rectAreaLTC1,u.ltc_2.value=i.state.rectAreaLTC2,u.pointLights.value=i.state.point,u.pointLightShadows.value=i.state.pointShadow,u.hemisphereLights.value=i.state.hemi,u.directionalShadowMap.value=i.state.directionalShadowMap,u.directionalShadowMatrix.value=i.state.directionalShadowMatrix,u.spotShadowMap.value=i.state.spotShadowMap,u.spotLightMatrix.value=i.state.spotLightMatrix,u.spotLightMap.value=i.state.spotLightMap,u.pointShadowMap.value=i.state.pointShadowMap,u.pointShadowMatrix.value=i.state.pointShadowMatrix),r.currentProgram=d,r.uniformsList=null,d}
```
</details>

### `Qe(e: any): any`

**Parameters:**

- **`e`** `any`

**Returns:** `any`

**Calls:**

- `e.currentProgram.getUniforms`
- `mi.seqWithValue`

<details><summary>Code</summary>

```typescript
function Qe(e){if(null===e.uniformsList){const t=e.currentProgram.getUniforms();e.uniformsList=mi.seqWithValue(t.seq,e.uniforms)}return e.uniformsList}
```
</details>

### `Je(e: any, t: any): void`

**Parameters:**

- **`e`** `any`
- **`t`** `any`

**Returns:** `void`

**Calls:**

- `ue.get`

<details><summary>Code</summary>

```typescript
function Je(e,t){const n=ue.get(e);n.outputColorSpace=t.outputColorSpace,n.batching=t.batching,n.batchingColor=t.batchingColor,n.instancing=t.instancing,n.instancingColor=t.instancingColor,n.instancingMorph=t.instancingMorph,n.skinning=t.skinning,n.morphTargets=t.morphTargets,n.morphNormals=t.morphNormals,n.morphColors=t.morphColors,n.morphTargetsCount=t.morphTargetsCount,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas,n.vertexTangents=t.vertexTangents,n.toneMapping=t.toneMapping}
```
</details>


---

## Classes

### `$n`

<details><summary>Class Code</summary>

```ts
class $n{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100,i={}){const{size:a=256,position:o=Zn}=i;kn=this._renderer.getRenderTarget(),Wn=this._renderer.getActiveCubeFace(),Xn=this._renderer.getActiveMipmapLevel(),Yn=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,r,s,o),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=tr(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=er(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(kn,Wn,Xn),this._renderer.xr.enabled=Yn,e.scissorTest=!1,Jn(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===C||e.mapping===L?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),kn=this._renderer.getRenderTarget(),Wn=this._renderer.getActiveCubeFace(),Xn=this._renderer.getActiveMipmapLevel(),Yn=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:B,minFilter:B,generateMipmaps:!1,type:E,format:M,colorSpace:F,depthBuffer:!1},r=Qn(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Qn(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){const t=[],n=[],r=[];let i=e;const a=e-4+1+Hn.length;for(let o=0;o<a;o++){const a=Math.pow(2,i);n.push(a);let s=1/a;o>e-4?s=Hn[o-e+4-1]:0===o&&(s=0),r.push(s);const l=1/(a-2),c=-l,d=1+l,u=[c,c,d,c,d,d,c,c,d,d,c,d],f=6,p=6,m=3,h=2,_=1,g=new Float32Array(m*p*f),v=new Float32Array(h*p*f),E=new Float32Array(_*p*f);for(let e=0;e<f;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];g.set(r,m*p*e),v.set(u,h*p*e);const i=[e,e,e,e,e,e];E.set(i,_*p*e)}const S=new N;S.setAttribute("position",new O(g,m)),S.setAttribute("uv",new O(v,h)),S.setAttribute("faceIndex",new O(E,_)),t.push(S),i>4&&i--}return{lodPlanes:t,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(e,t,n){const r=new Float32Array(Gn),a=new i(0,1,0),o=new l({name:"SphericalGaussianBlur",defines:{n:Gn,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:a}},vertexShader:nr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1});return o}(r,e,t)}return r}_compileMaterial(e){const t=new o(this._lodPlanes[0],e);this._renderer.compile(t,Vn)}_sceneToCubeUV(e,t,n,r,i){const a=new U(90,1,t,n),l=[1,-1,1,1,1,1],d=[1,1,1,-1,-1,-1],u=this._renderer,f=u.autoClear,p=u.toneMapping;u.getClearColor(zn),u.toneMapping=D,u.autoClear=!1;u.state.buffers.depth.getReversed()&&(u.setRenderTarget(r),u.clearDepth(),u.setRenderTarget(null));const m=new w({name:"PMREM.Background",side:c,depthWrite:!1,depthTest:!1}),h=new o(new s,m);let _=!1;const g=e.background;g?g.isColor&&(m.color.copy(g),e.background=null,_=!0):(m.color.copy(zn),_=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(a.up.set(0,l[t],0),a.position.set(i.x,i.y,i.z),a.lookAt(i.x+d[t],i.y,i.z)):1===n?(a.up.set(0,0,l[t]),a.position.set(i.x,i.y,i.z),a.lookAt(i.x,i.y+d[t],i.z)):(a.up.set(0,l[t],0),a.position.set(i.x,i.y,i.z),a.lookAt(i.x,i.y,i.z+d[t]));const o=this._cubeSize;Jn(r,n*o,t>2?o:0,o,o),u.setRenderTarget(r),_&&u.render(h,a),u.render(e,a)}h.geometry.dispose(),h.material.dispose(),u.toneMapping=p,u.autoClear=f,e.background=g}_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===C||e.mapping===L;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=tr()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=er());const i=r?this._cubemapMaterial:this._equirectMaterial,a=new o(this._lodPlanes[0],i);i.uniforms.envMap.value=e;const s=this._cubeSize;Jn(t,0,0,3*s,2*s),n.setRenderTarget(t),n.render(a,Vn)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let t=1;t<r;t++){const n=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),i=jn[(r-t-1)%jn.length];this._blur(e,t-1,t,n,i)}t.autoClear=n}_blur(e,t,n,r,i){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,r,"latitudinal",i),this._halfBlur(a,e,n,n,r,"longitudinal",i)}_halfBlur(e,t,n,r,i,a,s){const l=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const d=new o(this._lodPlanes[r],c),u=c.uniforms,f=this._sizeLods[n]-1,p=isFinite(i)?Math.PI/(2*f):2*Math.PI/39,m=i/p,h=isFinite(i)?1+Math.floor(3*m):Gn;h>Gn&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${h} samples when the maximum is set to 20`);const _=[];let g=0;for(let e=0;e<Gn;++e){const t=e/m,n=Math.exp(-t*t/2);_.push(n),0===e?g+=n:e<h&&(g+=2*n)}for(let e=0;e<_.length;e++)_[e]=_[e]/g;u.envMap.value=e.texture,u.samples.value=h,u.weights.value=_,u.latitudinal.value="latitudinal"===a,s&&(u.poleAxis.value=s);const{_lodMax:v}=this;u.dTheta.value=p,u.mipInt.value=v-n;const E=this._sizeLods[r];Jn(t,3*E*(r>v-4?r-v+4:0),4*(this._cubeSize-E),3*E,2*E),l.setRenderTarget(t),l.render(d,Vn)}}
```
</details>

#### Methods

##### `fromScene(e: any, t: number, n: number, r: number, i: {}): zs`

<details><summary>Code</summary>

```ts
fromScene(e,t=0,n=.1,r=100,i={}){const{size:a=256,position:o=Zn}=i;kn=this._renderer.getRenderTarget(),Wn=this._renderer.getActiveCubeFace(),Xn=this._renderer.getActiveMipmapLevel(),Yn=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(a);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,r,s,o),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}
```
</details>

##### `fromEquirectangular(e: any, t: any): any`

<details><summary>Code</summary>

```ts
fromEquirectangular(e,t=null){return this._fromTexture(e,t)}
```
</details>

##### `fromCubemap(e: any, t: any): any`

<details><summary>Code</summary>

```ts
fromCubemap(e,t=null){return this._fromTexture(e,t)}
```
</details>

##### `compileCubemapShader(): void`

<details><summary>Code</summary>

```ts
compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=tr(),this._compileMaterial(this._cubemapMaterial))}
```
</details>

##### `compileEquirectangularShader(): void`

<details><summary>Code</summary>

```ts
compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=er(),this._compileMaterial(this._equirectMaterial))}
```
</details>

##### `dispose(): void`

<details><summary>Code</summary>

```ts
dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}
```
</details>

##### `_setSize(e: any): void`

<details><summary>Code</summary>

```ts
_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}
```
</details>

##### `_dispose(): void`

<details><summary>Code</summary>

```ts
_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}
```
</details>

##### `_cleanup(e: any): void`

<details><summary>Code</summary>

```ts
_cleanup(e){this._renderer.setRenderTarget(kn,Wn,Xn),this._renderer.xr.enabled=Yn,e.scissorTest=!1,Jn(e,0,0,e.width,e.height)}
```
</details>

##### `_fromTexture(e: any, t: any): any`

<details><summary>Code</summary>

```ts
_fromTexture(e,t){e.mapping===C||e.mapping===L?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),kn=this._renderer.getRenderTarget(),Wn=this._renderer.getActiveCubeFace(),Xn=this._renderer.getActiveMipmapLevel(),Yn=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}
```
</details>

##### `_allocateTargets(): zs`

<details><summary>Code</summary>

```ts
_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:B,minFilter:B,generateMipmaps:!1,type:E,format:M,colorSpace:F,depthBuffer:!1},r=Qn(e,t,n);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Qn(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function(e){const t=[],n=[],r=[];let i=e;const a=e-4+1+Hn.length;for(let o=0;o<a;o++){const a=Math.pow(2,i);n.push(a);let s=1/a;o>e-4?s=Hn[o-e+4-1]:0===o&&(s=0),r.push(s);const l=1/(a-2),c=-l,d=1+l,u=[c,c,d,c,d,d,c,c,d,d,c,d],f=6,p=6,m=3,h=2,_=1,g=new Float32Array(m*p*f),v=new Float32Array(h*p*f),E=new Float32Array(_*p*f);for(let e=0;e<f;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];g.set(r,m*p*e),v.set(u,h*p*e);const i=[e,e,e,e,e,e];E.set(i,_*p*e)}const S=new N;S.setAttribute("position",new O(g,m)),S.setAttribute("uv",new O(v,h)),S.setAttribute("faceIndex",new O(E,_)),t.push(S),i>4&&i--}return{lodPlanes:t,sizeLods:n,sigmas:r}}(r)),this._blurMaterial=function(e,t,n){const r=new Float32Array(Gn),a=new i(0,1,0),o=new l({name:"SphericalGaussianBlur",defines:{n:Gn,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:a}},vertexShader:nr(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1});return o}(r,e,t)}return r}
```
</details>

##### `_compileMaterial(e: any): void`

<details><summary>Code</summary>

```ts
_compileMaterial(e){const t=new o(this._lodPlanes[0],e);this._renderer.compile(t,Vn)}
```
</details>

##### `_sceneToCubeUV(e: any, t: any, n: any, r: any, i: any): void`

<details><summary>Code</summary>

```ts
_sceneToCubeUV(e,t,n,r,i){const a=new U(90,1,t,n),l=[1,-1,1,1,1,1],d=[1,1,1,-1,-1,-1],u=this._renderer,f=u.autoClear,p=u.toneMapping;u.getClearColor(zn),u.toneMapping=D,u.autoClear=!1;u.state.buffers.depth.getReversed()&&(u.setRenderTarget(r),u.clearDepth(),u.setRenderTarget(null));const m=new w({name:"PMREM.Background",side:c,depthWrite:!1,depthTest:!1}),h=new o(new s,m);let _=!1;const g=e.background;g?g.isColor&&(m.color.copy(g),e.background=null,_=!0):(m.color.copy(zn),_=!0);for(let t=0;t<6;t++){const n=t%3;0===n?(a.up.set(0,l[t],0),a.position.set(i.x,i.y,i.z),a.lookAt(i.x+d[t],i.y,i.z)):1===n?(a.up.set(0,0,l[t]),a.position.set(i.x,i.y,i.z),a.lookAt(i.x,i.y+d[t],i.z)):(a.up.set(0,l[t],0),a.position.set(i.x,i.y,i.z),a.lookAt(i.x,i.y,i.z+d[t]));const o=this._cubeSize;Jn(r,n*o,t>2?o:0,o,o),u.setRenderTarget(r),_&&u.render(h,a),u.render(e,a)}h.geometry.dispose(),h.material.dispose(),u.toneMapping=p,u.autoClear=f,e.background=g}
```
</details>

##### `_textureToCubeUV(e: any, t: any): void`

<details><summary>Code</summary>

```ts
_textureToCubeUV(e,t){const n=this._renderer,r=e.mapping===C||e.mapping===L;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=tr()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=er());const i=r?this._cubemapMaterial:this._equirectMaterial,a=new o(this._lodPlanes[0],i);i.uniforms.envMap.value=e;const s=this._cubeSize;Jn(t,0,0,3*s,2*s),n.setRenderTarget(t),n.render(a,Vn)}
```
</details>

##### `_applyPMREM(e: any): void`

<details><summary>Code</summary>

```ts
_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;const r=this._lodPlanes.length;for(let t=1;t<r;t++){const n=Math.sqrt(this._sigmas[t]*this._sigmas[t]-this._sigmas[t-1]*this._sigmas[t-1]),i=jn[(r-t-1)%jn.length];this._blur(e,t-1,t,n,i)}t.autoClear=n}
```
</details>

##### `_blur(e: any, t: any, n: any, r: any, i: any): void`

<details><summary>Code</summary>

```ts
_blur(e,t,n,r,i){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,r,"latitudinal",i),this._halfBlur(a,e,n,n,r,"longitudinal",i)}
```
</details>

##### `_halfBlur(e: any, t: any, n: any, r: any, i: any, a: any, s: any): void`

<details><summary>Code</summary>

```ts
_halfBlur(e,t,n,r,i,a,s){const l=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const d=new o(this._lodPlanes[r],c),u=c.uniforms,f=this._sizeLods[n]-1,p=isFinite(i)?Math.PI/(2*f):2*Math.PI/39,m=i/p,h=isFinite(i)?1+Math.floor(3*m):Gn;h>Gn&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${h} samples when the maximum is set to 20`);const _=[];let g=0;for(let e=0;e<Gn;++e){const t=e/m,n=Math.exp(-t*t/2);_.push(n),0===e?g+=n:e<h&&(g+=2*n)}for(let e=0;e<_.length;e++)_[e]=_[e]/g;u.envMap.value=e.texture,u.samples.value=h,u.weights.value=_,u.latitudinal.value="latitudinal"===a,s&&(u.poleAxis.value=s);const{_lodMax:v}=this;u.dTheta.value=p,u.mipInt.value=v-n;const E=this._sizeLods[r];Jn(t,3*E*(r>v-4?r-v+4:0),4*(this._cubeSize-E),3*E,2*E),l.setRenderTarget(t),l.render(d,Vn)}
```
</details>

### `li`

<details><summary>Class Code</summary>

```ts
class li{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.setValue=function(e){switch(e){case 5126:return Rr;case 35664:return Ar;case 35665:return br;case 35666:return Cr;case 35674:return Lr;case 35675:return Pr;case 35676:return Ur;case 5124:case 35670:return Dr;case 35667:case 35671:return wr;case 35668:case 35672:return yr;case 35669:case 35673:return Ir;case 5125:return Nr;case 36294:return Or;case 36295:return Fr;case 36296:return Br;case 35678:case 36198:case 36298:case 36306:case 35682:return Hr;case 35679:case 36299:case 36307:return Gr;case 35680:case 36300:case 36308:case 36293:return Vr;case 36289:case 36303:case 36311:case 36292:return zr}}(t.type)}}
```
</details>

### `ci`

<details><summary>Class Code</summary>

```ts
class ci{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=function(e){switch(e){case 5126:return kr;case 35664:return Wr;case 35665:return Xr;case 35666:return Yr;case 35674:return Kr;case 35675:return qr;case 35676:return jr;case 5124:case 35670:return Zr;case 35667:case 35671:return $r;case 35668:case 35672:return Qr;case 35669:case 35673:return Jr;case 5125:return ei;case 36294:return ti;case 36295:return ni;case 36296:return ri;case 35678:case 36198:case 36298:case 36306:case 35682:return ii;case 35679:case 36299:case 36307:return ai;case 35680:case 36300:case 36308:case 36293:return oi;case 36289:case 36303:case 36311:case 36292:return si}}(t.type)}}
```
</details>

### `di`

<details><summary>Class Code</summary>

```ts
class di{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const r=this.seq;for(let i=0,a=r.length;i!==a;++i){const a=r[i];a.setValue(e,t[a.id],n)}}}
```
</details>

#### Methods

##### `setValue(e: any, t: any, n: any): void`

<details><summary>Code</summary>

```ts
setValue(e,t,n){const r=this.seq;for(let i=0,a=r.length;i!==a;++i){const a=r[i];a.setValue(e,t[a.id],n)}}
```
</details>

### `mi`

<details><summary>Class Code</summary>

```ts
class mi{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<n;++r){const n=e.getActiveUniform(t,r);pi(n,e.getUniformLocation(t,n.name),this)}}setValue(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)}setOptional(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)}static upload(e,t,n,r){for(let i=0,a=t.length;i!==a;++i){const a=t[i],o=n[a.id];!1!==o.needsUpdate&&a.setValue(e,o.value,r)}}static seqWithValue(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n}}
```
</details>

#### Methods

##### `setValue(e: any, t: any, n: any, r: any): void`

<details><summary>Code</summary>

```ts
setValue(e,t,n,r){const i=this.map[t];void 0!==i&&i.setValue(e,n,r)}
```
</details>

##### `setOptional(e: any, t: any, n: any): void`

<details><summary>Code</summary>

```ts
setOptional(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)}
```
</details>

##### `upload(e: any, t: any, n: any, r: any): void`

<details><summary>Code</summary>

```ts
static upload(e,t,n,r){for(let i=0,a=t.length;i!==a;++i){const a=t[i],o=n[a.id];!1!==o.needsUpdate&&a.setValue(e,o.value,r)}}
```
</details>

##### `seqWithValue(e: any, t: any): any[]`

<details><summary>Code</summary>

```ts
static seqWithValue(e,t){const n=[];for(let r=0,i=e.length;r!==i;++r){const i=e[r];i.id in t&&n.push(i)}return n}
```
</details>

### `Oi`

<details><summary>Class Code</summary>

```ts
class Oi{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return!1===a.has(r)&&(a.add(r),r.usedTimes++),!1===a.has(i)&&(a.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return void 0===n&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return void 0===n&&(n=new Fi(e),t.set(e,n)),n}}
```
</details>

#### Methods

##### `update(e: any): this`

<details><summary>Code</summary>

```ts
update(e){const t=e.vertexShader,n=e.fragmentShader,r=this._getShaderStage(t),i=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return!1===a.has(r)&&(a.add(r),r.usedTimes++),!1===a.has(i)&&(a.add(i),i.usedTimes++),this}
```
</details>

##### `remove(e: any): this`

<details><summary>Code</summary>

```ts
remove(e){const t=this.materialCache.get(e);for(const e of t)e.usedTimes--,0===e.usedTimes&&this.shaderCache.delete(e.code);return this.materialCache.delete(e),this}
```
</details>

##### `getVertexShaderID(e: any): any`

<details><summary>Code</summary>

```ts
getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}
```
</details>

##### `getFragmentShaderID(e: any): any`

<details><summary>Code</summary>

```ts
getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}
```
</details>

##### `dispose(): void`

<details><summary>Code</summary>

```ts
dispose(){this.shaderCache.clear(),this.materialCache.clear()}
```
</details>

##### `_getShaderCacheForMaterial(e: any): any`

<details><summary>Code</summary>

```ts
_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return void 0===n&&(n=new Set,t.set(e,n)),n}
```
</details>

##### `_getShaderStage(e: any): any`

<details><summary>Code</summary>

```ts
_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return void 0===n&&(n=new Fi(e),t.set(e,n)),n}
```
</details>

### `Fi`

<details><summary>Class Code</summary>

```ts
class Fi{constructor(e){this.id=Ni++,this.code=e,this.usedTimes=0}}
```
</details>

### `ta`

<details><summary>Class Code</summary>

```ts
class ta extends j{constructor(e=null){super(),this.sourceTexture=e,this.isExternalTexture=!0}}
```
</details>

### `na`

<details><summary>Class Code</summary>

```ts
class na{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t){if(null===this.texture){const n=new ta(e.texture);e.depthNear===t.depthNear&&e.depthFar===t.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}getMesh(e){if(null!==this.texture&&null===this.mesh){const t=e.cameras[0].viewport,n=new l({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new o(new h(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}
```
</details>

#### Methods

##### `init(e: any, t: any): void`

<details><summary>Code</summary>

```ts
init(e,t){if(null===this.texture){const n=new ta(e.texture);e.depthNear===t.depthNear&&e.depthFar===t.depthFar||(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}
```
</details>

##### `getMesh(e: any): jn`

<details><summary>Code</summary>

```ts
getMesh(e){if(null!==this.texture&&null===this.mesh){const t=e.cameras[0].viewport,n=new l({vertexShader:"\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",fragmentShader:"\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new o(new h(20,20),n)}return this.mesh}
```
</details>

##### `reset(): void`

<details><summary>Code</summary>

```ts
reset(){this.texture=null,this.mesh=null}
```
</details>

##### `getDepthTexture(): ta`

<details><summary>Code</summary>

```ts
getDepthTexture(){return this.texture}
```
</details>

### `ra`

<details><summary>Class Code</summary>

```ts
class ra extends _n{constructor(e,n){super();const r=this;let a=null,o=1,s=null,l="local-floor",c=1,d=null,u=null,f=null,p=null,m=null,h=null;const _=new na,g={},v=n.getContextAttributes();let E=null,T=null;const x=[],R=[],A=new t;let b=null;const C=new U;C.viewport=new k;const L=new U;L.viewport=new k;const P=[C,L],D=new gn;let w=null,y=null;function N(e){const t=R.indexOf(e.inputSource);if(-1===t)return;const n=x[t];void 0!==n&&(n.update(e.inputSource,e.frame,d||s),n.dispatchEvent({type:e.type,data:e.inputSource}))}function O(){a.removeEventListener("select",N),a.removeEventListener("selectstart",N),a.removeEventListener("selectend",N),a.removeEventListener("squeeze",N),a.removeEventListener("squeezestart",N),a.removeEventListener("squeezeend",N),a.removeEventListener("end",O),a.removeEventListener("inputsourceschange",F);for(let e=0;e<x.length;e++){const t=R[e];null!==t&&(R[e]=null,x[e].disconnect(t))}w=null,y=null,_.reset();for(const e in g)delete g[e];e.setRenderTarget(E),m=null,p=null,f=null,a=null,T=null,z.stop(),r.isPresenting=!1,e.setPixelRatio(b),e.setSize(A.width,A.height,!1),r.dispatchEvent({type:"sessionend"})}function F(e){for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=R.indexOf(n);r>=0&&(R[r]=null,x[r].disconnect(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t];let r=R.indexOf(n);if(-1===r){for(let e=0;e<x.length;e++){if(e>=R.length){R.push(n),r=e;break}if(null===R[e]){R[e]=n,r=e;break}}if(-1===r)break}const i=x[r];i&&i.connect(n)}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=x[e];return void 0===t&&(t=new vn,x[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=x[e];return void 0===t&&(t=new vn,x[e]=t),t.getGripSpace()},this.getHand=function(e){let t=x[e];return void 0===t&&(t=new vn,x[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){o=e,!0===r.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){l=e,!0===r.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return d||s},this.setReferenceSpace=function(e){d=e},this.getBaseLayer=function(){return null!==p?p:m},this.getBinding=function(){return f},this.getFrame=function(){return h},this.getSession=function(){return a},this.setSession=async function(t){if(a=t,null!==a){E=e.getRenderTarget(),a.addEventListener("select",N),a.addEventListener("selectstart",N),a.addEventListener("selectend",N),a.addEventListener("squeeze",N),a.addEventListener("squeezestart",N),a.addEventListener("squeezeend",N),a.addEventListener("end",O),a.addEventListener("inputsourceschange",F),!0!==v.xrCompatible&&await n.makeXRCompatible(),b=e.getPixelRatio(),e.getSize(A),"undefined"!=typeof XRWebGLBinding&&(f=new XRWebGLBinding(a,n));if(null!==f&&"createProjectionLayer"in XRWebGLBinding.prototype){let t=null,r=null,i=null;v.depth&&(i=v.stencil?n.DEPTH24_STENCIL8:n.DEPTH_COMPONENT24,t=v.stencil?vt:St,r=v.stencil?Mt:Tt);const s={colorFormat:n.RGBA8,depthFormat:i,scaleFactor:o};p=f.createProjectionLayer(s),a.updateRenderState({layers:[p]}),e.setPixelRatio(1),e.setSize(p.textureWidth,p.textureHeight,!1),T=new I(p.textureWidth,p.textureHeight,{format:M,type:S,depthTexture:new q(p.textureWidth,p.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,t),stencilBuffer:v.stencil,colorSpace:e.outputColorSpace,samples:v.antialias?4:0,resolveDepthBuffer:!1===p.ignoreDepthValues,resolveStencilBuffer:!1===p.ignoreDepthValues})}else{const t={antialias:v.antialias,alpha:!0,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:o};m=new XRWebGLLayer(a,n,t),a.updateRenderState({baseLayer:m}),e.setPixelRatio(1),e.setSize(m.framebufferWidth,m.framebufferHeight,!1),T=new I(m.framebufferWidth,m.framebufferHeight,{format:M,type:S,colorSpace:e.outputColorSpace,stencilBuffer:v.stencil,resolveDepthBuffer:!1===m.ignoreDepthValues,resolveStencilBuffer:!1===m.ignoreDepthValues})}T.isXRRenderTarget=!0,this.setFoveation(c),d=null,s=await a.requestReferenceSpace(l),z.setContext(a),z.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(null!==a)return a.environmentBlendMode},this.getDepthTexture=function(){return _.getDepthTexture()};const B=new i,H=new i;function G(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===a)return;let t=e.near,n=e.far;null!==_.texture&&(_.depthNear>0&&(t=_.depthNear),_.depthFar>0&&(n=_.depthFar)),D.near=L.near=C.near=t,D.far=L.far=C.far=n,w===D.near&&y===D.far||(a.updateRenderState({depthNear:D.near,depthFar:D.far}),w=D.near,y=D.far),D.layers.mask=6|e.layers.mask,C.layers.mask=3&D.layers.mask,L.layers.mask=5&D.layers.mask;const r=e.parent,i=D.cameras;G(D,r);for(let e=0;e<i.length;e++)G(i[e],r);2===i.length?function(e,t,n){B.setFromMatrixPosition(t.matrixWorld),H.setFromMatrixPosition(n.matrixWorld);const r=B.distanceTo(H),i=t.projectionMatrix.elements,a=n.projectionMatrix.elements,o=i[14]/(i[10]-1),s=i[14]/(i[10]+1),l=(i[9]+1)/i[5],c=(i[9]-1)/i[5],d=(i[8]-1)/i[0],u=(a[8]+1)/a[0],f=o*d,p=o*u,m=r/(-d+u),h=m*-d;if(t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(h),e.translateZ(m),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert(),-1===i[10])e.projectionMatrix.copy(t.projectionMatrix),e.projectionMatrixInverse.copy(t.projectionMatrixInverse);else{const t=o+m,n=s+m,i=f-h,a=p+(r-h),d=l*s/n*t,u=c*s/n*t;e.projectionMatrix.makePerspective(i,a,d,u,t,n),e.projectionMatrixInverse.copy(e.projectionMatrix).invert()}}(D,C,L):D.projectionMatrix.copy(C.projectionMatrix),function(e,t,n){null===n?e.matrix.copy(t.matrixWorld):(e.matrix.copy(n.matrixWorld),e.matrix.invert(),e.matrix.multiply(t.matrixWorld));e.matrix.decompose(e.position,e.quaternion,e.scale),e.updateMatrixWorld(!0),e.projectionMatrix.copy(t.projectionMatrix),e.projectionMatrixInverse.copy(t.projectionMatrixInverse),e.isPerspectiveCamera&&(e.fov=2*En*Math.atan(1/e.projectionMatrix.elements[5]),e.zoom=1)}(e,D,r)},this.getCamera=function(){return D},this.getFoveation=function(){if(null!==p||null!==m)return c},this.setFoveation=function(e){c=e,null!==p&&(p.fixedFoveation=e),null!==m&&void 0!==m.fixedFoveation&&(m.fixedFoveation=e)},this.hasDepthSensing=function(){return null!==_.texture},this.getDepthSensingMesh=function(){return _.getMesh(D)},this.getCameraTexture=function(e){return g[e]};let V=null;const z=new An;z.setAnimationLoop(function(t,n){if(u=n.getViewerPose(d||s),h=n,null!==u){const t=u.views;null!==m&&(e.setRenderTargetFramebuffer(T,m.framebuffer),e.setRenderTarget(T));let n=!1;t.length!==D.cameras.length&&(D.cameras.length=0,n=!0);for(let r=0;r<t.length;r++){const i=t[r];let a=null;if(null!==m)a=m.getViewport(i);else{const t=f.getViewSubImage(p,i);a=t.viewport,0===r&&(e.setRenderTargetTextures(T,t.colorTexture,t.depthStencilTexture),e.setRenderTarget(T))}let o=P[r];void 0===o&&(o=new U,o.layers.enable(r),o.viewport=new k,P[r]=o),o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.quaternion,o.scale),o.projectionMatrix.fromArray(i.projectionMatrix),o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),o.viewport.set(a.x,a.y,a.width,a.height),0===r&&(D.matrix.copy(o.matrix),D.matrix.decompose(D.position,D.quaternion,D.scale)),!0===n&&D.cameras.push(o)}const r=a.enabledFeatures;if(r&&r.includes("depth-sensing")&&"gpu-optimized"==a.depthUsage&&f){const e=f.getDepthInformation(t[0]);e&&e.isValid&&e.texture&&_.init(e,a.renderState)}if(r&&r.includes("camera-access")&&(e.state.unbindTexture(),f))for(let e=0;e<t.length;e++){const n=t[e].camera;if(n){let e=g[n];e||(e=new ta,g[n]=e);const t=f.getCameraImage(n);e.sourceTexture=t}}}for(let e=0;e<x.length;e++){const t=R[e],r=x[e];null!==t&&void 0!==r&&r.update(t,n,d||s)}V&&V(t,n),n.detectedPlanes&&r.dispatchEvent({type:"planesdetected",data:n}),h=null}),this.setAnimationLoop=function(e){V=e},this.dispose=function(){}}}
```
</details>

### `la`

<details><summary>Class Code</summary>

```ts
class la{constructor(e={}){const{canvas:t=Sn(),context:r=null,depth:a=!0,stencil:o=!1,alpha:s=!1,antialias:l=!1,premultipliedAlpha:d=!0,preserveDrawingBuffer:u=!1,powerPreference:m="default",failIfMajorPerformanceCaveat:h=!1,reversedDepthBuffer:g=!1}=e;let v;if(this.isWebGLRenderer=!0,null!==r){if("undefined"!=typeof WebGLRenderingContext&&r instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");v=r.getContextAttributes().alpha}else v=s;const T=new Uint32Array(4),M=new Int32Array(4);let x=null,R=null;const A=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.toneMapping=D,this.toneMappingExposure=1,this.transmissionResolutionScale=1;const C=this;let L=!1;this._outputColorSpace=Tn;let P=0,U=0,w=null,y=-1,N=null;const O=new k,B=new k;let G=null;const V=new n(0);let z=0,W=t.width,X=t.height,Y=1,K=null,q=null;const j=new k(0,0,W,X),Z=new k(0,0,W,X);let $=!1;const Q=new ge;let J=!1,ee=!1;const te=new f,ne=new i,re=new k,ie={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let ae=!1;function oe(){return null===w?Y:1}let se,le,ce,de,ue,pe,me,he,_e,ve,Ee,Se,Te,Me,xe,Re,Ae,be,Ce,Le,Pe,Ue,De,we,ye=r;function Ie(e,n){return t.getContext(e,n)}try{const e={alpha:!0,depth:a,stencil:o,antialias:l,premultipliedAlpha:d,preserveDrawingBuffer:u,powerPreference:m,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Mn}`),t.addEventListener("webglcontextlost",Fe,!1),t.addEventListener("webglcontextrestored",Be,!1),t.addEventListener("webglcontextcreationerror",He,!1),null===ye){const t="webgl2";if(ye=Ie(t,e),null===ye)throw Ie(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function Ne(){se=new ir(ye),se.init(),Ue=new ea(ye,se),le=new On(ye,se,e,Ue),ce=new Qi(ye,se),le.reversedDepthBuffer&&g&&ce.buffers.depth.setReversed(!0),de=new sr(ye),ue=new Hi,pe=new Ji(ye,se,ce,ue,le,Ue,de),me=new Bn(C),he=new rr(C),_e=new bn(ye),De=new In(ye,_e),ve=new ar(ye,_e,de,De),Ee=new cr(ye,ve,_e,de),Ce=new lr(ye,le,pe),Re=new Fn(ue),Se=new Bi(C,me,he,se,le,De,Re),Te=new oa(C,ue),Me=new ki,xe=new ji(se),be=new yn(C,me,he,ce,Ee,v,d),Ae=new Zi(C,Ee,le),we=new sa(ye,de,le,ce),Le=new Nn(ye,se,de),Pe=new or(ye,se,de),de.programs=Se.programs,C.capabilities=le,C.extensions=se,C.properties=ue,C.renderLists=Me,C.shadowMap=Ae,C.state=ce,C.info=de}Ne();const Oe=new ra(C,ye);function Fe(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),L=!0}function Be(){console.log("THREE.WebGLRenderer: Context Restored."),L=!1;const e=de.autoReset,t=Ae.enabled,n=Ae.autoUpdate,r=Ae.needsUpdate,i=Ae.type;Ne(),de.autoReset=e,Ae.enabled=t,Ae.autoUpdate=n,Ae.needsUpdate=r,Ae.type=i}function He(e){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}function Ge(e){const t=e.target;t.removeEventListener("dispose",Ge),function(e){(function(e){const t=ue.get(e).programs;void 0!==t&&(t.forEach(function(e){Se.releaseProgram(e)}),e.isShaderMaterial&&Se.releaseShaderCache(e))})(e),ue.remove(e)}(t)}function Ve(e,t,n){!0===e.transparent&&e.side===fe&&!1===e.forceSinglePass?(e.side=c,e.needsUpdate=!0,$e(e,t,n),e.side=_,e.needsUpdate=!0,$e(e,t,n),e.side=fe):$e(e,t,n)}this.xr=Oe,this.getContext=function(){return ye},this.getContextAttributes=function(){return ye.getContextAttributes()},this.forceContextLoss=function(){const e=se.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=se.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return Y},this.setPixelRatio=function(e){void 0!==e&&(Y=e,this.setSize(W,X,!1))},this.getSize=function(e){return e.set(W,X)},this.setSize=function(e,n,r=!0){Oe.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(W=e,X=n,t.width=Math.floor(e*Y),t.height=Math.floor(n*Y),!0===r&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return e.set(W*Y,X*Y).floor()},this.setDrawingBufferSize=function(e,n,r){W=e,X=n,Y=r,t.width=Math.floor(e*r),t.height=Math.floor(n*r),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return e.copy(O)},this.getViewport=function(e){return e.copy(j)},this.setViewport=function(e,t,n,r){e.isVector4?j.set(e.x,e.y,e.z,e.w):j.set(e,t,n,r),ce.viewport(O.copy(j).multiplyScalar(Y).round())},this.getScissor=function(e){return e.copy(Z)},this.setScissor=function(e,t,n,r){e.isVector4?Z.set(e.x,e.y,e.z,e.w):Z.set(e,t,n,r),ce.scissor(B.copy(Z).multiplyScalar(Y).round())},this.getScissorTest=function(){return $},this.setScissorTest=function(e){ce.setScissorTest($=e)},this.setOpaqueSort=function(e){K=e},this.setTransparentSort=function(e){q=e},this.getClearColor=function(e){return e.copy(be.getClearColor())},this.setClearColor=function(){be.setClearColor(...arguments)},this.getClearAlpha=function(){return be.getClearAlpha()},this.setClearAlpha=function(){be.setClearAlpha(...arguments)},this.clear=function(e=!0,t=!0,n=!0){let r=0;if(e){let e=!1;if(null!==w){const t=w.texture.format;e=t===Ot||t===Nt||t===yt}if(e){const e=w.texture.type,t=e===S||e===Tt||e===xt||e===Mt||e===At||e===bt,n=be.getClearColor(),r=be.getClearAlpha(),i=n.r,a=n.g,o=n.b;t?(T[0]=i,T[1]=a,T[2]=o,T[3]=r,ye.clearBufferuiv(ye.COLOR,0,T)):(M[0]=i,M[1]=a,M[2]=o,M[3]=r,ye.clearBufferiv(ye.COLOR,0,M))}else r|=ye.COLOR_BUFFER_BIT}t&&(r|=ye.DEPTH_BUFFER_BIT),n&&(r|=ye.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),ye.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Fe,!1),t.removeEventListener("webglcontextrestored",Be,!1),t.removeEventListener("webglcontextcreationerror",He,!1),be.dispose(),Me.dispose(),xe.dispose(),ue.dispose(),me.dispose(),he.dispose(),Ee.dispose(),De.dispose(),we.dispose(),Se.dispose(),Oe.dispose(),Oe.removeEventListener("sessionstart",ke),Oe.removeEventListener("sessionend",We),Xe.stop()},this.renderBufferDirect=function(e,t,n,r,i,a){null===t&&(t=ie);const o=i.isMesh&&i.matrixWorld.determinant()<0,s=function(e,t,n,r,i){!0!==t.isScene&&(t=ie);pe.resetTextureUnits();const a=t.fog,o=r.isMeshStandardMaterial?t.environment:null,s=null===w?C.outputColorSpace:!0===w.isXRRenderTarget?w.texture.colorSpace:F,l=(r.isMeshStandardMaterial?he:me).get(r.envMap||o),c=!0===r.vertexColors&&!!n.attributes.color&&4===n.attributes.color.itemSize,d=!!n.attributes.tangent&&(!!r.normalMap||r.anisotropy>0),u=!!n.morphAttributes.position,f=!!n.morphAttributes.normal,p=!!n.morphAttributes.color;let m=D;r.toneMapped&&(null!==w&&!0!==w.isXRRenderTarget||(m=C.toneMapping));const h=n.morphAttributes.position||n.morphAttributes.normal||n.morphAttributes.color,_=void 0!==h?h.length:0,g=ue.get(r),v=R.state.lights;if(!0===J&&(!0===ee||e!==N)){const t=e===N&&r.id===y;Re.setState(r,e,t)}let E=!1;r.version===g.__version?g.needsLights&&g.lightsStateVersion!==v.state.version||g.outputColorSpace!==s||i.isBatchedMesh&&!1===g.batching?E=!0:i.isBatchedMesh||!0!==g.batching?i.isBatchedMesh&&!0===g.batchingColor&&null===i.colorTexture||i.isBatchedMesh&&!1===g.batchingColor&&null!==i.colorTexture||i.isInstancedMesh&&!1===g.instancing?E=!0:i.isInstancedMesh||!0!==g.instancing?i.isSkinnedMesh&&!1===g.skinning?E=!0:i.isSkinnedMesh||!0!==g.skinning?i.isInstancedMesh&&!0===g.instancingColor&&null===i.instanceColor||i.isInstancedMesh&&!1===g.instancingColor&&null!==i.instanceColor||i.isInstancedMesh&&!0===g.instancingMorph&&null===i.morphTexture||i.isInstancedMesh&&!1===g.instancingMorph&&null!==i.morphTexture||g.envMap!==l||!0===r.fog&&g.fog!==a?E=!0:void 0===g.numClippingPlanes||g.numClippingPlanes===Re.numPlanes&&g.numIntersection===Re.numIntersection?(g.vertexAlphas!==c||g.vertexTangents!==d||g.morphTargets!==u||g.morphNormals!==f||g.morphColors!==p||g.toneMapping!==m||g.morphTargetsCount!==_)&&(E=!0):E=!0:E=!0:E=!0:E=!0:(E=!0,g.__version=r.version);let S=g.currentProgram;!0===E&&(S=$e(r,t,i));let T=!1,M=!1,x=!1;const A=S.getUniforms(),b=g.uniforms;ce.useProgram(S.program)&&(T=!0,M=!0,x=!0);r.id!==y&&(y=r.id,M=!0);if(T||N!==e){ce.buffers.depth.getReversed()&&!0!==e.reversedDepth&&(e._reversedDepth=!0,e.updateProjectionMatrix()),A.setValue(ye,"projectionMatrix",e.projectionMatrix),A.setValue(ye,"viewMatrix",e.matrixWorldInverse);const t=A.map.cameraPosition;void 0!==t&&t.setValue(ye,ne.setFromMatrixPosition(e.matrixWorld)),le.logarithmicDepthBuffer&&A.setValue(ye,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&A.setValue(ye,"isOrthographic",!0===e.isOrthographicCamera),N!==e&&(N=e,M=!0,x=!0)}if(i.isSkinnedMesh){A.setOptional(ye,i,"bindMatrix"),A.setOptional(ye,i,"bindMatrixInverse");const e=i.skeleton;e&&(null===e.boneTexture&&e.computeBoneTexture(),A.setValue(ye,"boneTexture",e.boneTexture,pe))}i.isBatchedMesh&&(A.setOptional(ye,i,"batchingTexture"),A.setValue(ye,"batchingTexture",i._matricesTexture,pe),A.setOptional(ye,i,"batchingIdTexture"),A.setValue(ye,"batchingIdTexture",i._indirectTexture,pe),A.setOptional(ye,i,"batchingColorTexture"),null!==i._colorsTexture&&A.setValue(ye,"batchingColorTexture",i._colorsTexture,pe));const L=n.morphAttributes;void 0===L.position&&void 0===L.normal&&void 0===L.color||Ce.update(i,n,S);(M||g.receiveShadow!==i.receiveShadow)&&(g.receiveShadow=i.receiveShadow,A.setValue(ye,"receiveShadow",i.receiveShadow));r.isMeshGouraudMaterial&&null!==r.envMap&&(b.envMap.value=l,b.flipEnvMap.value=l.isCubeTexture&&!1===l.isRenderTargetTexture?-1:1);r.isMeshStandardMaterial&&null===r.envMap&&null!==t.environment&&(b.envMapIntensity.value=t.environmentIntensity);M&&(A.setValue(ye,"toneMappingExposure",C.toneMappingExposure),g.needsLights&&(U=x,(P=b).ambientLightColor.needsUpdate=U,P.lightProbe.needsUpdate=U,P.directionalLights.needsUpdate=U,P.directionalLightShadows.needsUpdate=U,P.pointLights.needsUpdate=U,P.pointLightShadows.needsUpdate=U,P.spotLights.needsUpdate=U,P.spotLightShadows.needsUpdate=U,P.rectAreaLights.needsUpdate=U,P.hemisphereLights.needsUpdate=U),a&&!0===r.fog&&Te.refreshFogUniforms(b,a),Te.refreshMaterialUniforms(b,r,Y,X,R.state.transmissionRenderTarget[e.id]),mi.upload(ye,Qe(g),b,pe));var P,U;r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(mi.upload(ye,Qe(g),b,pe),r.uniformsNeedUpdate=!1);r.isSpriteMaterial&&A.setValue(ye,"center",i.center);if(A.setValue(ye,"modelViewMatrix",i.modelViewMatrix),A.setValue(ye,"normalMatrix",i.normalMatrix),A.setValue(ye,"modelMatrix",i.matrixWorld),r.isShaderMaterial||r.isRawShaderMaterial){const e=r.uniformsGroups;for(let t=0,n=e.length;t<n;t++){const n=e[t];we.update(n,S),we.bind(n,S)}}return S}(e,t,n,r,i);ce.setMaterial(r,o);let l=n.index,c=1;if(!0===r.wireframe){if(l=ve.getWireframeAttribute(n),void 0===l)return;c=2}const d=n.drawRange,u=n.attributes.position;let f=d.start*c,p=(d.start+d.count)*c;null!==a&&(f=Math.max(f,a.start*c),p=Math.min(p,(a.start+a.count)*c)),null!==l?(f=Math.max(f,0),p=Math.min(p,l.count)):null!=u&&(f=Math.max(f,0),p=Math.min(p,u.count));const m=p-f;if(m<0||m===1/0)return;let h;De.setup(i,r,s,n,l);let _=Le;if(null!==l&&(h=_e.get(l),_=Pe,_.setIndex(h)),i.isMesh)!0===r.wireframe?(ce.setLineWidth(r.wireframeLinewidth*oe()),_.setMode(ye.LINES)):_.setMode(ye.TRIANGLES);else if(i.isLine){let e=r.linewidth;void 0===e&&(e=1),ce.setLineWidth(e*oe()),i.isLineSegments?_.setMode(ye.LINES):i.isLineLoop?_.setMode(ye.LINE_LOOP):_.setMode(ye.LINE_STRIP)}else i.isPoints?_.setMode(ye.POINTS):i.isSprite&&_.setMode(ye.TRIANGLES);if(i.isBatchedMesh)if(null!==i._multiDrawInstances)H("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),_.renderMultiDrawInstances(i._multiDrawStarts,i._multiDrawCounts,i._multiDrawCount,i._multiDrawInstances);else if(se.get("WEBGL_multi_draw"))_.renderMultiDraw(i._multiDrawStarts,i._multiDrawCounts,i._multiDrawCount);else{const e=i._multiDrawStarts,t=i._multiDrawCounts,n=i._multiDrawCount,a=l?_e.get(l).bytesPerElement:1,o=ue.get(r).currentProgram.getUniforms();for(let r=0;r<n;r++)o.setValue(ye,"_gl_DrawID",r),_.render(e[r]/a,t[r])}else if(i.isInstancedMesh)_.renderInstances(f,m,i.count);else if(n.isInstancedBufferGeometry){const e=void 0!==n._maxInstanceCount?n._maxInstanceCount:1/0,t=Math.min(n.instanceCount,e);_.renderInstances(f,m,t)}else _.render(f,m)},this.compile=function(e,t,n=null){null===n&&(n=e),R=xe.get(n),R.init(t),b.push(R),n.traverseVisible(function(e){e.isLight&&e.layers.test(t.layers)&&(R.pushLight(e),e.castShadow&&R.pushShadow(e))}),e!==n&&e.traverseVisible(function(e){e.isLight&&e.layers.test(t.layers)&&(R.pushLight(e),e.castShadow&&R.pushShadow(e))}),R.setupLights();const r=new Set;return e.traverse(function(e){if(!(e.isMesh||e.isPoints||e.isLine||e.isSprite))return;const t=e.material;if(t)if(Array.isArray(t))for(let i=0;i<t.length;i++){const a=t[i];Ve(a,n,e),r.add(a)}else Ve(t,n,e),r.add(t)}),R=b.pop(),r},this.compileAsync=function(e,t,n=null){const r=this.compile(e,t,n);return new Promise(t=>{function n(){r.forEach(function(e){ue.get(e).currentProgram.isReady()&&r.delete(e)}),0!==r.size?setTimeout(n,10):t(e)}null!==se.get("KHR_parallel_shader_compile")?n():setTimeout(n,10)})};let ze=null;function ke(){Xe.stop()}function We(){Xe.start()}const Xe=new An;function Ye(e,t,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)R.pushLight(e),e.castShadow&&R.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||Q.intersectsSprite(e)){r&&re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(te);const t=Ee.update(e),i=e.material;i.visible&&x.push(e,t,i,n,re.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(!e.frustumCulled||Q.intersectsObject(e))){const t=Ee.update(e),i=e.material;if(r&&(void 0!==e.boundingSphere?(null===e.boundingSphere&&e.computeBoundingSphere(),re.copy(e.boundingSphere.center)):(null===t.boundingSphere&&t.computeBoundingSphere(),re.copy(t.boundingSphere.center)),re.applyMatrix4(e.matrixWorld).applyMatrix4(te)),Array.isArray(i)){const r=t.groups;for(let a=0,o=r.length;a<o;a++){const o=r[a],s=i[o.materialIndex];s&&s.visible&&x.push(e,t,s,n,re.z,o)}}else i.visible&&x.push(e,t,i,n,re.z,null)}const i=e.children;for(let e=0,a=i.length;e<a;e++)Ye(i[e],t,n,r)}function Ke(e,t,n,r){const i=e.opaque,a=e.transmissive,o=e.transparent;R.setupLightsView(n),!0===J&&Re.setGlobalState(C.clippingPlanes,n),r&&ce.viewport(O.copy(r)),i.length>0&&je(i,t,n),a.length>0&&je(a,t,n),o.length>0&&je(o,t,n),ce.buffers.depth.setTest(!0),ce.buffers.depth.setMask(!0),ce.buffers.color.setMask(!0),ce.setPolygonOffset(!1)}function qe(e,t,n,r){if(null!==(!0===n.isScene?n.overrideMaterial:null))return;void 0===R.state.transmissionRenderTarget[r.id]&&(R.state.transmissionRenderTarget[r.id]=new I(1,1,{generateMipmaps:!0,type:se.has("EXT_color_buffer_half_float")||se.has("EXT_color_buffer_float")?E:S,minFilter:ot,samples:4,stencilBuffer:o,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:p.workingColorSpace}));const i=R.state.transmissionRenderTarget[r.id],a=r.viewport||O;i.setSize(a.z*C.transmissionResolutionScale,a.w*C.transmissionResolutionScale);const s=C.getRenderTarget(),l=C.getActiveCubeFace(),d=C.getActiveMipmapLevel();C.setRenderTarget(i),C.getClearColor(V),z=C.getClearAlpha(),z<1&&C.setClearColor(16777215,.5),C.clear(),ae&&be.render(n);const u=C.toneMapping;C.toneMapping=D;const f=r.viewport;if(void 0!==r.viewport&&(r.viewport=void 0),R.setupLightsView(r),!0===J&&Re.setGlobalState(C.clippingPlanes,r),je(e,n,r),pe.updateMultisampleRenderTarget(i),pe.updateRenderTargetMipmap(i),!1===se.has("WEBGL_multisampled_render_to_texture")){let e=!1;for(let i=0,a=t.length;i<a;i++){const a=t[i],o=a.object,s=a.geometry,l=a.material,d=a.group;if(l.side===fe&&o.layers.test(r.layers)){const t=l.side;l.side=c,l.needsUpdate=!0,Ze(o,n,r,s,l,d),l.side=t,l.needsUpdate=!0,e=!0}}!0===e&&(pe.updateMultisampleRenderTarget(i),pe.updateRenderTargetMipmap(i))}C.setRenderTarget(s,l,d),C.setClearColor(V,z),void 0!==f&&(r.viewport=f),C.toneMapping=u}function je(e,t,n){const r=!0===t.isScene?t.overrideMaterial:null;for(let i=0,a=e.length;i<a;i++){const a=e[i],o=a.object,s=a.geometry,l=a.group;let c=a.material;!0===c.allowOverride&&null!==r&&(c=r),o.layers.test(n.layers)&&Ze(o,t,n,s,c,l)}}function Ze(e,t,n,r,i,a){e.onBeforeRender(C,t,n,r,i,a),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),i.onBeforeRender(C,t,n,r,e,a),!0===i.transparent&&i.side===fe&&!1===i.forceSinglePass?(i.side=c,i.needsUpdate=!0,C.renderBufferDirect(n,t,r,i,e,a),i.side=_,i.needsUpdate=!0,C.renderBufferDirect(n,t,r,i,e,a),i.side=fe):C.renderBufferDirect(n,t,r,i,e,a),e.onAfterRender(C,t,n,r,i,a)}function $e(e,t,n){!0!==t.isScene&&(t=ie);const r=ue.get(e),i=R.state.lights,a=R.state.shadowsArray,o=i.state.version,s=Se.getParameters(e,i.state,a,t,n),l=Se.getProgramCacheKey(s);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=(e.isMeshStandardMaterial?he:me).get(e.envMap||r.environment),r.envMapRotation=null!==r.environment&&null===e.envMap?t.environmentRotation:e.envMapRotation,void 0===c&&(e.addEventListener("dispose",Ge),c=new Map,r.programs=c);let d=c.get(l);if(void 0!==d){if(r.currentProgram===d&&r.lightsStateVersion===o)return Je(e,s),d}else s.uniforms=Se.getUniforms(e),e.onBeforeCompile(s,C),d=Se.acquireProgram(s,l),c.set(l,d),r.uniforms=s.uniforms;const u=r.uniforms;return(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(u.clippingPlanes=Re.uniform),Je(e,s),r.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),r.lightsStateVersion=o,r.needsLights&&(u.ambientLightColor.value=i.state.ambient,u.lightProbe.value=i.state.probe,u.directionalLights.value=i.state.directional,u.directionalLightShadows.value=i.state.directionalShadow,u.spotLights.value=i.state.spot,u.spotLightShadows.value=i.state.spotShadow,u.rectAreaLights.value=i.state.rectArea,u.ltc_1.value=i.state.rectAreaLTC1,u.ltc_2.value=i.state.rectAreaLTC2,u.pointLights.value=i.state.point,u.pointLightShadows.value=i.state.pointShadow,u.hemisphereLights.value=i.state.hemi,u.directionalShadowMap.value=i.state.directionalShadowMap,u.directionalShadowMatrix.value=i.state.directionalShadowMatrix,u.spotShadowMap.value=i.state.spotShadowMap,u.spotLightMatrix.value=i.state.spotLightMatrix,u.spotLightMap.value=i.state.spotLightMap,u.pointShadowMap.value=i.state.pointShadowMap,u.pointShadowMatrix.value=i.state.pointShadowMatrix),r.currentProgram=d,r.uniformsList=null,d}function Qe(e){if(null===e.uniformsList){const t=e.currentProgram.getUniforms();e.uniformsList=mi.seqWithValue(t.seq,e.uniforms)}return e.uniformsList}function Je(e,t){const n=ue.get(e);n.outputColorSpace=t.outputColorSpace,n.batching=t.batching,n.batchingColor=t.batchingColor,n.instancing=t.instancing,n.instancingColor=t.instancingColor,n.instancingMorph=t.instancingMorph,n.skinning=t.skinning,n.morphTargets=t.morphTargets,n.morphNormals=t.morphNormals,n.morphColors=t.morphColors,n.morphTargetsCount=t.morphTargetsCount,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas,n.vertexTangents=t.vertexTangents,n.toneMapping=t.toneMapping}Xe.setAnimationLoop(function(e){ze&&ze(e)}),"undefined"!=typeof self&&Xe.setContext(self),this.setAnimationLoop=function(e){ze=e,Oe.setAnimationLoop(e),null===e?Xe.stop():Xe.start()},Oe.addEventListener("sessionstart",ke),Oe.addEventListener("sessionend",We),this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===L)return;if(!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),null===t.parent&&!0===t.matrixWorldAutoUpdate&&t.updateMatrixWorld(),!0===Oe.enabled&&!0===Oe.isPresenting&&(!0===Oe.cameraAutoUpdate&&Oe.updateCamera(t),t=Oe.getCamera()),!0===e.isScene&&e.onBeforeRender(C,e,t,w),R=xe.get(e,b.length),R.init(t),b.push(R),te.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),Q.setFromProjectionMatrix(te,xn,t.reversedDepth),ee=this.localClippingEnabled,J=Re.init(this.clippingPlanes,ee),x=Me.get(e,A.length),x.init(),A.push(x),!0===Oe.enabled&&!0===Oe.isPresenting){const e=C.xr.getDepthSensingMesh();null!==e&&Ye(e,t,-1/0,C.sortObjects)}Ye(e,t,0,C.sortObjects),x.finish(),!0===C.sortObjects&&x.sort(K,q),ae=!1===Oe.enabled||!1===Oe.isPresenting||!1===Oe.hasDepthSensing(),ae&&be.addToRenderList(x,e),this.info.render.frame++,!0===J&&Re.beginShadows();const n=R.state.shadowsArray;Ae.render(n,e,t),!0===J&&Re.endShadows(),!0===this.info.autoReset&&this.info.reset();const r=x.opaque,i=x.transmissive;if(R.setupLights(),t.isArrayCamera){const n=t.cameras;if(i.length>0)for(let t=0,a=n.length;t<a;t++){qe(r,i,e,n[t])}ae&&be.render(e);for(let t=0,r=n.length;t<r;t++){const r=n[t];Ke(x,e,r,r.viewport)}}else i.length>0&&qe(r,i,e,t),ae&&be.render(e),Ke(x,e,t);null!==w&&0===U&&(pe.updateMultisampleRenderTarget(w),pe.updateRenderTargetMipmap(w)),!0===e.isScene&&e.onAfterRender(C,e,t),De.resetDefaultState(),y=-1,N=null,b.pop(),b.length>0?(R=b[b.length-1],!0===J&&Re.setGlobalState(C.clippingPlanes,R.state.camera)):R=null,A.pop(),x=A.length>0?A[A.length-1]:null},this.getActiveCubeFace=function(){return P},this.getActiveMipmapLevel=function(){return U},this.getRenderTarget=function(){return w},this.setRenderTargetTextures=function(e,t,n){const r=ue.get(e);r.__autoAllocateDepthBuffer=!1===e.resolveDepthBuffer,!1===r.__autoAllocateDepthBuffer&&(r.__useRenderToTexture=!1),ue.get(e.texture).__webglTexture=t,ue.get(e.depthTexture).__webglTexture=r.__autoAllocateDepthBuffer?void 0:n,r.__hasExternalTextures=!0},this.setRenderTargetFramebuffer=function(e,t){const n=ue.get(e);n.__webglFramebuffer=t,n.__useDefaultFramebuffer=void 0===t};const et=ye.createFramebuffer();this.setRenderTarget=function(e,t=0,n=0){w=e,P=t,U=n;let r=!0,i=null,a=!1,o=!1;if(e){const s=ue.get(e);if(void 0!==s.__useDefaultFramebuffer)ce.bindFramebuffer(ye.FRAMEBUFFER,null),r=!1;else if(void 0===s.__webglFramebuffer)pe.setupRenderTarget(e);else if(s.__hasExternalTextures)pe.rebindTextures(e,ue.get(e.texture).__webglTexture,ue.get(e.depthTexture).__webglTexture);else if(e.depthBuffer){const t=e.depthTexture;if(s.__boundDepthTexture!==t){if(null!==t&&ue.has(t)&&(e.width!==t.image.width||e.height!==t.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");pe.setupDepthRenderbuffer(e)}}const l=e.texture;(l.isData3DTexture||l.isDataArrayTexture||l.isCompressedArrayTexture)&&(o=!0);const c=ue.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(i=Array.isArray(c[t])?c[t][n]:c[t],a=!0):i=e.samples>0&&!1===pe.useMultisampledRTT(e)?ue.get(e).__webglMultisampledFramebuffer:Array.isArray(c)?c[n]:c,O.copy(e.viewport),B.copy(e.scissor),G=e.scissorTest}else O.copy(j).multiplyScalar(Y).floor(),B.copy(Z).multiplyScalar(Y).floor(),G=$;0!==n&&(i=et);if(ce.bindFramebuffer(ye.FRAMEBUFFER,i)&&r&&ce.drawBuffers(e,i),ce.viewport(O),ce.scissor(B),ce.setScissorTest(G),a){const r=ue.get(e.texture);ye.framebufferTexture2D(ye.FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ye.TEXTURE_CUBE_MAP_POSITIVE_X+t,r.__webglTexture,n)}else if(o){const r=t;for(let t=0;t<e.textures.length;t++){const i=ue.get(e.textures[t]);ye.framebufferTextureLayer(ye.FRAMEBUFFER,ye.COLOR_ATTACHMENT0+t,i.__webglTexture,n,r)}}else if(null!==e&&0!==n){const t=ue.get(e.texture);ye.framebufferTexture2D(ye.FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ye.TEXTURE_2D,t.__webglTexture,n)}y=-1},this.readRenderTargetPixels=function(e,t,n,r,i,a,o,s=0){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=ue.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==o&&(l=l[o]),l){ce.bindFramebuffer(ye.FRAMEBUFFER,l);try{const o=e.textures[s],l=o.format,c=o.type;if(!le.textureFormatReadable(l))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!le.textureTypeReadable(c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-r&&n>=0&&n<=e.height-i&&(e.textures.length>1&&ye.readBuffer(ye.COLOR_ATTACHMENT0+s),ye.readPixels(t,n,r,i,Ue.convert(l),Ue.convert(c),a))}finally{const e=null!==w?ue.get(w).__webglFramebuffer:null;ce.bindFramebuffer(ye.FRAMEBUFFER,e)}}},this.readRenderTargetPixelsAsync=async function(e,t,n,r,i,a,o,s=0){if(!e||!e.isWebGLRenderTarget)throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let l=ue.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==o&&(l=l[o]),l){if(t>=0&&t<=e.width-r&&n>=0&&n<=e.height-i){ce.bindFramebuffer(ye.FRAMEBUFFER,l);const o=e.textures[s],c=o.format,d=o.type;if(!le.textureFormatReadable(c))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!le.textureTypeReadable(d))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");const u=ye.createBuffer();ye.bindBuffer(ye.PIXEL_PACK_BUFFER,u),ye.bufferData(ye.PIXEL_PACK_BUFFER,a.byteLength,ye.STREAM_READ),e.textures.length>1&&ye.readBuffer(ye.COLOR_ATTACHMENT0+s),ye.readPixels(t,n,r,i,Ue.convert(c),Ue.convert(d),0);const f=null!==w?ue.get(w).__webglFramebuffer:null;ce.bindFramebuffer(ye.FRAMEBUFFER,f);const p=ye.fenceSync(ye.SYNC_GPU_COMMANDS_COMPLETE,0);return ye.flush(),await Rn(ye,p,4),ye.bindBuffer(ye.PIXEL_PACK_BUFFER,u),ye.getBufferSubData(ye.PIXEL_PACK_BUFFER,0,a),ye.deleteBuffer(u),ye.deleteSync(p),a}throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(e,t=null,n=0){const r=Math.pow(2,-n),i=Math.floor(e.image.width*r),a=Math.floor(e.image.height*r),o=null!==t?t.x:0,s=null!==t?t.y:0;pe.setTexture2D(e,0),ye.copyTexSubImage2D(ye.TEXTURE_2D,n,0,0,o,s,i,a),ce.unbindTexture()};const tt=ye.createFramebuffer(),nt=ye.createFramebuffer();this.copyTextureToTexture=function(e,t,n=null,r=null,i=0,a=null){let o,s,l,c,d,u,f,p,m;null===a&&(0!==i?(H("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),a=i,i=0):a=0);const h=e.isCompressedTexture?e.mipmaps[a]:e.image;if(null!==n)o=n.max.x-n.min.x,s=n.max.y-n.min.y,l=n.isBox3?n.max.z-n.min.z:1,c=n.min.x,d=n.min.y,u=n.isBox3?n.min.z:0;else{const t=Math.pow(2,-i);o=Math.floor(h.width*t),s=Math.floor(h.height*t),l=e.isDataArrayTexture?h.depth:e.isData3DTexture?Math.floor(h.depth*t):1,c=0,d=0,u=0}null!==r?(f=r.x,p=r.y,m=r.z):(f=0,p=0,m=0);const _=Ue.convert(t.format),g=Ue.convert(t.type);let v;t.isData3DTexture?(pe.setTexture3D(t,0),v=ye.TEXTURE_3D):t.isDataArrayTexture||t.isCompressedArrayTexture?(pe.setTexture2DArray(t,0),v=ye.TEXTURE_2D_ARRAY):(pe.setTexture2D(t,0),v=ye.TEXTURE_2D),ye.pixelStorei(ye.UNPACK_FLIP_Y_WEBGL,t.flipY),ye.pixelStorei(ye.UNPACK_PREMULTIPLY_ALPHA_WEBGL,t.premultiplyAlpha),ye.pixelStorei(ye.UNPACK_ALIGNMENT,t.unpackAlignment);const E=ye.getParameter(ye.UNPACK_ROW_LENGTH),S=ye.getParameter(ye.UNPACK_IMAGE_HEIGHT),T=ye.getParameter(ye.UNPACK_SKIP_PIXELS),M=ye.getParameter(ye.UNPACK_SKIP_ROWS),x=ye.getParameter(ye.UNPACK_SKIP_IMAGES);ye.pixelStorei(ye.UNPACK_ROW_LENGTH,h.width),ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT,h.height),ye.pixelStorei(ye.UNPACK_SKIP_PIXELS,c),ye.pixelStorei(ye.UNPACK_SKIP_ROWS,d),ye.pixelStorei(ye.UNPACK_SKIP_IMAGES,u);const R=e.isDataArrayTexture||e.isData3DTexture,A=t.isDataArrayTexture||t.isData3DTexture;if(e.isDepthTexture){const n=ue.get(e),r=ue.get(t),h=ue.get(n.__renderTarget),_=ue.get(r.__renderTarget);ce.bindFramebuffer(ye.READ_FRAMEBUFFER,h.__webglFramebuffer),ce.bindFramebuffer(ye.DRAW_FRAMEBUFFER,_.__webglFramebuffer);for(let n=0;n<l;n++)R&&(ye.framebufferTextureLayer(ye.READ_FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ue.get(e).__webglTexture,i,u+n),ye.framebufferTextureLayer(ye.DRAW_FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ue.get(t).__webglTexture,a,m+n)),ye.blitFramebuffer(c,d,o,s,f,p,o,s,ye.DEPTH_BUFFER_BIT,ye.NEAREST);ce.bindFramebuffer(ye.READ_FRAMEBUFFER,null),ce.bindFramebuffer(ye.DRAW_FRAMEBUFFER,null)}else if(0!==i||e.isRenderTargetTexture||ue.has(e)){const n=ue.get(e),r=ue.get(t);ce.bindFramebuffer(ye.READ_FRAMEBUFFER,tt),ce.bindFramebuffer(ye.DRAW_FRAMEBUFFER,nt);for(let e=0;e<l;e++)R?ye.framebufferTextureLayer(ye.READ_FRAMEBUFFER,ye.COLOR_ATTACHMENT0,n.__webglTexture,i,u+e):ye.framebufferTexture2D(ye.READ_FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ye.TEXTURE_2D,n.__webglTexture,i),A?ye.framebufferTextureLayer(ye.DRAW_FRAMEBUFFER,ye.COLOR_ATTACHMENT0,r.__webglTexture,a,m+e):ye.framebufferTexture2D(ye.DRAW_FRAMEBUFFER,ye.COLOR_ATTACHMENT0,ye.TEXTURE_2D,r.__webglTexture,a),0!==i?ye.blitFramebuffer(c,d,o,s,f,p,o,s,ye.COLOR_BUFFER_BIT,ye.NEAREST):A?ye.copyTexSubImage3D(v,a,f,p,m+e,c,d,o,s):ye.copyTexSubImage2D(v,a,f,p,c,d,o,s);ce.bindFramebuffer(ye.READ_FRAMEBUFFER,null),ce.bindFramebuffer(ye.DRAW_FRAMEBUFFER,null)}else A?e.isDataTexture||e.isData3DTexture?ye.texSubImage3D(v,a,f,p,m,o,s,l,_,g,h.data):t.isCompressedArrayTexture?ye.compressedTexSubImage3D(v,a,f,p,m,o,s,l,_,h.data):ye.texSubImage3D(v,a,f,p,m,o,s,l,_,g,h):e.isDataTexture?ye.texSubImage2D(ye.TEXTURE_2D,a,f,p,o,s,_,g,h.data):e.isCompressedTexture?ye.compressedTexSubImage2D(ye.TEXTURE_2D,a,f,p,h.width,h.height,_,h.data):ye.texSubImage2D(ye.TEXTURE_2D,a,f,p,o,s,_,g,h);ye.pixelStorei(ye.UNPACK_ROW_LENGTH,E),ye.pixelStorei(ye.UNPACK_IMAGE_HEIGHT,S),ye.pixelStorei(ye.UNPACK_SKIP_PIXELS,T),ye.pixelStorei(ye.UNPACK_SKIP_ROWS,M),ye.pixelStorei(ye.UNPACK_SKIP_IMAGES,x),0===a&&t.generateMipmaps&&ye.generateMipmap(v),ce.unbindTexture()},this.initRenderTarget=function(e){void 0===ue.get(e).__webglFramebuffer&&pe.setupRenderTarget(e)},this.initTexture=function(e){e.isCubeTexture?pe.setTextureCube(e,0):e.isData3DTexture?pe.setTexture3D(e,0):e.isDataArrayTexture||e.isCompressedArrayTexture?pe.setTexture2DArray(e,0):pe.setTexture2D(e,0),ce.unbindTexture()},this.resetState=function(){P=0,U=0,w=null,ce.reset(),De.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return xn}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=p._getDrawingBufferColorSpace(e),t.unpackColorSpace=p._getUnpackColorSpace()}}
```
</details>


---